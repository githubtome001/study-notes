----------------------------------------------VUE核心基础知识----------------------------------------------------------------------------------	
	一、基本认识：渐进式JavaScript框架；作者: 尤雨溪(一位华裔前Google工程师)；作用: 动态构建用户界面
		英文官网: https://vuejs.org/；中文官网: https://cn.vuejs.org/
		特点：
			1) 遵循MVVM模式
			2) 编码简洁, 体积小, 运行效率高, 适合移动/PC 端开发
			3) 它本身只关注UI, 可以轻松引入 vue 插件或其它第三库开发项目
		与其它前端JS框架的关联：
			借鉴angular的模板和数据绑定技术；借鉴react的组件化和虚拟DOM技术；
		Vue扩展插件：
			1) vue-cli: vue 脚手架
			2) vue-resource(axios): ajax 请求
			3) vue-router: 路由
			4) vuex: 状态管理
			5) vue-lazyload: 图片懒加载
			6) vue-scroller: 页面滑动相关
			7) mint-ui: 基于 vue 的 UI 组件库(移动端)
			8) element-ui: 基于 vue 的 UI 组件库(PC 端)
		基本使用：
			如：<div id="app">
					<input type="text" v-model="username">
					<p>Hello, {{username}}</p>
				</div>
				<script type="text/javascript" src="../js/vue.js"></script>
				<script type="text/javascript">
					new Vue({
					el: '#app',
					data: {
						username: 'atguigu'
					}
					})
				</script>
		开发者工具调试：vuejs devtools
		理解Vue的MVVM：	
			View ------------>ViewModel----------->Model（扁平化的JS对象）
			DOM            数据绑定/DOM监听
		基础语法：
			模板理解：动态的html页面；包含了一些 JS 语法代码（双大括号表达式、指令(以v-开头的自定义标签属性)）；
			1、双大括号表达式：{{exp}}；功能: 向页面输出数据；可以调用对象的方法；
			2、强制数据绑定：功能: 指定变化的属性值；完整写法: v-bind:xxx='yyy'；简写: :xxx='yyy'；
			3、绑定事件监听：功能: 绑定指定事件名的回调函数；完整写法:v-on:keyup='xxx'；v-on:keyup='xxx(参数)' v-on:keyup.enter='xxx'等等；简写:@keyup='xxx'；@keyup.enter='xxx'；
			如：<div id="app">
					<h2>1. 双大括号表达式</h2>
					<p>{{msg}}</p>
					<p>{{msg.toUpperCase()}}</p>
					<h2>2. 指令一: 强制数据绑定</h2>
					<a href="url">访问指定站点</a><br><!--不能使用-->
					<a v-bind:href="url">访问指定站点 2</a><br>
					<a :href="url">访问指定站点 3</a><br>
					<h2>3. 指令二: 绑定事件监听</h2>
					<button v-on:click="handleClick">点我</button>
					<button @click="handleClick">点我 2</button>
				</div>
				<script type="text/javascript" src="../js/vue.js"></script>
				<script type="text/javascript">
					new Vue({
					el: '#app',
					data: {// data的所有属性都会成功 vm 对象的属性, 而模板页面中可以直接访问
						msg: 'NBA I Love This Game!',
						url: 'http://www.baidu.com'
					},
					methods: {
						handleClick () {
							alert('处理点击')
						}
					}
					})
				</script>
			4、计算属性和监视：
			   计算属性：在computed属性对象中定义计算属性的方法；在页面中使用{{方法名}}来显示计算的结果；
			   监视属性：通过通过vm对象的$watch()或watch配置来监视指定的属性；当属性变化时, 回调函数自动调用, 在函数内部进行计算；
			   计算属性高级：通过getter/setter实现对属性数据的显示和监视，计算属性存在缓存, 多次读取只执行一次getter计算；
			   如：<div id="demo">
						姓: <input type="text" placeholder="First Name" v-model="firstName"><br>
						名: <input type="text" placeholder="Last Name" v-model="lastName"><br>
						姓名 1(单向): <input type="text" placeholder="Full Name" v-model="fullName1"><br>
						姓名 2(单向): <input type="text" placeholder="Full Name" v-model="fullName2"><br>
						姓名 3(双向): <input type="text" placeholder="Full Name2" v-model="fullName3"><br>
				   </div>
				   <script type="text/javascript" src="../js/vue.js"></script>
					<script type="text/javascript">
					var vm = new Vue({
					el: '#demo',
					data: {
						firstName: 'Kobe',
						lastName: 'bryant',
						fullName2: 'Kobe bryant'
					},
					computed: {
						fullName: function () {
							return this.firstName + " " + this.lastName
						},
						fullName3: {
							get: function () {
								return this.firstName + " " + this.lastName
							},
							set: function (value) {
								var names = value.split(' ')
								this.firstName = names[0]
								this.lastName = names[1]
							}
						}
					},
					watch: {
						lastName: function (newVal, oldVal) {
							this.fullName2 = this.firstName + ' ' + newVal
						}
					}
					})
					vm.$watch('firstName', function (val) {
						this.fullName2 = val + ' ' + this.lastName
					})
					</script>
			5、class与style绑定：
			   理解：在应用界面中, 某个(些)元素的样式是变化的；class/style绑定就是专门用来实现动态样式效果的技术；
			   class绑定：:class='xxx'；表达式是字符串: 'classA'；表达式是对象: {classA:isA, classB: isB}；表达式是数组: ['classA', 'classB']；
			   style绑定：:style="{ color: activeColor, fontSize: fontSize + 'px' }"，其中activeColor/fontSize是data属性；
			   如：<style>
					.classA {
						color: red;
					}
					.classB {
						background: blue;
					}
					.classC {
						font-size: 20px;
					}
					</style>
					<div id="demo">
						<h2>1. class 绑定: :class='xxx'</h2>
						<p class="classB" :class="a">表达式是字符串: 'classA'</p>
						<p :class="{classA: isA, classB: isB}">表达式是对象: {classA:isA, classB: isB}</p>
						<p :class="['classA', 'classC']"> 表达式是数组: ['classA', 'classB']</p>
						<h2>2. style 绑定</h2>
						<p :style="{ color: activeColor, fontSize: fontSize +
						'px' }"</p>
						<button @click="update">更新</button>
					</div>
					<script type="text/javascript" src="../js/vue.js"></script>
					<script type="text/javascript">
					new Vue({
						el : '#demo',
						data : {
							a: 'classA',
							isA: true,
							isB: false,
							activeColor: 'red',
							fontSize: '20px'
						},
						methods : {
							update () {
								this.a = 'classC'
								this.isA = false
								this.isB = true
								this.activeColor = 'blue'
								this.fontSize = '30px'
							}
						}
					})
					</script>
			6、条件渲染：
			   条件渲染指令：v-if与v-else；v-show；比较：需要频繁切换v-show较好；当条件不成立时, v-if的所有子节点不会解析(项目中使用)；
			   如：<div id="demo">
						<h2 v-if="ok">表白成功</h2>
						<h2 v-else>表白失败</h2>
						<h2 v-show="ok">求婚成功</h2>
						<h2 v-show="!ok">求婚失败</h2>
						<br>
						<button @click="ok=!ok">切换</button>
					</div>
			    <script type="text/javascript" src="../js/vue.js"></script>
				<script type="text/javascript">
				var vm = new Vue({
				el: '#demo',
				data: {
					ok: false
				}
				})
				</script>
			7、列表渲染：
			   列表显示指令：数组: v-for / index；对象: v-for / key；
			   列表的更新显示：删除 item；替换 item；
			   列表的高级处理：列表过滤、列表排序；
			   如：<div id="demo">
					<h2>测试: v-for 遍历数组</h2>
					<ul>
						<li v-for="(p, index) in persons" :key="index">
						{{index}}--{{p.name}}--{{p.age}}
						--
						<button @click="deleteItem(index)">删除</button>
						--
						<button @click="updateItem(index, {name:'Jok',age:15})">更新</button>
						</li>
					</ul>
					<h2>测试: v-for 遍历对象</h2>
					<ul>
						<li v-for="(value, key) in persons[0]">
						{{ key }} : {{ value }}
						</li>
					</ul>
					</div>
					<script type="text/javascript" src="../js/vue.js"></script>
					<script type="text/javascript">
					new Vue({
						el: '#demo',
						data: {
						persons: [
							{id: 1, name: 'Tom', age: 13},
							{id: 2, name: 'Jack', age: 12},
							{id: 3, name: 'Bob', age: 14}
						]
						},
						methods: {
						deleteItem(index) {
							this.persons.splice(index, 1) //splice()；用于删除、修改、新增；
						},
						updateItem(index, p) {
							// this.persons[index] = p // 页面不会更新
							this.persons.splice(index, 1, p)
						}
						}
					})
					</script>
			   如：<div id="demo">
						<input type="text" name="searchName" placeholder="搜索指定用户名"
						v-model="searchName">
						<ul>
						<li v-for="(p, index) in filterPerson" :key="index">
						{{index}}--{{p.name}}--{{p.age}}
						</li>
						</ul>
						<button @click="setOrderType(1)">年龄升序</button>
						<button @click="setOrderType(2)">年龄降序</button>
						<button @click="setOrderType(0)">原本顺序</button>
					</div>
					<script type="text/javascript" src="../js/vue.js"></script>
					<script type="text/javascript">
					new Vue({
					el: '#demo',
					data: {
						orderType: 0, //0 代表不排序, 1 为升序, 2 为降序
						searchName: '',
						persons: [
							{id: 1, name: 'Tom', age: 13},
							{id: 2, name: 'Jack', age: 12},
							{id: 3, name: 'Bob', age: 17},
							{id: 4, name: 'Cat', age: 14},
							{id: 4, name: 'Mike', age: 14},
							{id: 4, name: 'Monica', age: 16}
						]
					},
					methods: {
						setOrderType (orderType) {
							this.orderType = orderType
						}
					},
					computed: {
						filterPerson() {
							// let 声明的变量只在 let 命令所在的代码块内有效；const 声明一个只读的常量，一旦声明，常量的值就不能改变；
							let {orderType, searchName, persons} = this
							// 过滤
							persons = persons.filter(p => p.name.indexOf(searchName)!=-1)
							// 排序
							if(orderType!==0) {
								persons = persons.sort(function (p1, p2) {
								if(orderType===1) {
									return p1.age-p2.age
								} else {
									return p2.age-p1.age
								}
								})
							}
							return persons
						}
					}
					})
					</script>
			8、事件处理：
			   绑定监听: v-on:xxx="fun"；@xxx="fun"；@xxx="fun(参数)"；默认事件形参: event；隐含属性对象: $event；
			   事件修饰符：.prevent: 阻止事件的默认行为event.preventDefault()；.stop: 停止事件冒泡event.stopPropagation()；
			   按键修饰符：.keycode: 操作的是某个keycode值的键；.keyName: 操作的某个按键名的键(少部分)；
			   如：<div id="example">
						<h2>1. 绑定监听</h2>
						<button v-on:click="test1">Greet</button>
						<button @click="test1">Greet2</button>
						<button @click="test2($event, 'hello')">Greet3</button>
						<h2>2. 事件修饰符</h2>
						<!-- 阻止事件默认行为 -->
						<a href="http://www.baidu.com" @click.prevent="test3">百度一下</a>
						<br/>
						<br/>
						<!-- 停止事件冒泡 -->
						<div style="width: 200px;height: 200px;background: red" @click="test4">
						<div style="width: 100px;height: 100px;background: green"
						@click.stop="test5"></div>
						</div>
						<h2>3. 按键修饰符</h2>
						<input @keyup.8="test6">
						<input @keyup.enter="test6">
					</div>
					<script type="text/javascript" src="../js/vue.js"></script>
					<script type="text/javascript">
					new Vue({
					el: '#example',
					data: {
						name: 'Vue.js'
					},
					methods: {
						test1 (event) {
							// 方法内 `this` 指向 vm
							// alert('Hello ' + this.name + '!')
							// `event` 是原生 DOM 事件
							alert(event.target.innerHTML)
						},
						test2 (event, msg) {
							alert(event.target.innerHTML + '---' + msg)
						},
						test3() {
							alert('阻止事件的默认行为')
						},
						test4() {
							alert('out')
						},
						test5() {
							alert('inner')
						},
						test6(event) {
							alert(event.keyCode + '---' + event.target.value)
						}
					}
					})
					</script>
			9、表单输入绑定：
			   使用v-model对表单数据自动收集；text/textarea password checkbox radio select；
			   如：<div id="demo">
						<form @submit.prevent="handleSubmit">
							<span>用户名: </span>
							<input type="text" v-model="user.username"><br>
							<span>密码: </span>
							<input type="password" v-model="user.pwd"><br>
							<span>性别: </span>
							<input type="radio" id="female" value="female" v-model="user.sex">
							<label for="female">女</label>
							<input type="radio" id="male" value="male" v-model="user.sex">
							<label for="male">男</label><br>
							<span>爱好: </span>
							<input type="checkbox" id="basket" value="basketball"
							v-model="user.likes">
							<label for="basket">篮球</label>
							<input type="checkbox" id="foot" value="football"
							v-model="user.likes">
							<label for="foot">足球</label>
							<input type="checkbox" id="pingpang" value="pingpang"
							v-model="user.likes">
							<label for="pingpang">乒乓</label><br>
							<span>城市: </span>
							<select v-model="user.cityId">
							<option value="">未选择</option>
							<option v-for="city in allCitys" :value="city.id">
							{{ city.name }}
							</option>
							</select><br>
							<span>介绍: </span>
							<textarea v-model="user.desc" rows="10"></textarea><br><br>
							<input type="submit" value="注册">
						</form>
					</div>
					<script type="text/javascript" src="../js/vue.js"></script>
					<script type="text/javascript">
					var vm = new Vue({
					el: '#demo',
					data: {
						user: {
							username: '',
							pwd: '',
							sex: 'female',
							likes: [],
							cityId: '',
							desc: '',
						},
						allCitys: [{id: 1, name: 'BJ'}, {id: 2, name: 'SZ'},{id: 4, name:
						'SH'}],
					},
					methods: {
						handleSubmit (event) {
							alert(JSON.stringify(this.user))
						}
					}
					})
					</script>
			10、Vue实例生命周期：
				生命周期流程图：
									new Vue()#新建实例
									    |   
									init event#初始化事件&生命周期
									    |    -------beforeCreated
									初始化注入&校验
									    |    -------created
									是否指定EL（元素）选项？N ---->当调用vm.$mount(el)函数时-|
									    Y ------------------------------------------------->是否指定template（模板）选项？N 将el外的html作为template编译
																								  Y                                           |
																							将template编译到render（渲染函数）中              |
																							              |                                   |
																							                              |   ----beforeMount
																							                           创建$el并用其替换el
																													      |  ----mounted
																														挂载完毕 （当data被修改时->beforeUpdate->虚拟DOM重新渲染并应用更新->updated->挂载完毕） 
																														  |
																														当调用vm.$destory()函数时  
																														  |  -----beforeDestroy
																														解除绑定销毁子组件以及事件监听器
																														  |
																														销毁完成（destroyed）
				Vue生命周期分析：	
				初始化显示：beforeCreate() * created() * beforeMount() * mounted()；
				更新状态: this.xxx = value；* beforeUpdate() * updated()；
				销毁 vue 实例: vm.$destory()；* beforeDestory() * destoryed()；
				常用的生命周期方法：
				created()/mounted(): 发送 ajax 请求, 启动定时器等异步任务；
				beforeDestory(): 做收尾工作, 如: 清除定时器；
				如：<div>
						<button @click="destoryVue">destory vue</button>
						<p v-show="isShowing">{{msg}}</p>
					</div>
					<script type="text/javascript" src="../js/vue.js"></script>
					<script type="text/javascript">
					var vue = new Vue({
					el: 'div',
					data: {
						msg: '尚硅谷 IT 教育',
						isShowing: true,
						persons: []
					},
					beforeCreate () {
						console.log('beforeCreate() msg=' + this.msg)
					},
					created () {
						console.log('created() msg='+this.msg)
						this.intervalId = setInterval(() => {
						console.log('-----')
						this.isShowing = !this.isShowing
						}, 1000)
					},
					beforeMount () {
						console.log('beforeMount() msg='+this.msg)
					},
					mounted () {
						console.log('mounted() msg='+this.msg)
					},
					beforeUpdate() {
						console.log('beforeUpdate isShowing='+this.isShowing)
					},
					updated () {
						console.log('updated isShowing='+this.isShowing)
					},
					beforeDestroy () {
						console.log('beforeDestroy() msg='+this.msg)
						clearInterval(this.intervalId)
					},
					destroyed () {
						console.log('destroyed() msg='+this.msg)
					},
					methods: {
						destoryVue () {
							vue.$destroy()
						}
						}
					})
					</script>		
			11、过渡&动画：
				理解：操作css的trasition或animation；vue会给目标元素添加/移除特定的class；
				      过渡的相关类名：xxx-enter-active: 指定显示的transition；xxx-leave-active: 指定隐藏的transition；xxx-enter/xxx-leave-to: 指定隐藏时的样式；
					Enter:
						Opacity：0   ------------> Opacity：1
					      v-enter                  v-enter-to
								   v-enter-active
					Leave
						Opacity：1   ------------> Opacity：0
					      v-enter                  v-enter-to
								   v-enter-active
				基本过渡动画的编码：
					在目标元素外包裹<transition name="xxx">；定义class样式；指定过渡样式: transition；指定隐藏时的样式: opacity/其它；
				如：<style>
					.fade-enter-active, .fade-leave-active {
					transition: opacity .5s
					}
					.fade-enter, .fade-leave-to {
					opacity: 0
					}
					/* 可以设置不同的进入和离开动画 */
					.slide-fade-enter-active {
					transition: all .3s ease;
					}
					.slide-fade-leave-active {
					transition: all .8s cubic-bezier(1.0, 0.5, 0.8, 1.0);
					}
					.slide-fade-enter, .slide-fade-leave-to {
					transform: translateX(10px);
					opacity: 0;
					}
					</style>
					<div id="demo1">
						<button @click="show = !show">
						Toggle1
						</button>
						<transition name="fade">
						<p v-if="show">hello</p>
						</transition>
					</div>
					<div id="demo2">
						<button @click="show = !show">
						Toggle2
						</button>
						<transition name="slide-fade">
						<p v-if="show">hello</p>
						</transition>
					</div>
					<script type="text/javascript" src="../js/vue.js"></script>
					<script type="text/javascript">
					new Vue({
					el: '#demo1',
						data: {
						show: true
						}
					})
					new Vue({
					el: '#demo2',
						data: {
						show: true
						}
					})
					</script>
				如：<style>
					.bounce-enter-active {
					animation: bounce-in .5s;
					}
					.bounce-leave-active {
					animation: bounce-in .5s reverse;
					}
					@keyframes bounce-in {
					0% {
					transform: scale(0);
					}
					50% {
					transform: scale(1.5);
					}
					100% {
					transform: scale(1);
					}
					}
					</style>
					<div id="test2">
						<button @click="show = !show">Toggle show</button>
						<br>
						<transition name="bounce">
						<p v-if="show" style="display: inline-block">Look at me!</p>
						</transition>
					</div>
					<script type="text/javascript" src="../js/vue.js"></script>
					<script>
					new Vue({
					el: '#test2',
						data: {
						show: true
						}
					})
					</script>	
			12、过滤器：功能: 对要显示的数据进行特定格式化后再显示；注意: 并没有改变原本的数据, 可是产生新的对应的数据；
				定义和使用过滤器：
					定义过滤器：Vue.filter(filterName, function(value[,arg1,arg2,...]){
								// 进行一定的数据处理
								return newValue
								})
					使用过滤器：
					<div>{{myData | filterName}}</div>
					<div>{{myData | filterName(arg)}}</div>
				如：<div id="test">
						<p>当前时间为: {{currentTime}}</p>
						<p>当前时间 1 为: {{currentTime | dateStr}}</p>
						<p>当前时间 2 为: {{currentTime | dateStr('YYYY-MM-DD')}}</p>
						<p>当前时间 3 为: {{currentTime | dateStr('HH:mm:ss')}}</p>
					</div>
					<script type="text/javascript" src="../js/vue.js"></script>
					<script type="text/javascript"
						src="https://cdn.bootcss.com/moment.js/2.19.0/moment.js"></script>
					<script>
					// 注册过滤器
					Vue.filter('dateStr', function (value, format) {
						return moment(value).format(format || 'YYYY-MM-DD HH:mm:ss')
					})
					new Vue({
					el: '#test',
					data: {
						currentTime: new Date()
					}
					})
					</script>
			13、内置指令与自定义指令：
				常用内置指令：
				1) v:text : 更新元素的 textContent
				2) v-html : 更新元素的 innerHTML
				3) v-if : 如果为 true, 当前标签才会输出到页面
				   v-else: 如果为 false, 当前标签才会输出到页面
				5) v-show : 通过控制display样式来控制显示/隐藏
				6) v-for : 遍历数组/对象
				7) v-on : 绑定事件监听, 一般简写为@
				8) v-bind : 强制绑定解析表达式, 可以省略 v-bind
				9) v-model : 双向数据绑定
				10) ref : 指定唯一标识, vue对象通过$refs属性访问这个元素对象
				11) v-cloak : 防止闪现, 与 css 配合: [v-cloak] { display: none }
				自定义指令：
				注册全局指令：
				Vue.directive('my-directive', function(el, binding){
					el.innerHTML = binding.value.toupperCase()
				})
				注册局部指令：
				directives : {
					'my-directive' : {
						bind (el, binding) {
							el.innerHTML = binding.value.toupperCase()
						}
					}
				}
				使用指令：v-my-directive='xxx'
				如：（内置指令）
				<style>
				[v-cloak] {
				display: none
				}
				</style>
				<div id="example">
					<p v-text="url"></p>
					<p v-html="url"></p>
					<img :id="myid" :src="imageSrc">
					<p>
					<span ref="message">atguigu.com</span>
					<button @click="showMsg">显示左侧文本</button>
					</p>
					<p v-cloak>{{url}}</p>
				</div>
				<script type="text/javascript" src="../js/vue.js"></script>
				<script type="text/javascript">
				alert('模拟加载慢')
				new Vue({
				el: '#example',
				data: {
					url: '<a href="http://www.atguigu.com">尚硅谷</a>',
					myid: 'abc123',
					imageSrc: 'http://cn.vuejs.org/images/logo.png'
				},
				methods: {
					showMsg: function () {
						alert(this.$refs.message.textContent)
					}
				}
				})
				</script>
				如：（自定义指令）；需求：功能类型于 v-text, 但转换为全大写；功能类型于 v-text, 但转换为全小写；
				<div id="demo1">
					<p v-upper-text="msg"></p>
					<p v-lower-text="msg"></p>
				</div>
				<div id="demo2">
					<p v-upper-text="msg2"></p>
					<p v-lower-text="msg2"></p> <!--局部指令, 此处不能使用-->
				</div>
				<script type="text/javascript" src="../js/vue.js"></script>
				<script type="text/javascript">
				//注册全局指令
				Vue.directive('upper-text', function (el, binding) {
				el.innerHTML = binding.value.toUpperCase()
				})
				new Vue({
				el: '#demo1',
				data: {
					msg: 'NBA love this game!'
				},
				directives: { // 注册局部指令
					'lower-text': {
						bind (el, binding) {
							el.innerHTML = binding.value.toLowerCase()
						}
					}
				}
				})
				new Vue({
				el: '#demo2',
				data: {
					msg2: 'I Like You'
				}
				})
				</script>
			14、自定义插件：Vue 插件是一个包含 install 方法的对象；通过 install 方法给 Vue 或 Vue 实例添加方法，定义全局指令等；
				如：/**
					* 自定义 Vue 插件
					*/
					(function () {
					const MyPlugin = {}
					MyPlugin.install = function (Vue, options) {
					// 1. 添加全局方法或属性
					Vue.myGlobalMethod = function () {
						alert('Vue 函数对象方法执行')
					}
					// 2. 添加全局资源
					Vue.directive('my-directive', function (el, binding) {
						el.innerHTML = "MyPlugin my-directive " + binding.value
					})
					// 3. 添加实例方法
					Vue.prototype.$myMethod = function () {
						alert('vue 实例对象方法执行')
					}
					}
					window.MyPlugin = MyPlugin
					})()
					页面使用插件：
					<div id="demo">
					<!--使用自定义指令-->
					<p v-my-directive="msg"></p>
					</div>
					<script type="text/javascript" src="../js/vue.js"></script>
					<script type="text/javascript" src="vue-myPlugin.js"></script>
					<script type="text/javascript">
					//使用自定义插件
					Vue.use(MyPlugin)
					var vm = new Vue({
					el: '#demo',
					data: {
						msg: 'atguigu'
					}
					})
					//调用自定义的静态方法
					Vue.myGlobalMethod()
					//调用自定义的对象方法
					vm.$myMethod()
					</script>
	二、Vue组件化编码：
		使用 vue-cli 创建模板项目：vue-cli 是 vue 官方提供的脚手架工具；github: https://github.com/vuejs/vue-cli；作用: 从 https://github.com/vuejs-templates 下载模板项目；
		创建 vue 项目：
			npm install -g vue-cli 
			vue init webpack vue_demo
			cd vue_demo
			npm install
			npm run dev
			访问: http://localhost:8080/ 
		模板项目的结构：
			|-- build : webpack 相关的配置文件夹(基本不需要修改)
				|-- dev-server.js : 通过 express 启动后台服务器
			|-- config: webpack 相关的配置文件夹(基本不需要修改)
				|-- index.js: 指定的后台服务的端口号和静态资源文件夹
			|-- node_modules
			|-- src : 源码文件夹
				|-- components: vue 组件及其相关资源文件夹
				|-- App.vue: 应用根主组件
				|-- main.js: 应用入口 js
			|-- static: 静态资源文件夹
			|-- .babelrc: babel 的配置文件
			|-- .eslintignore: eslint 检查忽略的配置
			|-- .eslintrc.js: eslint 检查的配置
			|-- .gitignore: git 版本管制忽略的配置
			|-- index.html: 主页面文件
			|-- package.json: 应用包配置文件
			|-- README.md: 应用描述说明的 readme 文件
		项目的打包与发布：
			打包：npm run build；
			发布 1: 使用静态服务器工具包；
					npm install -g serve
					serve dist
					访问: http://localhost:5000
				 2：使用动态 web 服务器(tomcat、nginx)
					修改配置: webpack.prod.conf.js
					output: {
						publicPath: '/xxx/' //打包文件夹的名称
					}
					重新打包:
					npm run build
					修改 dist 文件夹为项目名称: xxx
					将 xxx 拷贝到运行的 tomcat 的 webapps 目录下
					访问: http://localhost:8080/xxx
		ESLint：
			说明：ESLint 是一个代码规范检查工具；它定义了很多特定的规则, 一旦你的代码违背了某一规则, eslint会作出非常有用的提示；官网: http://eslint.org/；基本已替代以前的 JSLint；
			ESLint 提供支持：ES； JSX； style 检查； 自定义错误和提示；
			ESLint 提供校验：语法错误校验；不重要或丢失的标点符号，如分号；没法运行到的代码块（使用过 WebStorm 的童鞋应该了解）；未被使用的参数提醒；确保样式的统一规则，如 sass 或者 less；检查变量的命名；
			规则的错误等级有三种：
				1) 0：关闭规则。
				2) 1：打开规则，并且作为一个警告（信息打印黄色字体）
				3) 2：打开规则，并且作为一个错误（信息打印红色字体）
			相关配置文件：
				1) .eslintrc.js : 全局规则配置文件
				'rules': {
					'no-new': 1
				}
				2) 在 js/vue 文件中修改局部规则
				/* eslint-disable no-new */
				new Vue({
					el: 'body', 
					components: { App }
				})
				3) .eslintignore: 指令检查忽略的文件
				*.js 
				*.vue
		组件定义与使用：
			vue 文件的组成(3 个部分)：
			1) 模板页面
				<template>
					页面模板
				</template>
			2) JS 模块对象
				<script>
				export default {
					data() {return {}}, methods: {}, computed: {}, components: {}
				}
				</script>
			3) 样式
				<style>
					样式定义
				</style>
		基本使用：引入组件；映射成组件标签；使用组件标签；
			如：<template>
				<HelloWorld></HelloWorld>
				<hello-world></hello-world>
				</template>
				<script>
				import HelloWorld from './components/HelloWorld' 
				export default {
					components: {
						HelloWorld
					}
				}
				</script>
			关于标签名与标签属性名书写问题：写法一: 一模一样；写法二: 大写变小写, 并用-连接；
		组件间通信：
			组件间通信基本原则：不要在子组件中直接修改父组件的状态数据；数据在哪, 更新数据的行为(函数)就应该定义在哪；
			组件间通信方式：props；自定义事件；消息订阅与发布(如: pubsub 库)；slot；vuex；
				props；
					使用组件标签时：<my-component name='tom' :age='3' :set-name='setName'></my-component>；
					定义 MyComponent 时：在组件内声明所有的 props				
					方式一: 只指定名称
					props: ['name', 'age', 'setName']
					方式二: 指定名称和类型
					props: {
					name: String, age: Number, setNmae: Function
					}
					方式三: 指定名称/类型/必要性/默认值
					props: {
						name: {type: String, required: true, default:xxx}, 
						age: {type: Number, required: true, default:xxx},
						setNmae: {type: Function, required: true, default:xxx}
					}
					如：//App.vue父组件
					<template>
					  <div id="app">
						<users v-bind:users="users"></users>//前者自定义名称便于子组件调用，后者要传递数据名
					  </div>
					</template>
					<script>
					import Users from "./components/Users"
					export default {
					  name: 'App',
					  data(){
						return{
						  users:["Henry","Bucky","Emily"]
						}
					  },
					  components:{
						"users":Users
					  }
					}
					//users子组件
					<template>
					  <div class="hello">
						<ul>
						  <li v-for="user in users">{{user}}</li>
						</ul>
					  </div>
					</template>
					<script>
					export default {
					  name: 'HelloWorld',
					  props:{
						users:{//这个就是父组件中子标签自定义名字
						  type:Array,
						  required:true
						}
					  }
					}
					</script>					
				注意：此方式用于父组件向子组件传递数据；所有标签属性都会成为组件对象的属性，模板页面可以直接引用；
				问题:
					a. 如果需要向非子后代传递数据必须多层逐层传递；b. 兄弟组件间也不能直接 props 通信, 必须借助父组件才可以；
				VUE自定义事件：
				   绑定事件监听（父组件）：
				    //方式一: 通过v-on绑定
					@delete_todo="deleteTodo"
					//方式二: 通过$on()
					this.$refs.xxx.$on('delete_todo', function (todo) {
						this.deleteTodo(todo)
					})
				   触发事件（子组件）：				    
					this.$emit(eventName, data)//触发事件(只能在父组件中接收)
				   如：// 子组件
					<template>
					  <header>
						<h1 @click="changeTitle">{{title}}</h1>//绑定一个点击事件
					  </header>
					</template>
					<script>
					export default {
					  name: 'app-header',
					  data() {
						return {
						  title:"Vue.js Demo"
						}
					  },
					  methods:{
						changeTitle() {
						  this.$emit("titleChanged","子向父组件传值");//自定义事件，传递值“子向父组件传值”
						}
					  }
					}
					</script>
				    // 父组件
					<template>
					  <div id="app">
						<app-header v-on:titleChanged="updateTitle" ></app-header>//与子组件titleChanged自定义事件保持一致
						<!-- 或 
						<app-header ref="titleChanged"></app-header> -->
					   // updateTitle($event)接受传递过来的文字
						<h2>{{title}}</h2>
					  </div>
					</template>
					<script>
					import Header from "./components/Header"
					export default {
					  name: 'App',
					  data(){
						return{
						  title:"传递的是一个值"
						}
					  },
					  /*mounted(){
						  this.$refs.titleChanged.$on('titleChanged', function (event) {
								this.updateTitle(event)
						  })
					  },*/
					  methods:{
						updateTitle(event){//声明这个函数
						  this.title = event;
						}
					  },
					  components:{
					   "app-header":Header,
					  }
					}
					</script>
				注意：此方式只用于子组件向父组件发送消息(数据)；问题: 隔代组件或兄弟组件间通信此种方式不合适；
				消息订阅与发布(PubSubJS库)：
				订阅消息：PubSub.subscribe('msg', function(msg, data){})
				发布消息：PubSub.publish('msg', data)
				如：
				<template>
				  <section class="jumbotron">
					<h3 class="jumbotron-heading">Search Github Users</h3>
					<div>
					  <input type="text" placeholder="enter the name you search" v-model="searchName"/>
					  <button @click="search">Search</button>
					</div>
				  </section>
				</template>
				<script>
				  import PubSub from 'pubsub-js'
				  export default {
					data () {
					  return {
						searchName: ''
					  }
					},
					methods: {
					  search () {
						const searchName = this.searchName.trim()
						if(searchName) {
						  PubSub.publish('search', searchName) //分发一个search的消息
						}
					  }
					}
				  }
				</script>
				<template>
				  <div>
					<h2 v-show="firstView">请输入关键字搜索</h2>
					<h2 v-show="loading">请求中...</h2>
					<h2 v-show="errorMsg">{{errorMsg}}</h2>
					<div class="row" v-show="users.length>0">
					  <div class="card" v-for="(user,index) in users" :key="index">
						<a :href="user.url" target="_blank">
						  <img :src="user.avatarUrl" style='width: 100px'/>
						</a>
						<p class="card-text">{{user.username}}</p>
					  </div>
					</div>
				  </div>
				</template>
				<script>
				  import PubSub from 'pubsub-js'
				  import axios from 'axios'
				  export default {
					data () {
					  return {
						firstView: true, // 是否显示初始页面
						loading: false, // 是否正在请求中
						users: [], // 用户数组
						errorMsg: ''  //错误信息
					  }
					},
					mounted () {
					  // 订阅消息(search)
					  PubSub.subscribe('search', (message,searchName) => { //点击了搜索, 发ajax请求进行搜索
						// 更新数据(请求中)
						this.firstView = false
						this.loading = true
						this.users = []
						this.errorMsg = ''
						// 发ajax请求进行搜索
						const url = `https://api.github.com/search/users?q=${searchName}`
						axios.get(url)
						  .then(response => {
							// 成功了, 更新数据(成功)
							this.loading = false
							this.users = response.data.items.map(item => ({
							  url: item.html_url,
							  avatarUrl: item.avatar_url,
							  username: item.login
							}))
						  })
						  .catch(error => {
							// 失败了, 更新数据(失败)
							this.loading = false
							this.errorMsg = '请求失败!'
						  })
					  })
					}
				  }
				</script>
				注意：此方式可实现任意关系组件间通信(数据)；
				总结：触发事件 (发布消息)：DOM 事件: 用户在浏览器上对应的界面上做对应的操作；自定义: 编码手动触发；
					  绑定事件监听 (订阅消息)：目标: 标签元素<button> ；事件名(类型): click/focus ；回调函数: function(event){}；
				slot：
				理解：此方式用于父组件向子组件传递`标签数据`；
				子组件: Child.vue；
				如：<template>
					<div>
					<slot name="xxx">不确定的标签结构 1</slot>
					<div>组件确定的标签结构</div>
					<slot name="yyy">不确定的标签结构 2</slot>
					</div>
					</template>				
				父组件: Parent.vue；
				<child>
				<div slot="xxx">xxx 对应的标签结构</div>
				<div slot="yyy">yyyy 对应的标签结构</div>
				</child>
		vue-ajax：
			Vue项目中常用的 2 个 ajax 库；vue-resource：vue 插件，非官方库，vue1.x 使用广泛；axios：通用的 ajax 请求库, 官方推荐，vue2.x 使用广泛；
			vue-resource：
			在线文档：https://github.com/pagekit/vue-resource/blob/develop/docs/http.md
			下载：npm install vue-resource --save；
			如：// 引入模块
			import VueResource from 'vue-resource' // 使用插件
			Vue.use(VueResource)
			// 通过 vue/组件对象发送 ajax 请求
			this.$http.get('/someUrl').then((response) => {
			// success callback
			console.log(response.data) //返回结果数据
			}, (response) => {
			// error callback
			console.log(response.statusText) //错误信息
			})
			vue-axios：
			下载：npm install axios --save；
			如：// 引入模块
			import axios from 'axios' // 发送 ajax 请求
			axios.get(url)
			.then(response => {
			console.log(response.data) // 得到返回结果数据
			})
			.catch(error => {
			console.log(error.message)
			})
			测试：接口 1: https://api.github.com/search/repositories?q=v&sort=stars
				  接口 2: https://api.github.com/search/users?q=aa
		VUE UI组件库：
			常用：Mint UI:
				  主页: http://mint-ui.github.io/#!/zh-cn；
				  说明: 饿了么开源的基于 vue 的移动端 UI 组件库；
				  Elment UI:
				  主页: http://element-cn.eleme.io/#/zh-CN；
				  说明: 饿了么开源的基于 vue 的 PC 端 UI 组件库；
			使用 Mint UI：
				下载：npm install mint-ui --save；
				实现按需打包：
				1. 下载
				npm install babel-plugin-component --save-dev；
				2. 修改 babel 配置
				"plugins": ["transform-runtime",["component", [
				{
				"libraryName": "mint-ui",
				"style": true
				}
				]]]
				组件分类：标签组件；非标签组件；
				使用：
				如：#index.html
				<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1,
				minimum-scale=1, user-scalable=no" />
				<script
				src="https://as.alipayobjects.com/g/component/fastclick/1.0.6/fastclick.js"></scrip
				t>
				<script>
				if ('addEventListener' in document) {
				document.addEventListener('DOMContentLoaded', function() {
				FastClick.attach(document.body);
				}, false);
				}
				if(!window.Promise) {
				document.writeln('<script
				src="https://as.alipayobjects.com/g/component/es6-promise/3.2.2/es6-promise.min.js"
				'+'>'+'<'+'/'+'script>');
				}
				</script>
				#main.js
				import {Button} from 'mint-ui'
				Vue.component(Button.name, Button)
				#App.vue
				<template>
				<mt-button @click="handleClick" type="primary" style="width: 100%">Test</mt-button>
				</template>
				<script>
				import {Toast} from 'mint-ui'
				export default {
					methods: {
					handleClick () {
						Toast('点击了测试');
					}
					}
				}
				</script>
		vue-router：
			理解：路由器；
			说明：官方提供的用来实现 SPA（单页应用） 的 vue 插件；
			官方文档：github: https://github.com/vuejs/vue-router；中文文档: http://router.vuejs.org/zh-cn/；
			下载: npm install vue-router --save；
			API说明：
			1) VueRouter(): 用于创建路由器的构建函数
			new VueRouter({
			// 多个配置项
			})
			2) 路由配置，src/router/index.js；
			routes: [
			{ // 一般路由
			path: '/about', 
			component: About
			},
			{ // 自动跳转路由
			path: '/', redirect: '/about' }
			]
			3) 注册路由器，main.js入口注册
			import router from './router' 
			new Vue({
			router
			})
			4) 使用路由组件标签；
			1. <router-link>: 用来生成路由链接
			<router-link to="/xxx">Go to XXX</router-link>
			2. <router-view>: 用来显示当前路由组件界面
			<router-view></router-view>
			基本路由组件：Home.vue、About.vue；
			应用组件: App.vue；
			<div>
			<!--路由链接-->
			<router-link to="/about">About</router-link>
			<router-link to="/home">Home</router-link>
			<!--用于渲染当前路由组件-->
			<router-view></router-view>
			</div>
			路由器模块：src/router/index.js；
			export default new VueRouter({
			routes: [
			{
			path: '/', redirect: '/about' },{
			path: '/about', component: About
			},{
			path: '/home', component: Home
			}
			]
			})
			注册路由器: main.js；
			import Vue from 'vue' 
			import router from './router' // 创建VUE配置路由器
			new Vue({
				el: '#app', 
				router, 
				render: h => h(app)
			})
			优化路由器配置：linkActiveClass: 'active', // 指定选中的路由链接的class；
			总结: 编写使用路由的 3 步：定义路由组件；注册路由；使用路由：<router-link> <router-view>
			嵌套路由：
			子路由组件：News.vue、Message.vue；
			配置嵌套路由: router/index.js；
			path: '/home', 
			component: home, 
			children: [
			{
			path: 'news', component: News
			},
			{
			path: 'message', component: Message
			}
			]
			路由链接: Home.vue；
			<router-link to="/home/news">News</router-link>
			<router-link to="/home/message">Message</router-link>
			<router-view></route-view>
			向路由组件传递数据：
			方式 1: 路由路径携带参数(param/query)：
			1) 配置路由
			children: [
			{
			path: 'mdetail/:id', 
			component: MessageDetail
			}
			]
			2) 路由路径
			<router-link :to="'/home/message/mdetail/'+m.id">{{m.title}}</router-link>
			3) 路由组件中读取请求参数
			this.$route.params.id
			方式 2: <router-view>属性携带数据：
			<router-view :msg="msg"></router-view>
			缓存路由组件对象：
			理解：默认情况下, 被切换的路由组件对象会死亡释放，再次回来时是重新创建的；如果可以缓存路由组件对象, 可以提高用户体验；
			使用：<keep-alive>
					<router-view></router-view>
				</keep-alive>
		编程式路由导航：
			相关API：
			1) this.$router.push(path): 相当于点击路由链接(可以返回到当前路由界面)
			2) this.$router.replace(path): 用新路由替换当前路由(不可以返回到当前路由界面)
			3) this.$router.back(): 请求(返回)上一个记录路由
			4) this.$router.go(-1): 请求(返回)上一个记录路由
			5) this.$router.go(1): 请求下一个记录路由
			完整示例说明：
			#入口JS、main.js
			import Vue from 'vue'
			import App from './App.vue'
			import router from './router'
			/* eslint-disable no-new */
			new Vue({
			  el: '#app',
			  components: {App}, // 映射组件标签
			  template: '<App/>', // 指定需要渲染到页面的模板
			  router  // 注册路由器
			})
			#App.vue
			<template>
			  <div>
				<div class="row">
				  <div class="col-xs-offset-2 col-xs-8">
					<div class="page-header"><h2>Router Test</h2></div>
				  </div>
				</div>
				<div class="row">
				  <div class="col-xs-2 col-xs-offset-2">
					<div class="list-group">
					  <!--生成路由链接-->
					  <router-link to="/about" class="list-group-item">About</router-link>
					  <router-link to="/home" class="list-group-item">Home</router-link>
					</div>
				  </div>
				  <div class="col-xs-6">
					<div class="panel">
					  <div class="panel-body">
						<!--显示当前组件-->
						<keep-alive>
						  <router-view :msg="abc"></router-view>
						</keep-alive>
					  </div>
					</div>
				  </div>
				</div>
			  </div>
			</template>
			<script>
			  export default {}
			</script>
			#index.js
			import Vue from 'vue'
			import VueRouter from 'vue-router'
			import About from '../pages/About.vue'
			import Home from '../pages/Home.vue'
			import News from '../pages/News.vue'
			import Message from '../pages/Message.vue'
			import MessageDetail from '../pages/MessageDetail.vue'
			// 内部定义并注册了2个组件标签(router-link/router-view)，给组件对象添加了2个属性:1. $router: 路由器；2. $route: 当前路由
			Vue.use(VueRouter)
			export default new VueRouter ({
			  // 注册应用中所有的路由
			  routes: [
				{
				  path: '/about',
				  component: About
				},
				{
				  path: '/home',
				  component: Home,
				  children: [
					{
					  path: '/home/news',
					  component: News
					},
					{
					  path: 'message',
					  component: Message,
					  children: [
						{
						  path:'detail/:id',
						  component: MessageDetail
						}
					  ]
					},
					{
					  path: '',
					  redirect: '/home/news'
					}
				  ]
				},
				{
				  path: '/',
				  redirect: '/about'
				}
			  ]
			})
			#Home.vue
			<template>
			  <div>
				<h2>Home</h2>
				<div>
				  <ul class="nav nav-tabs">
					<li><router-link to="/home/news">News</router-link></li>
					<li><router-link to="/home/message">Message</router-link></li>
				  </ul>
				  <router-view></router-view>
				</div>
			  </div>
			</template>
			<script>
			  export default {}
			</script>
			#About.vue
			<template>
			  <div>
				<h2>About</h2>
				<p>{{msg}}</p>
				<input type="text">
			  </div>
			</template>
			<script>
			  export default {
				props: {
				  msg: String
				}
			  }
			</script>
			#New.vue
			<template>
			  <ul>
				<li v-for="(news, index) in newsArr" :key="index">{{news}}</li>
			  </ul>
			</template>
			<script>
			  export default {
				data () {
				  return {
					newsArr: ['News001', 'News002', 'News003']
				  }
				}
			  }
			</script>
			#Message.vue
			<template>
			  <div>
				<ul>
				  <li v-for="m in messages" :key="m.id">
					<router-link :to="`/home/message/detail/${m.id}`">{{m.title}}</router-link>
					<button @click="pushShow(m.id)">push查看</button>
					<button @click="replaceShow(m.id)">replace查看</button>
				  </li>
				</ul>
				<button @click="$router.back()">回退</button>
				<hr>
				<router-view></router-view>
			  </div>
			</template>
			<script>
			  export default {
				data () {
				  return {
					messages: [
					 /* {id: 1, title: 'Message001'},{id: 3, title: 'Message003'},{id: 5, title: 'Message005'}*/
					]
				  }
				},
				//生命周期，只加载1次
				mounted () {
				  setTimeout(() => {
					const messages = [
					   {id: 1, title: 'Message001'},
					   {id: 3, title: 'Message003'},
					   {id: 5, title: 'Message005'}
					]
					this.messages = messages
				  }, 1000)
				},
				methods: {
				  pushShow (id) {
					this.$router.push(`/home/message/detail/${id}`)
				  },
				  replaceShow(id) {
					this.$router.replace(`/home/message/detail/${id}`)
				  }
				}
			  }
			</script>
			#MessageDetail.vue
			<template>
			  <ul>
				<li>id: {{this.$route.params.id}}</li>
				<li>title: {{detail.title}}</li>
				<li>content: {{detail.content}}</li>
			  </ul>
			</template>
			<script>
			  const messageDetails = [
				{id: 1, title: 'Message001', content: 'message content00111....'},
				{id: 3, title: 'Message003', content: 'message content00222....'},
				{id: 5, title: 'Message005', content: 'message content00333....'}
			  ]
			  export default {
				data() {
				  return {
					detail: {}
				  }
				},
				mounted () {// 改变当前路由组件参数数据时，不会重新创建组件对象，mounted不会重新执行
				  const id = this.$route.params.id
				  this.detail = messageDetails.find(detail => detail.id===id*1)
				},
				watch: {
				  $route: function () { // 改变当前路由组件参数数据时自动调用
					const id = this.$route.params.id
					this.detail = messageDetails.find(detail => detail.id===id*1)
				  }
				}
			  }
			</script>
		VUEX：状态管理
			理解：github 站点: https://github.com/vuejs/vuex；在线文档: https://vuex.vuejs.org/zh-cn/；简单来说: 对 vue 应用中多个组件的共享状态进行集中式的管理(读/写)；
			状态自管理应用：
			state: 驱动应用的数据源；view: 以声明方式将 state 映射到视图；actions: 响应在 view 上的用户输入导致的状态变化(包含 n 个更新状态的方法)；三者组成 一个闭环；
			多组件共享状态的问题：多个视图依赖于同一状态；来自不同视图的行为需要变更同一状态；
            以前的解决办法：将数据以及操作数据的行为都定义在父组件，将数据以及操作数据的行为传递给需要的各个子组件(有可能需要多级传递)，vuex 就是用来解决这个问题的；
			核心API：
			state：管理状态对象，是唯一的；
			格式：const state = {
					xxx: initValue
				  }
			mutations：包含多个直接更新 state 的方法(回调函数)的对象；
			谁来触发: action 中的 commit('mutation名称')；只能包含同步的代码, 不能写异步代码；
			格式：const mutations = {
					yyy (state, {data1}) {
					// 更新 state 的某个属性
				  }
				  }
			actions：包含多个事件回调函数的对象；通过执行: commit()来触发 mutation 的调用, 间接更新 state；
			谁来触发: 组件中: $store.dispatch('action名称', data1)；可以包含异步代码(定时器, ajax)；
			格式：const actions = {
					zzz ({commit, state}, data1) {
						commit('yyy', {data1})
					}
					}
			getters：包含多个计算属性(get)的对象；谁来读取: 组件中: $store.getters.xxx；
			格式：const getters = {
						mmm (state) {
						return ...
						}
					}			
			modules：包含多个 module；一个 module 是一个 store 的配置对象；与一个组件(包含有共享数据)对应；
			向外暴露 store 对象：
			格式：export default new Vuex.Store({
					   state, mutations, actions, getters
				    })
			组件中使用：
			格式：import {mapState, mapGetters, mapActions} from 'vuex' 
			export default {
				computed: {
				...mapState(['xxx']), 
				...mapGetters(['mmm']), 
				}
				methods: mapActions(['zzz'])
			}
			{{xxx}} {{mmm}} 
			@click="zzz(data)"
			映射 store：
			import store from './store' 
			new Vue({
				store
			})
			store 对象：所有用 vuex 管理的组件中都多了一个属性$store, 它就是一个 store 对象；
			属性：state: 注册的 state 对象；getters: 注册的 getters 对象；
			方法: dispatch(actionName, data): 分发调用 action；
		VUEX结构分析：
							$state.dispatch                     commit
			VUE 组件 -----------------------------> Actions ----------------> mutations
			   |              mapAction                                            | -Mutate
			     --------------------------------------------------------------- State
									Render （mapGetters()、mapState()）										
		完整示例：
			#搜索示例
			#入口，main.js
			import Vue from 'vue'
			import App from './App.vue'
			import store from './vuex/store'
			// 创建vm
			/* eslint-disable no-new */
			new Vue({
			  el: '#app',
			  render: h => h(App),
			  store
			})
			/*
			new Vue({
			  el: '#app',
			  components: {App}, // 映射组件标签
			  template: '<App/>', // 指定需要渲染到页面的模板
			  store
			})*/
			#应用组件App.vue
			<template>
			  <div class="container">
				<Search/>
				<UsersMain/>
			  </div>
			</template>
			<script>
			  import Search from './components/Search.vue'
			  import Main from './components/Main.vue'

			  export default {
				components: {
				  Search,// 映射组件标签
				  UsersMain: Main
				}
			  }
			</script>
			#基本组件-Search.vue
			<template>
			  <section class="jumbotron">
				<h3 class="jumbotron-heading">Search Github Users</h3>
				<div>
				  <input type="text" placeholder="enter the name you search" v-model="searchName"/>
				  <button @click="search">Search</button>
				</div>
			  </section>
			</template>
			<script>
			  export default {
				data () {
				  return {
					searchName: ''
				  }
				},
				methods: {
				  search () {
					const searchName = this.searchName.trim()
					if(searchName) {
					  this.$store.dispatch('search', searchName)
					}
				  }
				}
			  }
			</script>
			#基本组件-Main.vue
			<template>
			  <div>
				<h2 v-show="firstView">请输入关键字搜索</h2>
				<h2 v-show="loading">请求中...</h2>
				<h2 v-show="errorMsg">{{errorMsg}}</h2>
				<div class="row" v-show="users.length>0">
				  <div class="card" v-for="(user, index) in users" :key="index">
					<a :href="user.url" target="_blank">
					  <img :src="user.avatarUrl" style='width: 100px'/>
					</a>
					<p class="card-text">{{user.username}}</p>
				  </div>
				</div>
			  </div>
			</template>
			<script>
			  import {mapState} from 'vuex'
			  export default {
				computed: {
				  ...mapState(['firstView', 'loading', 'errorMsg', 'users'])
				}
			  }
			</script>
			#state.js
			export default {
			  firstView: true, // 是否显示初始页面
			  loading: false, // 是否正在请求中
			  users: [], // 用户数组
			  errorMsg: ''  //错误信息
			}
			#mutations.js
			import {REQUESTING, REQUEST_SUCCESS, REQUEST_ERROR} from './mutation-types'
			export default {
			  [REQUESTING] (state) {
				state.firstView = false
				state.loading = true
				state.users = []
				state.errorMsg = ''
			  },
			  [REQUEST_SUCCESS] (state, {users}) {
				state.loading = false
				state.users = users
			  },
			  [REQUEST_ERROR] (state, {msg}) {
				state.loading  = false
				state.errorMsg = msg
			  },
			}
			#mutations-types.js
			export const REQUESTING = 'requesting' // 请求中
			export const REQUEST_SUCCESS = 'request_success' // 请求成功
			export const REQUEST_ERROR = 'request_error' // 请求失败
			#actions.js
			import axios from 'axios'
			import {REQUESTING, REQUEST_SUCCESS, REQUEST_ERROR} from './mutation-types'
			export default {
			  search({commit}, searchName) {
				// 提交mutation: 更新状态(请求中)
				commit(REQUESTING)
				// 发送异步ajax请求获取数据
				const url = `https://api.github.com/search/users?q=${searchName}`
				axios.get(url)
				  .then(response => {
					// 成功了, 提交mutation: 更新状态(成功)
					const users = response.data.items.map(item => ({
					  url: item.html_url,
					  avatarUrl: item.avatar_url,
					  username: item.login
					}))
					commit(REQUEST_SUCCESS, {users})
				  })
				  .catch(error => {
					// 失败了, 提交mutation: 更新状态(失败)
					commit(REQUEST_ERROR, {msg: '请求失败'})
				  })
			  }
			}
			#getters.js
			export default {
			}
			#store.js
			import Vue from 'vue'
			import Vuex from 'vuex'
			import state from './state'
			import mutations from './mutations'
			import actions from './actions'
			import getters from './getters'
			Vue.use(Vuex)
			export default new Vuex.Store({
			  state,
			  mutations,
			  actions,
			  getters
			})
			#计数器示例
			#store.js
			import Vue from 'vue'
			import Vuex from 'vuex'
			Vue.use(Vuex)
			const state = {
				count: 0 // 初始化状态数据
			}
			// mutations 对象，包含个方法: 
			// 能直接更新 state 一个方法就是一个 mutation，mutation 只能包含更新 state 的同步代码,也不会有逻辑；
			// mutation 由 action 触发调用: commit('mutationName')；
			const mutations = {
				INCREMENT(state) {
					state.count++
				},
				DECREMENT (state) { // ctrl + shift + x
					state.count--
				}
			}
			// actions 对象，包含个方法: 触发 mutation 调用, 间接更新 state 一个方法就是一个 action
			// action 中可以有逻辑代码和异步代码；action 由组件来触发调用: this.$store.dispatch('actionName')；
			const actions = {
				increment ({commit}) {
					commit('INCREMENT')
				},
				decrement ({commit}) {
					commit('DECREMENT')
				},
				incrementIfOdd ({commit, state}) {
					if(state.count%2===1) {
					commit('INCREMENT')
					}
				},
				incrementAsync ({commit}) {
					setTimeout(() => {
					commit('INCREMENT')
					}, 1000)
				}
			}			
			const getters = {
				oddOrEven (state) {
				return state.count%2===0 ? '偶数' : '奇数'
				},
				count (state) {
				return state.count
				}
			}
			//向外暴露 store 实例对象
			export default new Vuex.Store({
				state,
				mutations,
				actions,
				getters
			})
			#main.js
			import Vue from 'vue'
			import app from './app1.vue'
			// import app from './app.vue'
			import store from './store'
			new Vue({
			el: '#app',
			render: h => h(app),
			store // 所有组件都多个一个属性: $store
			})
			#app.vue（优化前）
			<template>
				<div>
				<p>clicked: {{$store.state.count}} times, count is {{oddOrEven}}</p>
				<button @click="increment">+</button>
				<button @click="decrement">-</button>
				<button @click="incrementIfOdd">increment if odd</button>
				<button @click="incrementAsync">increment async</button>
				</div>
			</template>
			<script>
			export default {
			computed: {
				oddOrEven () {
					return this.$store.getters.oddOrEven
				}
			},
			methods: {
				increment () {
					this.$store.dispatch('increment')
				},
				decrement () {
					this.$store.dispatch('decrement')
				},
				incrementIfOdd () {
					this.$store.dispatch('incrementIfOdd')
				},
				incrementAsync () {
					this.$store.dispatch('incrementAsync')
				}
			}
			}
			</script>
			#app1.vue（优化后）
			<template>
				<div>
				<p>clicked: {{count}} times, count is {{oddOrEven}}</p>
				<button @click="increment">+</button>
				<button @click="decrement">-</button>
				<button @click="incrementIfOdd">increment if odd</button>
				<button @click="incrementAsync">increment async</button>
				</div>
			</template>
			<script>
			import {mapGetters, mapActions} from 'vuex'
			export default {
			computed: mapGetters({ // 名称不一样
				oddOrEven: 'oddOrEven',
				count: 'count'
			}),
			methods: mapActions(['increment', 'decrement', 'incrementIfOdd','incrementAsync']) // 名称一样			
			}
			</script>