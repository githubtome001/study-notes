----------------------------------------------Java高级篇之网络编程技术---------------------------------------------------------------------------------------------------------------------------------------	
	一、网络编程基础知识
		1、注意区分MQ与网络通讯的区别：
			MQ的目的是为了缓解服务器的压力，在消息生产者与消费者之间添加了一层，使系统解耦，接收的消息可以延迟，不要求完全实时性；
			网络通讯是服务端与客户端之间直接通讯，中间没有添加其他层，实时消息；
		2、Socket基本认识：
			含义：Socket又称“套接字”，即应用程序通过“套接字”向网络发起请求或应答网络请求，在java.net包内有Socket与ServerSocket类分别对应服务端和客户端（建立网络连接）；
				  建立连接成功后，两端都会产生一个Socket实例，操作这个实例，来完成此次会话；具体的工作，都是由子类去实现的；
								发起请求
				  Socket <------------------------>ServerSocket
								应答网络请求
			      套接字的连接过程分为4步骤（3次握手、4次挥手）：
					服务器监听：服务器端处于等待连接状态（accept）（不确定哪一个客户端连接），实时监测网络状态；
					客户端请求服务端：前提是客户端必须描述服务端的套接字，即指出地址和端口号，然后才能发出连接请求；
					服务端连接确认：服务端监听到客户端套接字的连接请求，响应客户端请求，建立一个新的线程（Thread），把自身的套接字描述信息发给客户端；
					客户端连接确认：一旦客户端确认了服务端的描述，双方建立连接，开始通讯；同时，服务端仍然属于监听状态，等待其他客户端来连接；
		3、IO（BIO）与NIO的认识：
			本质是阻塞与非阻塞的区别；
				阻塞：应用程序在获取网络数据的时候，如果网络传输慢，程序必须一直等待着，直到传输完毕为止；完全依赖于网络带宽
				非阻塞：程序直接获取已经准备好的数据，无需等待；即在网路之外添加了一个channel与buffer，客户端直接从这里面取数据；
			BIO：同步阻塞，NIO同步非阻塞，在JDK1.7以后出现了异步非阻塞模型即NIO2.0（AIO）
			同步与异步：面向操作系统的；同步指程序直接参与IO的读写操作；异步所有的IO的读写交给操作系统；同步指的是服务端执行方式，阻塞指的是具体技术；
			BIO通讯：基于TCP/IP协议，跨址传输，C/S模型，Client（多个）------------->Server acceptor（阻塞状态）---------->Thread（多个）
				案例说明：
				//服务端
				public class Server {
					final static int PROT = 8765;					
					public static void main(String[] args) {					
						ServerSocket server = null;
						try {
							server = new ServerSocket(PROT);
							System.out.println(" server start .. ");
							//进行阻塞，开启线程
							Socket socket = server.accept();
							//新建一个线程执行客户端的任务
							new Thread(new ServerHandler(socket)).start();							
						} catch (Exception e) {
							e.printStackTrace();
						} finally {
							if(server != null){
								try {
									server.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
							}
							server = null;
						}																		
					}
				}
				//客户端
				public class Client {
					final static String ADDRESS = "127.0.0.1";
					final static int PORT = 8765;					
					public static void main(String[] args) {						
						Socket socket = null;
						//输入流-读数据，输出流-写数据
						BufferedReader in = null;
						PrintWriter out = null;						
						try {
							socket = new Socket(ADDRESS, PORT);//描述服务端套接字的信息
							in = new BufferedReader(new InputStreamReader(socket.getInputStream()));
							out = new PrintWriter(socket.getOutputStream(), true);							
							//向服务器端发送数据
							out.println("接收到客户端的请求数据...");
							String response = in.readLine();
							System.out.println("Client: " + response);//结果：Client: 服务器端回送响的应数据.							
						} catch (Exception e) {
							e.printStackTrace();
						} finally {
							if(in != null){
								try {
									in.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
							}
							if(out != null){
								try {
									out.close();
								} catch (Exception e) {
									e.printStackTrace();
								}
							}
							if(socket != null){
								try {
									socket.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
							}
							socket = null;
						}
					}
				}
				//Handler
				public class ServerHandler implements Runnable{
					private Socket socket;					
					public ServerHandler(Socket socket){
						this.socket = socket;
					}					
					@Override
					public void run() {
						BufferedReader in = null;
						PrintWriter out = null;
						try {
							in = new BufferedReader(new InputStreamReader(this.socket.getInputStream()));
							out = new PrintWriter(this.socket.getOutputStream(), true);
							String body = null;
							while(true){
								body = in.readLine();
								if(body == null) break;
								System.out.println("Server :" + body);//结果：Server : 接收到客户端的请求数据...
								out.println("服务器端回送响的应数据.");
							}							
						} catch (Exception e) {
							e.printStackTrace();
						} finally {
							if(in != null){
								try {
									in.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
							}
							if(out != null){
								try {
									out.close();
								} catch (Exception e) {
									e.printStackTrace();
								}
							}
							if(socket != null){
								try {
									socket.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
							}
							socket = null;
						}												
					}
				}
			伪异步IO：利用线程池技术来缓解创建过多线程带来的服务器的压力；
				原理：Client（多个）------------->Server acceptor（阻塞状态）---------->ThreadPool，实现Runable接口；
				//案例分析：
				//服务端
				public class Server {
					final static int PORT = 8765;
					public static void main(String[] args) {
						ServerSocket server = null;
						BufferedReader in = null;
						PrintWriter out = null;
						try {
							server = new ServerSocket(PORT);
							System.out.println("server start...");
							Socket socket = null;
							//利用池技术
							HandlerExecutorPool executorPool = new HandlerExecutorPool(50, 1000);
							while(true){
								socket = server.accept();
								executorPool.execute(new ServerHandler(socket));
							}						
						} catch (Exception e) {
							e.printStackTrace();
						} finally {
							if(in != null){
								try {
									in.close();
								} catch (Exception e1) {
									e1.printStackTrace();
								}
							}
							if(out != null){
								try {
									out.close();
								} catch (Exception e2) {
									e2.printStackTrace();
								}
							}
							if(server != null){
								try {
									server.close();
								} catch (Exception e3) {
									e3.printStackTrace();
								}
							}
							server = null;				
						}																
					}										
				}
				//线程池，JDK1.5以后JUC包下
				public class HandlerExecutorPool {
					private ExecutorService executor;
					public HandlerExecutorPool(int maxPoolSize, int queueSize){
						this.executor = new ThreadPoolExecutor(
								Runtime.getRuntime().availableProcessors(),
								maxPoolSize, 
								120L, 
								TimeUnit.SECONDS,
								new ArrayBlockingQueue<Runnable>(queueSize));
					}					
					public void execute(Runnable task){
						this.executor.execute(task);
					}														
				}
				//客户端、Handler类同上；
			NIO：（JDK1.5）非阻塞IO（同步），核心概念：Buffer（缓冲区）、Channel（通道）、Selector（多路复用器、选择器），目的就是减少TCP的3次握手4次挥手操作，减少连接开销；
				原理：Client端（核心类：SocketChannel类，对Socket类的进一步抽象）注册到服务端选择器上
					  Server端（核心类：ServerSocketChannel类，对ServerSocket类的进一步抽象），这里有多路复用器，采用轮询（Key）所有注册通道，查看通道状态（Connect、Accept、Read、Write），执行相关操作；
				基本概念解释：	  
					  Buffer：缓冲区，包含读写数据的对象，实质是一个对象，通常是一个字节数组（ByteBuffer），也可以对应Java的其他基本类型（Boolean除外）；
					  Channel：网络数据通过Channel读写，方向是双向的，与多路复用器结合，有多种状态位；有2种分类：网路读写（SelectableChannel）、文件操作（FileChannel）;
					  Selector：多路复用器、选择器，是NIO基础，轮询注册其上的Channel，查看通道状态；理论上channel是无上限的，底层利用JDK的epoll机制，获取连接句柄；
								类似一个管理者角色，管理channel，在客户端通道注册到选择器后，Selector会分配每一个channel一个key，轮询的是key；当管道准备就绪（accept）状态时，通知cpu进行读写操作；
					  Buffer：API说明示例；
					  public class TestBuffer {						
						public static void main(String[] args) {							
							// 1 基本操作
							//创建指定长度的缓冲区
							IntBuffer buf = IntBuffer.allocate(10);//声明容量
							buf.put(13);// position位置：0 - > 1
							buf.put(21);// position位置：1 - > 2
							buf.put(35);// position位置：2 - > 3
							//把位置复位为0，也就是position位置：3 - > 0
							buf.flip();
							System.out.println("使用flip复位：" + buf);//使用flip复位：java.nio.HeapIntBuffer[pos=0 lim=3 cap=10]
							System.out.println("容量为: " + buf.capacity());	//容量一旦初始化后不允许改变（warp方法包裹数组除外）
							System.out.println("限制为: " + buf.limit());		//由于只装载了三个元素,所以可读取或者操作的元素为3 则limit=3														
							System.out.println("获取下标为1的元素：" + buf.get(1));//读数据
							System.out.println("get(index)方法，position位置不改变：" + buf);//get(index)方法，position位置不改变：java.nio.HeapIntBuffer[pos=0 lim=3 cap=10]
							buf.put(1, 4);//写数据
							System.out.println("put(index, change)方法，position位置不变：" + buf);//java.nio.HeapIntBuffer[pos=0 lim=3 cap=10]						
							for (int i = 0; i < buf.limit(); i++) {
								//调用get方法会使其缓冲区位置（position）向后递增一位
								System.out.print(buf.get() + "\t");
							}
							System.out.println("buf对象遍历之后为: " + buf);	//buf对象遍历之后为: java.nio.HeapIntBuffer[pos=3 lim=3 cap=10]						
							// 2 wrap方法使用
							//  wrap方法会包裹一个数组: 一般这种用法不会先初始化缓存对象的长度，因为没有意义，最后还会被wrap所包裹的数组覆盖掉。 
							//  并且wrap方法修改缓冲区对象的时候，数组本身也会跟着发生变化。                     
							int[] arr = new int[]{1,2,5};
							IntBuffer buf1 = IntBuffer.wrap(arr);
							System.out.println(buf1);//java.nio.HeapIntBuffer[pos=0 lim=3 cap=3]						
							IntBuffer buf2 = IntBuffer.wrap(arr, 0 , 2);
							//这样使用表示容量为数组arr的长度，但是可操作的元素只有实际进入缓存区的元素长度
							System.out.println(buf2);//java.nio.HeapIntBuffer[pos=0 lim=2 cap=3]														
							// 3 其他方法
							IntBuffer buf1 = IntBuffer.allocate(10);
							int[] arr = new int[]{1,2,5};
							buf1.put(arr);
							System.out.println(buf1);//java.nio.HeapIntBuffer[pos=3 lim=10 cap=10]	
							//一种复制方法
							IntBuffer buf3 = buf1.duplicate();
							System.out.println(buf3);//java.nio.HeapIntBuffer[pos=3 lim=10 cap=10]	
							//设置buf1的位置属性
							//buf1.position(0);
							buf1.flip();
							System.out.println(buf1);//java.nio.HeapIntBuffer[pos=0 lim=3 cap=10]							
							System.out.println("可读数据为：" + buf1.remaining());//可读数据为：3						
							int[] arr2 = new int[buf1.remaining()];
							//将缓冲区数据放入arr2数组中去
							buf1.get(arr2);
							for(int i : arr2){
								System.out.print(Integer.toString(i) + ",");//1,2,5,
							}							
						}
					}
				  NIO案例说明（了解）：
					//服务端（读-操作）
					public class Server implements Runnable{
						//1 多路复用器（管理所有的通道）
						private Selector seletor;
						//2 建立缓冲区
						private ByteBuffer readBuf = ByteBuffer.allocate(1024);
						//private ByteBuffer writeBuf = ByteBuffer.allocate(1024);
						public Server(int port){
							try {
								//1 打开路复用器
								this.seletor = Selector.open();
								//2 打开服务器通道
								ServerSocketChannel ssc = ServerSocketChannel.open();
								//3 设置服务器通道为非阻塞模式
								ssc.configureBlocking(false);
								//4 绑定地址
								ssc.bind(new InetSocketAddress(port));
								//5 把服务器通道注册到多路复用器上，并且监听阻塞事件，标识位
								ssc.register(this.seletor, SelectionKey.OP_ACCEPT);								
								System.out.println("Server start, port :" + port);								
							} catch (IOException e) {
								e.printStackTrace();
							}
						}
						@Override
						public void run() {
							while(true){
								try {
									//1 必须要让多路复用器开始监听
									this.seletor.select();
									//2 返回多路复用器已经选择的结果集
									Iterator<SelectionKey> keys = this.seletor.selectedKeys().iterator();
									//3 进行遍历
									while(keys.hasNext()){
										//4 获取一个选择的元素
										SelectionKey key = keys.next();
										//5 直接从容器中移除就可以了
										keys.remove();
										//6 如果是有效的
										if(key.isValid()){
											//7 如果为阻塞状态
											if(key.isAcceptable()){
												this.accept(key);
											}
											//8 如果为可读状态
											if(key.isReadable()){
												this.read(key);
											}
											//9 写数据
											if(key.isWritable()){
												//this.write(key); //ssc
											}
										}										
									}
								} catch (IOException e) {
									e.printStackTrace();
								}
							}
						}						
						private void write(SelectionKey key){
							//ServerSocketChannel ssc =  (ServerSocketChannel) key.channel();
							//ssc.register(this.seletor, SelectionKey.OP_WRITE);
						}
						private void read(SelectionKey key) {
							try {
								//1 清空缓冲区旧的数据
								this.readBuf.clear();
								//2 获取之前注册的socket通道对象
								SocketChannel sc = (SocketChannel) key.channel();
								//3 读取数据
								int count = sc.read(this.readBuf);
								//4 如果没有数据
								if(count == -1){
									key.channel().close();
									key.cancel();
									return;
								}
								//5 有数据则进行读取 读取之前需要进行复位方法(把position 和limit进行复位)
								this.readBuf.flip();
								//6 根据缓冲区的数据长度创建相应大小的byte数组，接收缓冲区的数据
								byte[] bytes = new byte[this.readBuf.remaining()];
								//7 接收缓冲区数据
								this.readBuf.get(bytes);
								//8 打印结果
								String body = new String(bytes).trim();
								System.out.println("Server : " + body);								
								// 9..可以写回给客户端数据 								
							} catch (IOException e) {
								e.printStackTrace();
							}							
						}
						private void accept(SelectionKey key) {
							try {
								//1 获取服务通道
								ServerSocketChannel ssc =  (ServerSocketChannel) key.channel();
								//2 执行阻塞方法
								SocketChannel sc = ssc.accept();
								//3 设置阻塞模式
								sc.configureBlocking(false);
								//4 注册到多路复用器上，并设置读取标识，即sc通道可读
								sc.register(this.seletor, SelectionKey.OP_READ);
							} catch (IOException e) {
								e.printStackTrace();
							}
						}						
						public static void main(String[] args) {							
							new Thread(new Server(8765)).start();
						}											
					}
					//客户端
					public class Client {
						//需要一个Selector 
						public static void main(String[] args) {							
							//创建连接的地址
							InetSocketAddress address = new InetSocketAddress("127.0.0.1", 8765);							
							//声明连接通道
							SocketChannel sc = null;							
							//建立缓冲区
							ByteBuffer buf = ByteBuffer.allocate(1024);							
							try {
								//打开通道
								sc = SocketChannel.open();
								//进行连接
								sc.connect(address);								
								while(true){
									//定义一个字节数组，然后使用系统录入功能：
									byte[] bytes = new byte[1024];
									System.in.read(bytes);									
									//把数据放到缓冲区中
									buf.put(bytes);
									//对缓冲区进行复位
									buf.flip();
									//写出数据
									sc.write(buf);
									//清空缓冲区数据
									buf.clear();
								}
							} catch (IOException e) {
								e.printStackTrace();
							} finally {
								if(sc != null){
									try {
										sc.close();
									} catch (IOException e) {
										e.printStackTrace();
									}
								}
							}							
						}						
					}
				优缺点：优点减少连接数量，采用抽象的通道技术（取代了TCP/IP的通讯技术）以及多路复用等技术；缺点：书写繁琐，所有的细节都要自己去实现；
			AIO：（JDK1.7）	异步非阻塞，引入异步通道概念；在多路复用器轮询通道是异步的，两个核心类：AsynchronousSocketChannel与AsynchronousServerSocketChannel；
				案例说明：
				//服务端
				public class Server {
					//线程池
					private ExecutorService executorService;
					//线程组
					private AsynchronousChannelGroup threadGroup;
					//服务器通道
					public AsynchronousServerSocketChannel assc;					
					public Server(int port){
						try {
							//创建一个缓存池
							executorService = Executors.newCachedThreadPool();
							//创建线程组
							threadGroup = AsynchronousChannelGroup.withCachedThreadPool(executorService, 1);
							//创建服务器通道
							assc = AsynchronousServerSocketChannel.open(threadGroup);
							//进行绑定，便于寻址
							assc.bind(new InetSocketAddress(port));							
							System.out.println("server start , port : " + port);
							//进行阻塞
							assc.accept(this, new ServerCompletionHandler());
							//一直阻塞不让服务器停止，模拟服务器一直处于运行状态，因为非阻塞
							Thread.sleep(Integer.MAX_VALUE);							
						} catch (Exception e) {
							e.printStackTrace();
						}
					}					
					public static void main(String[] args) {
						Server server = new Server(8765);
					}					
				}
				//Handler
				public class ServerCompletionHandler implements CompletionHandler<AsynchronousSocketChannel, Server> {
					@Override
					public void completed(AsynchronousSocketChannel asc, Server attachment) {
						//当有下一个客户端接入的时候直接调用Server的accept方法，这样反复执行下去，保证多个客户端都可以阻塞
						attachment.assc.accept(attachment, this);
						read(asc);
					}
					private void read(final AsynchronousSocketChannel asc) {
						//读取数据，异步读数据
						ByteBuffer buf = ByteBuffer.allocate(1024);
						asc.read(buf, buf, new CompletionHandler<Integer, ByteBuffer>() {
							@Override
							public void completed(Integer resultSize, ByteBuffer attachment) {//数据读完以后
								//进行读取之后,重置标识位
								attachment.flip();
								//获得读取的字节数
								System.out.println("Server -> " + "收到客户端的数据长度为:" + resultSize);
								//获取读取的数据
								String resultData = new String(attachment.array()).trim();
								System.out.println("Server -> " + "收到客户端的数据信息为:" + resultData);
								String response = "服务器响应, 收到了客户端发来的数据: " + resultData;
								write(asc, response);
							}
							@Override
							public void failed(Throwable exc, ByteBuffer attachment) {
								exc.printStackTrace();
							}
						});
					}					
					private void write(AsynchronousSocketChannel asc, String response) {
						try {
							ByteBuffer buf = ByteBuffer.allocate(1024);
							buf.put(response.getBytes());
							buf.flip();
							asc.write(buf).get();//开启一个新的线程，不影响主线程执行，不断的写数据
						} catch (InterruptedException e) {
							e.printStackTrace();
						} catch (ExecutionException e) {
							e.printStackTrace();
						}
					}					
					@Override
					public void failed(Throwable exc, Server attachment) {
						exc.printStackTrace();
					}
				}
				//客户端
				public class Client implements Runnable{
					private AsynchronousSocketChannel asc ;					
					public Client() throws Exception {
						asc = AsynchronousSocketChannel.open();
					}					
					public void connect(){
						asc.connect(new InetSocketAddress("127.0.0.1", 8765));//寻址
					}					
					public void write(String request){
						try {
							asc.write(ByteBuffer.wrap(request.getBytes())).get();
							read();
						} catch (Exception e) {
							e.printStackTrace();
						}
					}
					private void read() {
						ByteBuffer buf = ByteBuffer.allocate(1024);
						try {
							asc.read(buf).get();//不断的读数据
							buf.flip();
							byte[] respByte = new byte[buf.remaining()];
							buf.get(respByte);
							System.out.println(new String(respByte,"utf-8").trim());
						} catch (InterruptedException e) {
							e.printStackTrace();
						} catch (ExecutionException e) {
							e.printStackTrace();
						} catch (UnsupportedEncodingException e) {
							e.printStackTrace();
						}
					}					
					@Override
					public void run() {//模拟客户端服务一直开启状态
						while(true){							
						}
					}					
					public static void main(String[] args) throws Exception {
						Client c1 = new Client();
						c1.connect();						
						Client c2 = new Client();
						c2.connect();					
						Client c3 = new Client();
						c3.connect();						
						new Thread(c1, "c1").start();
						new Thread(c2, "c2").start();
						new Thread(c3, "c3").start();						
						Thread.sleep(1000);						
						c1.write("c1 aaa");
						c2.write("c2 bbbb");
						c3.write("c3 ccccc");
					}					
				}
	二、Netty通讯技术（联想Apache mina通讯框架）
		1、初步认识：
			Netty简单易用，健壮可扩展，当下主流框架技术底层都有用到，如：JMS中的RocketMQ、分布式通信框架Dubbox、Hadoop的RPC框架Avro等等
			Netty是基于Java的NIO（客户端-服务端）网络应用框架，它提供了简易的API使得与业务逻辑解耦，是异步通讯的（非阻塞）；
			Netty支持的传输协议有：Socket、Http，它支持服务有WebSocket、SSL（安全认证、Secure Sockets Layer 安全套接层）以及大文件传输等
			Netty特性：易于使用、高吞吐量低的延迟性能好、安全性高、社区活跃度高
		2、Netty通讯步骤：
			//服务端
			a、创建2个线程组，一个专门用于网络事件处理（接收客户端的连接，客户端可能有多个），另一个进行网络通讯读写；
			b、创建ServerBootstrap对象，配置Netty参数；
			c、创建类ChannelInitalizer，配置初始化工作；
			d、配置端口，启动Netty服务端；
			//客户端
			a、创建1个线程组，进行网络通讯读写；
			b、创建Bootstrap对象，配置Netty参数；
			c、创建类ChannelInitalizer，配置初始化工作；
			d、寻址，连接Netty服务端；
		3、简单示例，入门级HelloWorld：
		   //服务端，调用netty API接口
		   public class Server {
				public static void main(String[] args) throws Exception {
					//1 创建线两个程组，一个是用于处理服务器端接收客户端连接的，一个是进行网络通信的（网络读写）
					EventLoopGroup pGroup = new NioEventLoopGroup();
					EventLoopGroup cGroup = new NioEventLoopGroup();					
					//2 创建辅助工具类，用于服务器通道的一系列配置
					ServerBootstrap b = new ServerBootstrap();
					b.group(pGroup, cGroup)		//绑定俩个线程组
					.channel(NioServerSocketChannel.class)		//指定NIO的模式
					.option(ChannelOption.SO_BACKLOG, 1024)		//设置tcp缓冲区
					.option(ChannelOption.SO_SNDBUF, 32*1024)	//设置发送缓冲大小
					.option(ChannelOption.SO_RCVBUF, 32*1024)	//接收缓冲大小
					.option(ChannelOption.SO_KEEPALIVE, true)	//保持连接
					.childHandler(new ChannelInitializer<SocketChannel>() {
						@Override
						protected void initChannel(SocketChannel sc) throws Exception {
							//3 在这里配置具体数据接收方法的处理
							sc.pipeline().addLast(new ServerHandler());
						}
					});					
					//4 进行绑定，即服务端可以开放多个端口 
					ChannelFuture cf1 = b.bind(8765).sync();
					//ChannelFuture cf2 = b.bind(8764).sync();
					//5 等待关闭，同步优雅关闭
					cf1.channel().closeFuture().sync();
					//cf2.channel().closeFuture().sync();
					pGroup.shutdownGracefully();
					cGroup.shutdownGracefully();
				}
			}
			//ServerHandler，处理服务端业务逻辑
			public class ServerHandler extends ChannelHandlerAdapter {
				@Override
				public void channelActive(ChannelHandlerContext ctx) throws Exception {
					System.out.println("server channel active... ");
				}
				@Override
				public void channelRead(ChannelHandlerContext ctx, Object msg)
						throws Exception {
						ByteBuf buf = (ByteBuf) msg;
						byte[] req = new byte[buf.readableBytes()];
						buf.readBytes(req);
						String body = new String(req, "utf-8");
						System.out.println("Server :" + body );//服务端接收到的shuju
						String response = "进行返回给客户端的响应：" + body ;
						ctx.writeAndFlush(Unpooled.copiedBuffer(response.getBytes()));
						//.addListener(ChannelFutureListener.CLOSE);//将Netty长连接转成短连接
				}
				@Override
				public void channelReadComplete(ChannelHandlerContext ctx)
						throws Exception {
					System.out.println("读完了");
					ctx.flush();
				}
				@Override
				public void exceptionCaught(ChannelHandlerContext ctx, Throwable t)
						throws Exception {
					ctx.close();
				}
			}
			//客户端，调用netty API接口
			public class Client {
				public static void main(String[] args) throws Exception{					
					EventLoopGroup group = new NioEventLoopGroup();
					Bootstrap b = new Bootstrap();
					b.group(group)
					.channel(NioSocketChannel.class)
					.handler(new ChannelInitializer<SocketChannel>() {
						@Override
						protected void initChannel(SocketChannel sc) throws Exception {
							sc.pipeline().addLast(new ClientHandler());
						}
					});					
					ChannelFuture cf1 = b.connect("127.0.0.1", 8765).sync();//寻址，模拟多个客户端连接
					//ChannelFuture cf2 = b.connect("127.0.0.1", 8764).sync();
					//发送消息
					Thread.sleep(1000);
					cf1.channel().writeAndFlush(Unpooled.copiedBuffer("777".getBytes()));
					cf1.channel().writeAndFlush(Unpooled.copiedBuffer("666".getBytes()));
					//cf2.channel().writeAndFlush(Unpooled.copiedBuffer("888".getBytes()));
					Thread.sleep(2000);
					cf1.channel().writeAndFlush(Unpooled.copiedBuffer("888".getBytes()));
					//cf2.channel().writeAndFlush(Unpooled.copiedBuffer("666".getBytes()));					
					cf1.channel().closeFuture().sync();
					//cf2.channel().closeFuture().sync();
					group.shutdownGracefully();															
				}
			}
			// ClientHandler，处理客户端业务逻辑
			public class ClientHandler extends ChannelHandlerAdapter{
				@Override
				public void channelActive(ChannelHandlerContext ctx) throws Exception {
				}
				@Override
				public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
					try {
						ByteBuf buf = (ByteBuf) msg;						
						byte[] req = new byte[buf.readableBytes()];
						buf.readBytes(req);					
						String body = new String(req, "utf-8");
						System.out.println("Client :" + body );//客户端接收到的服务端的响应数据
						String response = "收到服务器端的返回信息：" + body;
					} finally {
						ReferenceCountUtil.release(msg);//释放信息
					}
				}
				@Override
				public void channelReadComplete(ChannelHandlerContext ctx) throws Exception {
				}
				@Override
				public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause)
						throws Exception {
					ctx.close();
				}
			}
		4、Netty拆包、粘包：
			问题产生：TCP是一个“流”的协议，即没有界限的遗传数据，会产生拆包、粘包问题，对应的解决方案：
				1、消息定长（固定报文的长度）；2、在包尾部添加特殊的字符进行分割；3、将消息分为消息头（消息长度）与消息体；
			Netty提供：DelimiterBasedFrameDecoder（自定义分割符类）、FixedLengthFrameDecoder（定长）来处理这一问题；
			案例分析一：
			//服务端
			public class Server {
				public static void main(String[] args) throws Exception{
					//1 创建2个线程，一个是负责接收客户端的连接。一个是负责进行数据传输的
					EventLoopGroup pGroup = new NioEventLoopGroup();
					EventLoopGroup cGroup = new NioEventLoopGroup();					
					//2 创建服务器辅助类
					ServerBootstrap b = new ServerBootstrap();
					b.group(pGroup, cGroup)
					 .channel(NioServerSocketChannel.class)
					 .option(ChannelOption.SO_BACKLOG, 1024)
					 .option(ChannelOption.SO_SNDBUF, 32*1024)
					 .option(ChannelOption.SO_RCVBUF, 32*1024)
					 .childHandler(new ChannelInitializer<SocketChannel>() {
						@Override
						protected void initChannel(SocketChannel sc) throws Exception {
							//设置特殊分隔符$_
							ByteBuf buf = Unpooled.copiedBuffer("$_".getBytes());
							sc.pipeline().addLast(new DelimiterBasedFrameDecoder(1024, buf));
							//设置字符串形式的解码
							sc.pipeline().addLast(new StringDecoder());
							sc.pipeline().addLast(new ServerHandler());
						}
					});					
					//4 绑定连接
					ChannelFuture cf = b.bind(8765).sync();					
					//等待服务器监听端口关闭
					cf.channel().closeFuture().sync();
					pGroup.shutdownGracefully();
					cGroup.shutdownGracefully();					
				}				
			}
			//ServerHandler
			public class ServerHandler extends ChannelHandlerAdapter {
				@Override
				public void channelActive(ChannelHandlerContext ctx) throws Exception {
					System.out.println(" server channel active... ");
				}
				@Override
				public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
					String request = (String)msg;//接收客户端数据是解码后的字符串数据
					System.out.println("Server :" + msg);
					String response = "服务器响应：" + msg + "$_";
					ctx.writeAndFlush(Unpooled.copiedBuffer(response.getBytes()));
				}
				@Override
				public void channelReadComplete(ChannelHandlerContext ctx) throws Exception {					
				}
				@Override
				public void exceptionCaught(ChannelHandlerContext ctx, Throwable t) throws Exception {
					ctx.close();
				}
			}
			//客户端
			public class Client {
				public static void main(String[] args) throws Exception {					
					EventLoopGroup group = new NioEventLoopGroup();					
					Bootstrap b = new Bootstrap();
					b.group(group)
					 .channel(NioSocketChannel.class)
					 .handler(new ChannelInitializer<SocketChannel>() {
						@Override
						protected void initChannel(SocketChannel sc) throws Exception {
							//同服务端
							ByteBuf buf = Unpooled.copiedBuffer("$_".getBytes());
							sc.pipeline().addLast(new DelimiterBasedFrameDecoder(1024, buf));
							sc.pipeline().addLast(new StringDecoder());
							sc.pipeline().addLast(new ClientHandler());
						}
					});					
					ChannelFuture cf = b.connect("127.0.0.1", 8765).sync();					
					cf.channel().writeAndFlush(Unpooled.wrappedBuffer("bbbb$_".getBytes()));
					cf.channel().writeAndFlush(Unpooled.wrappedBuffer("cccc$_".getBytes()));										
					//等待客户端端口关闭
					cf.channel().closeFuture().sync();
					group.shutdownGracefully();				
				}
			}
			//ClientHandler
			public class ClientHandler extends ChannelHandlerAdapter{
				@Override
				public void channelActive(ChannelHandlerContext ctx) throws Exception {
					System.out.println("client channel active... ");
				}
				@Override
				public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
					try {
						String response = (String)msg;
						System.out.println("Client: " + response);
					} finally {
						ReferenceCountUtil.release(msg);
					}
				}
				@Override
				public void channelReadComplete(ChannelHandlerContext ctx) throws Exception {
				}
				@Override
				public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {
					ctx.close();
				}
			}
			//案例分析二：
			//服务端
			public class Server {
				public static void main(String[] args) throws Exception{
					//1 创建2个线程，一个是负责接收客户端的连接。一个是负责进行数据传输的
					EventLoopGroup pGroup = new NioEventLoopGroup();
					EventLoopGroup cGroup = new NioEventLoopGroup();					
					//2 创建服务器辅助类
					ServerBootstrap b = new ServerBootstrap();
					b.group(pGroup, cGroup)
					 .channel(NioServerSocketChannel.class)
					 .option(ChannelOption.SO_BACKLOG, 1024)
					 .option(ChannelOption.SO_SNDBUF, 32*1024)
					 .option(ChannelOption.SO_RCVBUF, 32*1024)
					 .childHandler(new ChannelInitializer<SocketChannel>() {
						@Override
						protected void initChannel(SocketChannel sc) throws Exception {
							//设置定长字符串接收
							sc.pipeline().addLast(new FixedLengthFrameDecoder(5));
							//设置字符串形式的解码
							sc.pipeline().addLast(new StringDecoder());
							sc.pipeline().addLast(new ServerHandler());
						}
					});					
					//4 绑定连接
					ChannelFuture cf = b.bind(8765).sync();					
					//等待服务器监听端口关闭
					cf.channel().closeFuture().sync();
					pGroup.shutdownGracefully();
					cGroup.shutdownGracefully();					
				}				
			}
			//ServerHandler
			public class ServerHandler extends ChannelHandlerAdapter {
				@Override
				public void channelActive(ChannelHandlerContext ctx) throws Exception {
					System.out.println(" server channel active... ");
				}
				@Override
				public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
					String request = (String)msg;
					System.out.println("Server :" + msg);
					String response =  request ;
					ctx.writeAndFlush(Unpooled.copiedBuffer(response.getBytes()));
				}
				@Override
				public void channelReadComplete(ChannelHandlerContext ctx) throws Exception {					
				}
				@Override
				public void exceptionCaught(ChannelHandlerContext ctx, Throwable t) throws Exception {
				}
			}
			//客户端
			public class Client {
				public static void main(String[] args) throws Exception {					
					EventLoopGroup group = new NioEventLoopGroup();					
					Bootstrap b = new Bootstrap();
					b.group(group)
					 .channel(NioSocketChannel.class)
					 .handler(new ChannelInitializer<SocketChannel>() {
						@Override
						protected void initChannel(SocketChannel sc) throws Exception {
							sc.pipeline().addLast(new FixedLengthFrameDecoder(5));
							sc.pipeline().addLast(new StringDecoder());
							sc.pipeline().addLast(new ClientHandler());
						}
					});					
					ChannelFuture cf = b.connect("127.0.0.1", 8765).sync();					
					cf.channel().writeAndFlush(Unpooled.wrappedBuffer("aaaaabbbbb".getBytes()));
					cf.channel().writeAndFlush(Unpooled.copiedBuffer("ccccccc".getBytes()));					
					//等待客户端端口关闭
					cf.channel().closeFuture().sync();
					group.shutdownGracefully();					
				}
			}
			//ClientHandler
			public class ClientHandler extends ChannelHandlerAdapter{
				@Override
				public void channelActive(ChannelHandlerContext ctx) throws Exception {
					System.out.println("client channel active... ");
				}
				@Override
				public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
					String response = (String)msg;
					System.out.println("Client: " + response);
				}
				@Override
				public void channelReadComplete(ChannelHandlerContext ctx) throws Exception {
				}
				@Override
				public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {
				}
			}
		5、Netty编解码问题：
			含义：实质是Java序列化问题，目的：进行网络传输；对象持久化；
				可以使用对象序列化，但性能太低，一般使用编解码框架：Jboss的Marshalling包、google的Protobuf；
			案例分析：
			//服务端
			public class Server {
				public static void main(String[] args) throws Exception{
					//开启2个线程组
					EventLoopGroup pGroup = new NioEventLoopGroup();
					EventLoopGroup cGroup = new NioEventLoopGroup();
					//辅助工具类
					ServerBootstrap b = new ServerBootstrap();
					b.group(pGroup, cGroup)
					 .channel(NioServerSocketChannel.class)
					 .option(ChannelOption.SO_BACKLOG, 1024)
					 //设置日志级别
					 .handler(new LoggingHandler(LogLevel.INFO))
					 //初始化工作
					 .childHandler(new ChannelInitializer<SocketChannel>() {
						protected void initChannel(SocketChannel sc) throws Exception {
							//管道处理
							sc.pipeline().addLast(MarshallingCodeCFactory.buildMarshallingDecoder());//解码
							sc.pipeline().addLast(MarshallingCodeCFactory.buildMarshallingEncoder());//编码
							sc.pipeline().addLast(new ServerHandler());//处理业务逻辑
						}
					});					
					ChannelFuture cf = b.bind(8765).sync();
					//关闭资源
					cf.channel().closeFuture().sync();
					pGroup.shutdownGracefully();
					cGroup.shutdownGracefully();					
				}
			}
			//编解码工具类
			public final class MarshallingCodeCFactory {
				/**
				 * 创建Jboss Marshalling解码器MarshallingDecoder
				 * @return MarshallingDecoder
				 */
				public static MarshallingDecoder buildMarshallingDecoder() {
					//首先通过Marshalling工具类的精通方法获取Marshalling实例对象 参数serial标识创建的是java序列化工厂对象。
					final MarshallerFactory marshallerFactory = Marshalling.getProvidedMarshallerFactory("serial");
					//创建了MarshallingConfiguration对象，配置了版本号为5 
					final MarshallingConfiguration configuration = new MarshallingConfiguration();
					configuration.setVersion(5);
					//根据marshallerFactory和configuration创建provider
					UnmarshallerProvider provider = new DefaultUnmarshallerProvider(marshallerFactory, configuration);
					//构建Netty的MarshallingDecoder对象，俩个参数分别为provider和单个消息序列化后的最大长度
					MarshallingDecoder decoder = new MarshallingDecoder(provider, 1024 * 1024 * 1);
					return decoder;
				}
				/**
				 * 创建Jboss Marshalling编码器MarshallingEncoder
				 * @return MarshallingEncoder
				 */
				public static MarshallingEncoder buildMarshallingEncoder() {
					final MarshallerFactory marshallerFactory = Marshalling.getProvidedMarshallerFactory("serial");
					final MarshallingConfiguration configuration = new MarshallingConfiguration();
					configuration.setVersion(5);
					MarshallerProvider provider = new DefaultMarshallerProvider(marshallerFactory, configuration);
					//构建Netty的MarshallingEncoder对象，MarshallingEncoder用于实现序列化接口的POJO对象序列化为二进制数组
					MarshallingEncoder encoder = new MarshallingEncoder(provider);
					return encoder;
				}
			}
			//服务端业务逻辑处理，ServerHandler类
			public class ServerHandler extends ChannelHandlerAdapter{
				@Override
				public void channelActive(ChannelHandlerContext ctx) throws Exception {
				}
				@Override
				public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
					Req req = (Req)msg;
					System.out.println("Server : " + req.getId() + ", " + req.getName() + ", " + req.getRequestMessage());
					byte[] attachment = GzipUtils.ungzip(req.getAttachment());
					//程序所在的目录下的文件
					String path = System.getProperty("user.dir") + File.separatorChar + "receive" +  File.separatorChar + "001.jpg";
					FileOutputStream fos = new FileOutputStream(path);
					fos.write(attachment);
					fos.close();
					//服务端响应
					Resp resp = new Resp();
					resp.setId(req.getId());
					resp.setName("resp" + req.getId());
					resp.setResponseMessage("响应内容" + req.getId());
					ctx.writeAndFlush(resp);//.addListener(ChannelFutureListener.CLOSE);
				}
				@Override
				public void channelReadComplete(ChannelHandlerContext ctx) throws Exception {					
				}
				@Override
				public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {
					ctx.close();
				}								
			}
			//基础对象类：Req与Resp
			public class Req implements Serializable{
				private static final long  SerialVersionUID = 1L;				
				private String id;
				private String name;
				private String requestMessage;
				private byte[] attachment;				
				public String getId() {
					return id;
				}
				public void setId(String id) {
					this.id = id;
				}
				public String getName() {
					return name;
				}
				public void setName(String name) {
					this.name = name;
				}
				public String getRequestMessage() {
					return requestMessage;
				}
				public void setRequestMessage(String requestMessage) {
					this.requestMessage = requestMessage;
				}
				public byte[] getAttachment() {
					return attachment;
				}
				public void setAttachment(byte[] attachment) {
					this.attachment = attachment;
				}								
			}
			public class Resp implements Serializable{				
				private static final long serialVersionUID = 1L;				
				private String id;
				private String name;
				private String responseMessage;				
				public String getId() {
					return id;
				}
				public void setId(String id) {
					this.id = id;
				}
				public String getName() {
					return name;
				}
				public void setName(String name) {
					this.name = name;
				}
				public String getResponseMessage() {
					return responseMessage;
				}
				public void setResponseMessage(String responseMessage) {
					this.responseMessage = responseMessage;
				}				
			}
			//压缩/解压工具包
			public class GzipUtils {
				public static byte[] gzip(byte[] data) throws Exception{
					ByteArrayOutputStream bos = new ByteArrayOutputStream();
					GZIPOutputStream gzip = new GZIPOutputStream(bos);
					gzip.write(data);
					gzip.finish();
					gzip.close();
					byte[] ret = bos.toByteArray();
					bos.close();
					return ret;
				}				
				public static byte[] ungzip(byte[] data) throws Exception{
					ByteArrayInputStream bis = new ByteArrayInputStream(data);
					GZIPInputStream gzip = new GZIPInputStream(bis);
					byte[] buf = new byte[1024];
					int num = -1;
					ByteArrayOutputStream bos = new ByteArrayOutputStream();
					while((num = gzip.read(buf, 0 , buf.length)) != -1 ){
						bos.write(buf, 0, num);
					}
					gzip.close();
					bis.close();
					byte[] ret = bos.toByteArray();
					bos.flush();
					bos.close();
					return ret;
				}				
				public static void main(String[] args) throws Exception{					
					//读取文件
					String readPath = System.getProperty("user.dir") + File.separatorChar + "sources" +  File.separatorChar + "006.jpg";
					File file = new File(readPath);  
					FileInputStream in = new FileInputStream(file);  
					byte[] data = new byte[in.available()];  
					in.read(data);  
					in.close();  					
					System.out.println("文件原始大小:" + data.length);
					//测试压缩					
					byte[] ret1 = GzipUtils.gzip(data);
					System.out.println("压缩之后大小:" + ret1.length);					
					byte[] ret2 = GzipUtils.ungzip(ret1);
					System.out.println("还原之后大小:" + ret2.length);					
					//写出文件
					String writePath = System.getProperty("user.dir") + File.separatorChar + "receive" +  File.separatorChar + "006.jpg";
					FileOutputStream fos = new FileOutputStream(writePath);
					fos.write(ret2);
					fos.close();    											
				}												
			}
			//客户端
			public class Client {				
				public static void main(String[] args) throws Exception{					
					EventLoopGroup group = new NioEventLoopGroup();
					Bootstrap b = new Bootstrap();
					b.group(group)
					 .channel(NioSocketChannel.class)
					 .handler(new ChannelInitializer<SocketChannel>() {
						@Override
						protected void initChannel(SocketChannel sc) throws Exception {
							sc.pipeline().addLast(MarshallingCodeCFactory.buildMarshallingDecoder());
							sc.pipeline().addLast(MarshallingCodeCFactory.buildMarshallingEncoder());
							sc.pipeline().addLast(new ClientHandler());
						}
					});					
					ChannelFuture cf = b.connect("127.0.0.1", 8765).sync();					
					for(int i = 0; i < 5; i++ ){
						Req req = new Req();
						req.setId("" + i);
						req.setName("pro" + i);
						req.setRequestMessage("数据信息" + i);	
						String path = System.getProperty("user.dir") + File.separatorChar + "sources" +  File.separatorChar + "001.jpg";
						File file = new File(path);
						FileInputStream in = new FileInputStream(file);  
						byte[] data = new byte[in.available()];  
						in.read(data);  
						in.close(); 
						req.setAttachment(GzipUtils.gzip(data));
						cf.channel().writeAndFlush(req);
					}
					cf.channel().closeFuture().sync();
					group.shutdownGracefully();
				}
			}
			//ClientHandler
			public class ClientHandler extends ChannelHandlerAdapter{				
				@Override
				public void channelActive(ChannelHandlerContext ctx) throws Exception {					
				}
				@Override
				public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
					try {
						Resp resp = (Resp)msg;
						System.out.println("Client : " + resp.getId() + ", " + resp.getName() + ", " + resp.getResponseMessage());			
					} finally {
						ReferenceCountUtil.release(msg);
					}
				}
				@Override
				public void channelReadComplete(ChannelHandlerContext ctx) throws Exception {					
				}
				@Override
				public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {
					ctx.close();
				}				
			}
		6、数据通讯
		   含义：在实际工作中，多台机器可以通过netty通讯，对于参数的设置取决于服务器性能，具体通讯方式可以分为三类：
				a、使用长连接，客户端与服务端一直处于开启连接转态，对服务器的性能要求比较高，而且适用于客户端数量较少的情况，业务场景：滴滴打车
				b、使用短链接，客户端一次批量的提交数据，客户端会把数据临时存储在缓存区或临时表中，当条件满足阈值时，才与服务端连接，提交数据，弊端：不能实时的提交数据
				c、特殊的长连接，规定在一定时间内两者没有通讯，则断开连接，下次连接客户端向服务端发起连接请求，建立连接；但需要注意2个因素：
					超时如何关闭通讯，以及后续如何建立连接；服务端宕机，客户端如何与服务端进行连接（方案：客户端使用job任务，定时检测）；
			案例分析：
				//服务端
			public class Server {
				public static void main(String[] args) throws Exception{
					//开启2个线程组
					EventLoopGroup pGroup = new NioEventLoopGroup();
					EventLoopGroup cGroup = new NioEventLoopGroup();
					//辅助类
					ServerBootstrap b = new ServerBootstrap();
					b.group(pGroup, cGroup)
					 .channel(NioServerSocketChannel.class)
					 .option(ChannelOption.SO_BACKLOG, 1024)
					 //设置日志
					 .handler(new LoggingHandler(LogLevel.INFO))
					 .childHandler(new ChannelInitializer<SocketChannel>() {
						protected void initChannel(SocketChannel sc) throws Exception {
							//管道链
							sc.pipeline().addLast(MarshallingCodeCFactory.buildMarshallingDecoder());
							sc.pipeline().addLast(MarshallingCodeCFactory.buildMarshallingEncoder());
							//设置服务端与客户端超时断开连接时间：5s
							sc.pipeline().addLast(new ReadTimeoutHandler(5)); 
							sc.pipeline().addLast(new ServerHandler());
						}
					});					
					ChannelFuture cf = b.bind(8765).sync();
					//关闭通道 
					cf.channel().closeFuture().sync();
					pGroup.shutdownGracefully();
					cGroup.shutdownGracefully();					
				}
			}
			//JavaBean类
			public class Request implements Serializable{
				private static final long  SerialVersionUID = 1L;				
				private String id;
				private String name;
				private String requestMessage;				
				public String getId() {
					return id;
				}
				public void setId(String id) {
					this.id = id;
				}
				public String getName() {
					return name;
				}
				public void setName(String name) {
					this.name = name;
				}
				public String getRequestMessage() {
					return requestMessage;
				}
				public void setRequestMessage(String requestMessage) {
					this.requestMessage = requestMessage;
				}
			}
			public class Response implements Serializable{				
				private static final long serialVersionUID = 1L;				
				private String id;
				private String name;
				private String responseMessage;				
				public String getId() {
					return id;
				}
				public void setId(String id) {
					this.id = id;
				}
				public String getName() {
					return name;
				}
				public void setName(String name) {
					this.name = name;
				}
				public String getResponseMessage() {
					return responseMessage;
				}
				public void setResponseMessage(String responseMessage) {
					this.responseMessage = responseMessage;
				}				
			}
			//MarshallingCodeCFactory类同上
			//ServerHandler
			public class ServerHandler extends ChannelHandlerAdapter{
				@Override
				public void channelActive(ChannelHandlerContext ctx) throws Exception {
				}
				@Override
				public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
					Request request = (Request)msg;
					System.out.println("Server : " + request.getId() + ", " + request.getName() + ", " + request.getRequestMessage());
					Response response = new Response();
					response.setId(request.getId());
					response.setName("response" + request.getId());
					response.setResponseMessage("响应内容" + request.getId());
					ctx.writeAndFlush(response);//.addListener(ChannelFutureListener.CLOSE);
				}
				@Override
				public void channelReadComplete(ChannelHandlerContext ctx) throws Exception {					
				}
				@Override
				public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {
					ctx.close();
				}								
			}
			//客户端
			public class Client {
				//单例获取实例对象
				private static class SingletonHolder {
					static final Client instance = new Client();
				}				
				public static Client getInstance(){
					return SingletonHolder.instance;
				}
				//建立辅助类
				private EventLoopGroup group;
				private Bootstrap b;
				private ChannelFuture cf;				
				private Client(){
						group = new NioEventLoopGroup();
						b = new Bootstrap();
						b.group(group)
						 .channel(NioSocketChannel.class)
						 .handler(new LoggingHandler(LogLevel.INFO))
						 .handler(new ChannelInitializer<SocketChannel>() {
								@Override
								protected void initChannel(SocketChannel sc) throws Exception {
									sc.pipeline().addLast(MarshallingCodeCFactory.buildMarshallingDecoder());
									sc.pipeline().addLast(MarshallingCodeCFactory.buildMarshallingEncoder());
									//超时handler（当服务器端与客户端在指定时间以上没有任何进行通信，则会关闭响应的通道，主要为减小服务端资源占用）
									sc.pipeline().addLast(new ReadTimeoutHandler(5)); 
									sc.pipeline().addLast(new ClientHandler());
								}
						});
				}				
				public void connect(){
					try {
						this.cf = b.connect("127.0.0.1", 8765).sync();//寻址连接
						System.out.println("远程服务器已经连接, 可以进行数据交换..");				
					} catch (Exception e) {
						e.printStackTrace();
					}
				}
				//获取ChannelFuture对象
				public ChannelFuture getChannelFuture(){					
					if(this.cf == null){
						this.connect();
					}
					if(!this.cf.channel().isActive()){
						this.connect();
					}					
					return this.cf;
				}				
				public static void main(String[] args) throws Exception{
					final Client c = Client.getInstance();
					//c.connect();					
					ChannelFuture cf = c.getChannelFuture();
					for(int i = 1; i <= 3; i++ ){
						Request request = new Request();
						request.setId("" + i);
						request.setName("pro" + i);
						request.setRequestMessage("数据信息" + i);
						cf.channel().writeAndFlush(request);
						//间隔4S写入数据
						TimeUnit.SECONDS.sleep(4);
					}
					cf.channel().closeFuture().sync();					
					//模拟客户端连接服务器
					new Thread(new Runnable() {
						@Override
						public void run() {
							try {
								System.out.println("进入子线程...");
								ChannelFuture cf = c.getChannelFuture();
								System.out.println(cf.channel().isActive());
								System.out.println(cf.channel().isOpen());								
								//再次发送数据
								Request request = new Request();
								request.setId("" + 4);
								request.setName("pro" + 4);
								request.setRequestMessage("数据信息" + 4);
								cf.channel().writeAndFlush(request);					
								cf.channel().closeFuture().sync();
								System.out.println("子线程结束.");
							} catch (InterruptedException e) {
								e.printStackTrace();
							}
						}
					}).start();					
					System.out.println("断开连接,主线程结束..");					
				}											
			}
			//ClientHandler
			public class ClientHandler extends ChannelHandlerAdapter{				
				@Override
				public void channelActive(ChannelHandlerContext ctx) throws Exception {
				}
				@Override
				public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
					try {
						Response resp = (Response)msg;
						System.out.println("Client : " + resp.getId() + ", " + resp.getName() + ", " + resp.getResponseMessage());			
					} finally {
						//只做读取操作，没有写数据需要释放消息
						ReferenceCountUtil.release(msg);
					}
				}
				@Override
				public void channelReadComplete(ChannelHandlerContext ctx) throws Exception {					
				}
				@Override
				public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {
					ctx.close();
				}				
			}
		7、心跳检测
			含义：在服务器集群之间需要进行心跳检测，基于Master-Slaver模式，监控各个服务器节点的各个方面情况（CPU、磁盘、网络），把这样的过程叫心跳检测；
			案例分析（利用netty与sigar相关技术实现心跳检测）：
			//服务端
			public class Server {
				public static void main(String[] args) throws Exception{					
					EventLoopGroup pGroup = new NioEventLoopGroup();
					EventLoopGroup cGroup = new NioEventLoopGroup();					
					ServerBootstrap b = new ServerBootstrap();
					b.group(pGroup, cGroup)
					 .channel(NioServerSocketChannel.class)
					 .option(ChannelOption.SO_BACKLOG, 1024)
					 //设置日志
					 .handler(new LoggingHandler(LogLevel.INFO))
					 .childHandler(new ChannelInitializer<SocketChannel>() {
						protected void initChannel(SocketChannel sc) throws Exception {
							sc.pipeline().addLast(MarshallingCodeCFactory.buildMarshallingDecoder());
							sc.pipeline().addLast(MarshallingCodeCFactory.buildMarshallingEncoder());
							//心跳检测类
							sc.pipeline().addLast(new ServerHeartBeatHandler());
						}
					});					
					ChannelFuture cf = b.bind(8765).sync();					
					cf.channel().closeFuture().sync();
					pGroup.shutdownGracefully();
					cGroup.shutdownGracefully();					
				}
			}
			//ServerHeartBeatHandler类
			public class ServerHeartBeatHandler extends ChannelHandlerAdapter {				
				private static HashMap<String, String> AUTH_IP_MAP = new HashMap<String, String>();
				private static final String SUCCESS_KEY = "auth_success_key";				
				static {
					AUTH_IP_MAP.put("192.168.1.200", "1234");
				}				
				private boolean auth(ChannelHandlerContext ctx, Object msg){
						//System.out.println(msg);
						//从客户端取到的信息
						String [] ret = ((String) msg).split(",");
						String auth = AUTH_IP_MAP.get(ret[0]);
						if(auth != null && auth.equals(ret[1])){
							ctx.writeAndFlush(SUCCESS_KEY);//认证通过
							return true;
						} else {
							ctx.writeAndFlush("auth failure !").addListener(ChannelFutureListener.CLOSE);
							return false;
						}
				}				
				@Override
				public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
					if(msg instanceof String){
						//首次认证
						auth(ctx, msg);
					} else if (msg instanceof RequestInfo) {						
						RequestInfo info = (RequestInfo) msg;
						System.out.println("--------------------------------------------");
						System.out.println("当前主机ip为: " + info.getIp());
						System.out.println("当前主机cpu情况: ");
						HashMap<String, Object> cpu = info.getCpuPercMap();
						System.out.println("总使用率: " + cpu.get("combined"));
						System.out.println("用户使用率: " + cpu.get("user"));
						System.out.println("系统使用率: " + cpu.get("sys"));
						System.out.println("等待率: " + cpu.get("wait"));
						System.out.println("空闲率: " + cpu.get("idle"));
						
						System.out.println("当前主机memory情况: ");
						HashMap<String, Object> memory = info.getMemoryMap();
						System.out.println("内存总量: " + memory.get("total"));
						System.out.println("当前内存使用量: " + memory.get("used"));
						System.out.println("当前内存剩余量: " + memory.get("free"));
						System.out.println("--------------------------------------------");
						//响应数据
						ctx.writeAndFlush("info received!");
					} else {
						ctx.writeAndFlush("connect failure!").addListener(ChannelFutureListener.CLOSE);
					}
				}
			}
			//客户端
			public class Client {				
				public static void main(String[] args) throws Exception{					
					EventLoopGroup group = new NioEventLoopGroup();
					Bootstrap b = new Bootstrap();
					b.group(group)
					 .channel(NioSocketChannel.class)
					 .handler(new ChannelInitializer<SocketChannel>() {
						@Override
						protected void initChannel(SocketChannel sc) throws Exception {
							sc.pipeline().addLast(MarshallingCodeCFactory.buildMarshallingDecoder());
							sc.pipeline().addLast(MarshallingCodeCFactory.buildMarshallingEncoder());
							//心跳检测类
							sc.pipeline().addLast(new ClienHeartBeattHandler());
						}
					});
					//寻址连接
					ChannelFuture cf = b.connect("127.0.0.1", 8765).sync();
					cf.channel().closeFuture().sync();
					group.shutdownGracefully();
				}
			}
			//ClienHeartBeattHandler
			public class ClienHeartBeattHandler extends ChannelHandlerAdapter {
				//池化技术，特点是可以定时执行任务
				private ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(1);				
				private ScheduledFuture<?> heartBeat;
				//主动向服务器发送认证信息
				private InetAddress addr;				
				private static final String SUCCESS_KEY = "auth_success_key";
				@Override
				public void channelActive(ChannelHandlerContext ctx) throws Exception {
					addr = InetAddress.getLocalHost();
					String ip = addr.getHostAddress();
					String key = "1234";
					//证书，由两部分构成：IP与KEY
					String auth = ip + "," + key;
					//写出
					ctx.writeAndFlush(auth);
				}				
				@Override
				public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
					try {
						if(msg instanceof String){
							String ret = (String)msg;
							if(SUCCESS_KEY.equals(ret)){
								// 握手成功，主动发送心跳消息，每2S执行一次任务
								this.heartBeat = this.scheduler.scheduleWithFixedDelay(new HeartBeatTask(ctx), 0, 2, TimeUnit.SECONDS);
								System.out.println(msg);    			
							}
							else {
								System.out.println(msg);
							}
						}
					} finally {
						ReferenceCountUtil.release(msg);
					}
				}
				//线程任务
				private class HeartBeatTask implements Runnable {
					private final ChannelHandlerContext ctx;
					public HeartBeatTask(final ChannelHandlerContext ctx) {
						this.ctx = ctx;
					}				
					@Override
					public void run() {
						try {
							RequestInfo info = new RequestInfo();
							//ip
							info.setIp(addr.getHostAddress());
							Sigar sigar = new Sigar();
							//cpu prec
							CpuPerc cpuPerc = sigar.getCpuPerc();
							HashMap<String, Object> cpuPercMap = new HashMap<String, Object>();
							cpuPercMap.put("combined", cpuPerc.getCombined());
							cpuPercMap.put("user", cpuPerc.getUser());
							cpuPercMap.put("sys", cpuPerc.getSys());
							cpuPercMap.put("wait", cpuPerc.getWait());
							cpuPercMap.put("idle", cpuPerc.getIdle());
							// memory
							Mem mem = sigar.getMem();
							HashMap<String, Object> memoryMap = new HashMap<String, Object>();
							memoryMap.put("total", mem.getTotal() / 1024L);
							memoryMap.put("used", mem.getUsed() / 1024L);
							memoryMap.put("free", mem.getFree() / 1024L);
							info.setCpuPercMap(cpuPercMap);
							info.setMemoryMap(memoryMap);
							ctx.writeAndFlush(info);
							
						} catch (Exception e) {
							e.printStackTrace();
						}
					}
					public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {
						cause.printStackTrace();
						if (heartBeat != null) {
							heartBeat.cancel(true);
							heartBeat = null;
						}
						ctx.fireExceptionCaught(cause);
					}					
				}
			}
			//JavaBean类
			public class RequestInfo implements Serializable {
				private String ip ;
				private HashMap<String, Object> cpuPercMap ;
				private HashMap<String, Object> memoryMap;				
				public String getIp() {
					return ip;
				}
				public void setIp(String ip) {
					this.ip = ip;
				}
				public HashMap<String, Object> getCpuPercMap() {
					return cpuPercMap;
				}
				public void setCpuPercMap(HashMap<String, Object> cpuPercMap) {
					this.cpuPercMap = cpuPercMap;
				}
				public HashMap<String, Object> getMemoryMap() {
					return memoryMap;
				}
				public void setMemoryMap(HashMap<String, Object> memoryMap) {
					this.memoryMap = memoryMap;
				}								
			}
		8、基于Http协议实现上传/下载（了解即可，实现文件的上传与下载可以使用专业的框架：如FastDfs、HDFs）
			Http协议的认识：超文本传输协议，是基于TCP协议之上的运用层协议，主要用于WEB开发；Netty下的Http也是异步非阻塞的，Http协议特点：简单（使用简单、在URL中携带必要参数即可）、
			灵活（支持任意类型的数据对象）、无状态（对事务处理没有记忆能力、即想获取之前的信息必须重新请求）；构成：请求行、请求头、请求体组成；
			请求方式：GET、POST、HEAD、PUT、DELETE、TRACE、CONNECT、OPTINS
			响应码：
				1XX：提示信息；2XX：成功；3XX：重定向；4XX:客户端错误；5XX:服务端错误；
				常见状态码：200 OK、400 Bad Request（语法不对）、401 Unauthorized（未授权）、403 Forbidden（服务器拒绝）、404 Not Fund（找不到）、405 Method Not Allowed（请求方式不被允许）
							500 Inernal Server Error（服务器内部错误）、503 Server Unavailable （服务当前不可用）；
			案例分析：（Netty实现文件上传核心利用的是chuck分片断点续传技术）		
			#与Http的整合例子
			public final class HttpHelloWorldServer {
				  //安全验证
				  static final boolean SSL = System.getProperty("ssl") != null;
				  static final int PORT = Integer.parseInt(System.getProperty("port", SSL? "8443" : "8080"));			  
				  public static void main(String[] args) throws Exception {
					  //配置SSL
					  final SslContext sslCtx;
					  if (SSL) {
						  SelfSignedCertificate ssc = new SelfSignedCertificate();
						  sslCtx = SslContext.newServerContext(ssc.certificate(), ssc.privateKey());
					  } else {
						  sslCtx = null;
					  }			  
					  //配置服务端
					  EventLoopGroup bossGroup = new NioEventLoopGroup(1);
					  EventLoopGroup workerGroup = new NioEventLoopGroup();
					  try {
						  ServerBootstrap b = new ServerBootstrap();
						  b.option(ChannelOption.SO_BACKLOG, 1024);
						  b.group(bossGroup, workerGroup)
						   .channel(NioServerSocketChannel.class)
						   .handler(new LoggingHandler(LogLevel.INFO))
						   .childHandler(new HttpHelloWorldServerInitializer(sslCtx));			  
						  Channel ch = b.bind(PORT).sync().channel();			  
						  System.err.println("Open your web browser and navigate to " +
								  (SSL? "https" : "http") + "://127.0.0.1:" + PORT + '/');			  
						  ch.closeFuture().sync();
					  } finally {
						  bossGroup.shutdownGracefully();
						  workerGroup.shutdownGracefully();
					  }
				  }				  				  
			}
			#HttpHelloWorldServerInitializer
			public class HttpHelloWorldServerInitializer extends ChannelInitializer<SocketChannel> {			  
				  private final SslContext sslCtx;			  
				  public HttpHelloWorldServerInitializer(SslContext sslCtx) {
					 this.sslCtx = sslCtx;
				  }			  
				  @Override
				  public void initChannel(SocketChannel ch) {
					  ChannelPipeline p = ch.pipeline();
					  if (sslCtx != null) {
						  p.addLast(sslCtx.newHandler(ch.alloc()));
					  }
					  //管道链
					  p.addLast(new HttpServerCodec());
					  p.addLast(new HttpHelloWorldServerHandler());
				  }
			  }
			  public class HttpHelloWorldServerHandler extends ChannelHandlerAdapter {
				  //连接OK，响应标识
				  private static final byte[] CONTENT = { 'H', 'e', 'l', 'l', 'o', ' ', 'W', 'o', 'r', 'l', 'd' };			  
				  @Override
				  public void channelReadComplete(ChannelHandlerContext ctx) {
					  ctx.flush();
				  }			  
				  @Override
				  public void channelRead(ChannelHandlerContext ctx, Object msg) {
					  if (msg instanceof HttpRequest) {
						  HttpRequest req = (HttpRequest) msg;			  
						  if (HttpHeaderUtil.is100ContinueExpected(req)) {
							  ctx.write(new DefaultFullHttpResponse(HTTP_1_1, CONTINUE));
						  }
						  boolean keepAlive = HttpHeaderUtil.isKeepAlive(req);
						  FullHttpResponse response = new DefaultFullHttpResponse(HTTP_1_1, OK, Unpooled.wrappedBuffer(CONTENT));
						  response.headers().set(CONTENT_TYPE, "text/plain");
						  response.headers().setInt(CONTENT_LENGTH, response.content().readableBytes());			  
						  if (!keepAlive) {
							  ctx.write(response).addListener(ChannelFutureListener.CLOSE);
						  } else {
							  response.headers().set(CONNECTION, HttpHeaderValues.KEEP_ALIVE);
							  ctx.write(response);
						  }
					  }
				  }			  
				  @Override
				  public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {
					  cause.printStackTrace();
					  ctx.close();
				  }
			  }
			  #注：浏览器访问:127.0.0.1:8080，页面出现Hello Word，说明netty与http配置成功！
			  #FileList列表
			  public class HttpFileServer {
				private static final String DEFAULT_URL = "/sources/";
				public void run(final int port, final String url) throws Exception {
					EventLoopGroup bossGroup = new NioEventLoopGroup();
					EventLoopGroup workerGroup = new NioEventLoopGroup();
					try {
						ServerBootstrap b = new ServerBootstrap();
						b.group(bossGroup, workerGroup)
							.channel(NioServerSocketChannel.class)
							.childHandler(new ChannelInitializer<SocketChannel>() {
							@Override
							protected void initChannel(SocketChannel ch)
								throws Exception {
								// 加入http的解码器
								ch.pipeline().addLast("http-decoder", new HttpRequestDecoder());
								// 加入ObjectAggregator解码器，作用是他会把多个消息转换为单一的FullHttpRequest或者FullHttpResponse
								ch.pipeline().addLast("http-aggregator", new HttpObjectAggregator(65536));
								// 加入http的编码器
								ch.pipeline().addLast("http-encoder", new HttpResponseEncoder());
								// 加入chunked 主要作用是支持异步发送的码流（大文件传输），但不专用过多的内存，防止java内存溢出
								ch.pipeline().addLast("http-chunked", new ChunkedWriteHandler());
								// 加入自定义处理文件服务器的业务逻辑handler
								ch.pipeline().addLast("fileServerHandler",new HttpFileServerHandler(url));									
							}
							});
						ChannelFuture future = b.bind("192.168.1.200", port).sync();
						System.out.println("HTTP文件目录服务器启动，网址是 : " + "http://192.168.1.200:"  + port + url);
						future.channel().closeFuture().sync();
					} finally {
						bossGroup.shutdownGracefully();
						workerGroup.shutdownGracefully();
					}
				}
				public static void main(String[] args) throws Exception {
					int port = 8765;
					String url = DEFAULT_URL;
					new HttpFileServer().run(port, url);
				}
			}
			public class HttpFileServerHandler extends SimpleChannelInboundHandler<FullHttpRequest> {				
				private final String url;
				public HttpFileServerHandler(String url) {
					this.url = url;
				}
				@Override
				public void messageReceived(ChannelHandlerContext ctx, FullHttpRequest request) throws Exception {
					//对请求的解码结果进行判断：
					if (!request.decoderResult().isSuccess()) {
						// 400
						sendError(ctx, BAD_REQUEST);
						return;
					}
					//对请求方式进行判断：如果不是get方式（如post方式）则返回异常
					if (request.method() != GET) {
						// 405
						sendError(ctx, METHOD_NOT_ALLOWED);
						return;
					}
					//获取请求uri路径
					final String uri = request.uri();
					//对url进行分析，返回本地系统
					final String path = sanitizeUri(uri);
					//如果 路径构造不合法，则path为null
					if (path == null) {
						//403
						sendError(ctx, FORBIDDEN);
						return;
					}
					// 创建file对象
					File file = new File(path);
					// 判断文件是否为隐藏或者不存在
					if (file.isHidden() || !file.exists()) {
						// 404 
						sendError(ctx, NOT_FOUND);
						return;
					}
					// 如果为文件夹
					if (file.isDirectory()) {
						if (uri.endsWith("/")) {
							//如果以正常"/"结束 说明是访问的一个文件目录：则进行展示文件列表（web服务端则可以跳转一个Controller，遍历文件并跳转到一个页面）
							sendListing(ctx, file);
						} else {
							//如果非"/"结束 则重定向，补全"/" 再次请求
							sendRedirect(ctx, uri + '/');
						}
						return;
					}
					// 如果所创建的file对象不是文件类型
					if (!file.isFile()) {
						// 403
						sendError(ctx, FORBIDDEN);
						return;
					}					
					//随机文件读写类
					RandomAccessFile randomAccessFile = null;
					try {
						randomAccessFile = new RandomAccessFile(file, "r");// 以只读的方式打开文件
					} catch (FileNotFoundException fnfe) {
						// 404
						sendError(ctx, NOT_FOUND);
						return;
					}					
					//获取文件长度
					long fileLength = randomAccessFile.length();
					//建立响应对象
					HttpResponse response = new DefaultHttpResponse(HTTP_1_1, OK);
					//设置响应信息
					HttpHeaderUtil.setContentLength(response, fileLength);
					//设置响应头
					setContentTypeHeader(response, file);
					//如果一直保持连接则设置响应头信息为：HttpHeaders.Values.KEEP_ALIVE
					if (HttpHeaderUtil.isKeepAlive(request)) {
						response.headers().set(CONNECTION, HttpHeaderValues.KEEP_ALIVE);
					}
					//进行写出
					ctx.write(response);					
					//构造发送文件线程，将文件写入到Chunked缓冲区中
					ChannelFuture sendFileFuture;
					//写出ChunkedFile
					sendFileFuture = ctx.write(new ChunkedFile(randomAccessFile, 0, fileLength, 8192), ctx.newProgressivePromise());
					//添加传输监听，文件上传进度监听
					sendFileFuture.addListener(new ChannelProgressiveFutureListener() {
						@Override
						public void operationProgressed(ChannelProgressiveFuture future, long progress, long total) {
							if (total < 0) { // total unknown
								System.err.println("Transfer progress: " + progress);
							} else {
								System.err.println("Transfer progress: " + progress + " / " + total);
							}
						}
						@Override
						public void operationComplete(ChannelProgressiveFuture future) throws Exception {
							System.out.println("Transfer complete.");
						}
					});					
					//如果使用Chunked编码，最后则需要发送一个编码结束的看空消息体，进行标记，表示所有消息体已经成功发送完成。
					ChannelFuture lastContentFuture = ctx.writeAndFlush(LastHttpContent.EMPTY_LAST_CONTENT);
					//如果当前连接请求非Keep-Alive ，最后一包消息发送完成后 服务器主动关闭连接
					if (!HttpHeaderUtil.isKeepAlive(request)) {
						lastContentFuture.addListener(ChannelFutureListener.CLOSE);
					}
				}
				@Override
				public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {
					if (ctx.channel().isActive()) {
						sendError(ctx, INTERNAL_SERVER_ERROR);
						ctx.close();
					}
				}
				//非法URI正则
				private static final Pattern INSECURE_URI = Pattern.compile(".*[<>&\"].*");
				/**
				 * <B>方法名称：</B>解析URI<BR>
				 * <B>概要说明：</B>对URI进行分析<BR>
				 * @param uri netty包装后的字符串对象
				 * @return path 解析结果
				 */
				private String sanitizeUri(String uri) {
					try {
						//使用UTF-8字符集
						uri = URLDecoder.decode(uri, "UTF-8");
					} catch (UnsupportedEncodingException e) {
						try {
							//尝试ISO-8859-1
							uri = URLDecoder.decode(uri, "ISO-8859-1");
						} catch (UnsupportedEncodingException e1) {
							//抛出预想外异常信息
							throw new Error();
						}
					}
					// 对uri进行细粒度判断：4步验证操作
					// step 1 基础验证
					if (!uri.startsWith(url)) {
						return null;
					}
					// step 2 基础验证
					if (!uri.startsWith("/")) {
						return null;
					}
					// step 3 将文件分隔符替换为本地操作系统的文件路径分隔符
					uri = uri.replace('/', File.separatorChar);
					// step 4 二次验证合法性
					if (uri.contains(File.separator + '.')
						|| uri.contains('.' + File.separator) || uri.startsWith(".")
						|| uri.endsWith(".") || INSECURE_URI.matcher(uri).matches()) {
						return null;
					}
					//当前工程所在目录 + URI构造绝对路径进行返回 
					return System.getProperty("user.dir") + File.separator + uri;
				}				
				//文件是否被允许访问下载验证
				private static final Pattern ALLOWED_FILE_NAME = Pattern.compile("[A-Za-z0-9][-_A-Za-z0-9\\.]*");
				private static void sendListing(ChannelHandlerContext ctx, File dir) {
					// 设置响应对象
					FullHttpResponse response = new DefaultFullHttpResponse(HTTP_1_1, OK);
					// 响应头
					response.headers().set(CONTENT_TYPE, "text/html; charset=UTF-8");
					// 追加文本内容
					StringBuilder ret = new StringBuilder();
					String dirPath = dir.getPath();
					ret.append("<!DOCTYPE html>\r\n");
					ret.append("<html><head><title>");
					ret.append(dirPath);
					ret.append(" 目录：");
					ret.append("</title></head><body>\r\n");
					ret.append("<h3>");
					ret.append(dirPath).append(" 目录：");
					ret.append("</h3>\r\n");
					ret.append("<ul>");
					ret.append("<li>链接：<a href=\"../\">..</a></li>\r\n");					
					// 遍历文件 添加超链接
					for (File f : dir.listFiles()) {
						//step 1: 跳过隐藏或不可读文件 
						if (f.isHidden() || !f.canRead()) {
							continue;
						}
						String name = f.getName();
						//step 2: 如果不被允许，则跳过此文件
						if (!ALLOWED_FILE_NAME.matcher(name).matches()) {
							continue;
						}
						//拼接超链接即可
						ret.append("<li>链接：<a href=\"");
						ret.append(name);
						ret.append("\">");
						ret.append(name);
						ret.append("</a></li>\r\n");
					}
					ret.append("</ul></body></html>\r\n");
					//构造结构，写入缓冲区
					ByteBuf buffer = Unpooled.copiedBuffer(ret, CharsetUtil.UTF_8);
					//进行写出操作
					response.content().writeBytes(buffer);
					//重置写出区域
					buffer.release();
					//使用ctx对象写出并且刷新到SocketChannel中去 并主动关闭连接(这里是指关闭处理发送数据的线程连接)
					ctx.writeAndFlush(response).addListener(ChannelFutureListener.CLOSE);
				}
				//重定向操作
				private static void sendRedirect(ChannelHandlerContext ctx, String newUri) {
					//建立响应对象
					FullHttpResponse response = new DefaultFullHttpResponse(HTTP_1_1, FOUND);
					//设置新的请求地址放入响应对象中去
					response.headers().set(LOCATION, newUri);
					//使用ctx对象写出并且刷新到SocketChannel中去 并主动关闭连接(这里是指关闭处理发送数据的线程连接)
					ctx.writeAndFlush(response).addListener(ChannelFutureListener.CLOSE);
				}
				//错误信息
				private static void sendError(ChannelHandlerContext ctx, HttpResponseStatus status) {
					//建立响应对象
					FullHttpResponse response = new DefaultFullHttpResponse(HTTP_1_1, status, Unpooled.copiedBuffer("Failure: " + status.toString()+ "\r\n", CharsetUtil.UTF_8));
					//设置响应头信息
					response.headers().set(CONTENT_TYPE, "text/plain; charset=UTF-8");
					//使用ctx对象写出并且刷新到SocketChannel中去 并主动关闭连接(这里是指关闭处理发送数据的线程连接)
					ctx.writeAndFlush(response).addListener(ChannelFutureListener.CLOSE);
				}
				private static void setContentTypeHeader(HttpResponse response, File file) {
					//使用mime对象获取文件类型
					MimetypesFileTypeMap mimeTypesMap = new MimetypesFileTypeMap();
					response.headers().set(CONTENT_TYPE, mimeTypesMap.getContentType(file.getPath()));
				}
			}