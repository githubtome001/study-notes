----------------------------------------------Java高级运用技术篇之设计模式-------------------------------------------------------------------------------------------------------				
	设计模式
		重要性：设计模式不依赖于语言，对普遍存在的各种问题，所提出的解决方案，思想来源于建筑学。
				项目的后期维护扩展，有新需求，都需要设计模式。
				在软件中的运用：面向对象(oo)->功能模块[设计模式+算法/数据结构]->框架[多种设计模式]->架构[服务器集群]
		Java设计模式：23种、七大原则
			目的：为了让软件具有更好的代码重用性[相同的功能，不需要重复编写]、可读性[规范性]、可扩展性[增加新功能非常方便，可维护性]、可靠性[新功能对就功能不会产生影响]，->高内聚、降低耦合性。
			七大原则：是设计模式的基础
				单一职责原则-一个类只负责一项职责，降低类的负责度，提高可读性、可维护性，降低风险。当类方法很少，可以在方法级别实现单一职责原则。				
					//方案一
					public class SingleResponsibility1 {
						public static void main(String[] args) {
							RoadVehicle roadVehicle = new RoadVehicle();
							roadVehicle.run("摩托车");
							roadVehicle.run("汽车");
							
							AirVehicle airVehicle = new AirVehicle();						
							airVehicle.run("飞机");
						}
					}
					//1. 遵守单一职责原则
					//2. 但是这样做的改动很大，即将类分解，同时修改客户端
					//3. 改进：直接修改Vehicle 类，改动的代码会比较少=>方案2
					class RoadVehicle {
						public void run(String vehicle) {
							System.out.println(vehicle + "公路运行");
						}
					}
					class AirVehicle {
						public void run(String vehicle) {
							System.out.println(vehicle + "天空运行");
						}
					}
					class WaterVehicle {
						public void run(String vehicle) {
							System.out.println(vehicle + "水中运行");
						}
					}
					//方案二
					public class SingleResponsibility2 {
							public static void main(String[] args) {
								Vehicle2 vehicle2  = new Vehicle2();
								vehicle2.run("汽车");
								vehicle2.runWater("轮船");
								vehicle2.runAir("飞机");
							}

						}
						//1. 这种修改方法没有对原来的类做大的修改，只是增加方法
						//2. 这里虽然没有在类这个级别上遵守单一职责原则，但是在方法级别上，仍然是遵守单一职责
						class Vehicle2 {
							public void run(String vehicle) {								
								System.out.println(vehicle + " 在公路上运行....");								
							}						
							public void runAir(String vehicle) {
								System.out.println(vehicle + " 在天空上运行....");
							}							
							public void runWater(String vehicle) {
								System.out.println(vehicle + " 在水中行....");
							}							
						}
				接口隔离原则-一个类对另一个类的依赖应建立在最小接口上。
					UML类图：
							 依赖										实现
						A类	------->接口[最小接口，接口拆分多个接口]<------- B类
							 依赖           							实现 
						C类	------->接口[最小接口，接口拆分多个接口]<------- D类
					如：public class Segregation1 {
							public static void main(String[] args) {
								A a = new A();
								a.depend1(new B()); // A类通过接口去依赖B类
								a.depend2(new B());
								a.depend3(new B());

								C c = new C();
								c.depend1(new D()); // C类通过接口去依赖(使用)D类
								c.depend4(new D());
								c.depend5(new D());
							}
						}
						// 接口1
						interface Interface1 {
							void operation1();

						}
						// 接口2
						interface Interface2 {
							void operation2();
							void operation3();
						}
						// 接口3
						interface Interface3 {
							void operation4();
							void operation5();
						}
						class B implements Interface1, Interface2 {
							public void operation1() {
								System.out.println("B 实现了 operation1");
							}
							public void operation2() {
								System.out.println("B 实现了 operation2");
							}
							public void operation3() {
								System.out.println("B 实现了 operation3");
							}

						}
						class D implements Interface1, Interface3 {
							public void operation1() {
								System.out.println("D 实现了 operation1");
							}
							public void operation4() {
								System.out.println("D 实现了 operation4");
							}
							public void operation5() {
								System.out.println("D 实现了 operation5");
							}
						}
						class A { // A 类通过接口Interface1,Interface2 依赖(使用) B类，但是只会用到1,2,3方法
							public void depend1(Interface1 i) {
								i.operation1();
							}
							public void depend2(Interface2 i) {
								i.operation2();
							}
							public void depend3(Interface2 i) {
								i.operation3();
							}
						}
						class C { // C 类通过接口Interface1,Interface3 依赖(使用) D类，但是只会用到1,4,5方法
							public void depend1(Interface1 i) {
								i.operation1();
							}
							public void depend4(Interface3 i) {
								i.operation4();
							}
							public void depend5(Interface3 i) {
								i.operation5();
							}
						}												
				依赖倒转[倒置]原则-核心思想是面向接口编程，使程序有一个缓冲层，抽象不依赖细节，细节依赖抽象，接口或抽象类制定规范，细节交给实现类
					坚持3种传递方式：利用接口、构造器、setter进行依赖传递！注意细节：1，低层模块尽量是接口或抽象类；2，变量尽量使用是接口或抽象类；3，继承了里氏替换原则
					如：public class DependecyInversion {
							public static void main(String[] args) {
								//客户端无需改变
								Person person = new Person();
								person.receive(new Email());								
								person.receive(new WeiXin());
							}
						}
						//定义接口
						interface IReceiver {
							public String getInfo();
						}
						class Email implements IReceiver {
							public String getInfo() {
								return "电子邮件信息: hello,world";
							}
						}
						//增加微信
						class WeiXin implements IReceiver {
							public String getInfo() {
								return "微信信息: hello,ok";
							}
						}
						class Person {							
							public void receive(IReceiver receiver) {//这里我们是对接口的依赖
								System.out.println(receiver.getInfo());
							}
						}
					传递方式：
						public class DependencyPass {
							public static void main(String[] args) {
								//通过接口进行依赖传递
								ChangHong changHong = new ChangHong();
						//		OpenAndClose openAndClose = new OpenAndClose();
						//		openAndClose.open(changHong);								
								//通过构造器进行依赖传递
						//		OpenAndClose openAndClose = new OpenAndClose(changHong);
						//		openAndClose.open();
								//通过setter方法进行依赖传递
								OpenAndClose openAndClose = new OpenAndClose();
								openAndClose.setTv(changHong);
								openAndClose.open();
							}
						}
						// 方式1：通过接口传递，2接口2实现
						// 开关接口
						// interface IOpenAndClose {
						// public void open(ITV tv); //抽象方法,接收接口
						// }
						// interface ITV { //ITV接口
						// public void play();
						// } 
						// class ChangHong implements ITV {
						//	@Override
						//	public void play() {
						//		System.out.println("长虹电视机，打开");
						//	} 
						// }
						// 实现接口
						// class OpenAndClose implements IOpenAndClose{
						// public void open(ITV tv){
						// tv.play();
						// }
						// }
						// 方式2: 通过构造方法，2接口1实现
						// interface IOpenAndClose {
						// public void open(); //抽象方法
						// }
						// interface ITV { //ITV接口
						// public void play();
						// }
						// class OpenAndClose implements IOpenAndClose{
						// public ITV tv; //成员
						// public OpenAndClose(ITV tv){ //构造器
						// this.tv = tv;
						// }
						// public void open(){
						// this.tv.play();
						// }
						// }
						// 方式3 , 通过setter方法传递
						interface IOpenAndClose {
							public void open(); // 抽象方法
							public void setTv(ITV tv);
						}
						interface ITV { // ITV接口
							public void play();
						}
						class OpenAndClose implements IOpenAndClose {
							private ITV tv;
							public void setTv(ITV tv) {
								this.tv = tv;
							}
							public void open() {
								this.tv.play();
							}
						}
						class ChangHong implements ITV {
							@Override
							public void play() {
								System.out.println("长虹电视机，打开");
							}							 
						}
				里氏替换原则-正确使用继承[将父类与子类去继承更基础的类,原有的继承关系被打断]，继承会使耦合性增强，尽量不要去修改父类的方法；在适当的时候可以使用聚合、组合、依赖来解决这一问题！
					如：public class Liskov {
							public static void main(String[] args) {
								A a = new A();
								System.out.println("11-3=" + a.func1(11, 3));
								B b = new B();
								//调用完成的功能就会很明确
								System.out.println("11+3+9=" + b.func2(11, 3));									
								//使用组合仍然可以使用到A类相关方法
								System.out.println("11-3=" + b.func3(11, 3));// 这里本意是求出11-3								
							}
						}
						//创建一个更加基础的基类
						class Base {
							//把更加基础的方法和成员写到Base类
						}
						// A类
						class A extends Base {
							// 返回两个数的差
							public int func1(int num1, int num2) {
								return num1 - num2;
							}
						}
						// 增加了一个新功能：完成两个数相加,然后和9求和
						class B extends Base {
							//如果B需要使用A类的方法,使用组合关系
							private A a = new A();							
							public int func1(int a, int b) {
								return a + b;
							}
							public int func2(int a, int b) {
								return func1(a, b) + 9;
							}							
							//我们仍然想使用A的方法
							public int func3(int a, int b) {
								return this.a.func1(a, b);
							}
						}					
				开闭[ocp]原则-对扩展者开放[提供方]，对修改者关闭[使用者，调用者]，核心！
					如：public class Ocp {
							public static void main(String[] args) {
								GraphicEditor graphicEditor = new GraphicEditor();
								graphicEditor.drawShape(new Rectangle());
								graphicEditor.drawShape(new Circle());
								graphicEditor.drawShape(new Triangle());
								graphicEditor.drawShape(new OtherGraphic());
							}
						}
						//这是一个用于绘图的类 [使用方]
						class GraphicEditor {							
							public void drawShape(Shape s) {//接收Shape对象，调用draw方法
								s.draw();
							}							
						}
						//Shape类，基类
						abstract class Shape {
							int m_type;							
							public abstract void draw();//抽象方法
						}
						//扩展方
						class Rectangle extends Shape {
							Rectangle() {
								super.m_type = 1;
							}
							@Override
							public void draw() {
								System.out.println(" 绘制矩形 ");
							}
						}
						class Circle extends Shape {
							Circle() {
								super.m_type = 2;
							}
							@Override
							public void draw() {
								System.out.println(" 绘制圆形 ");
							}
						}
						//新增画三角形
						class Triangle extends Shape {
							Triangle() {
								super.m_type = 3;
							}
							@Override
							public void draw() {
								System.out.println(" 绘制三角形 ");
							}
						}
						//新增一个图形
						class OtherGraphic extends Shape {
							OtherGraphic() {
								super.m_type = 4;
							}
							@Override
							public void draw() {
								System.out.println(" 绘制其它图形 ");
							}
						}					
				迪米特法则-最少知道原则，只与直接朋友通讯。
					耦合关系：组合、关联、聚合、依赖、泛化、实现。
					直接朋友：a类与b类直接朋友，若a类成员变量、方法参数、方法返回值是b类，两者是直接朋友；而出现在局部变量里的b类则称为陌生的类；						
						如：public class Demeter1 {
								public static void main(String[] args) {
									System.out.println("~~~使用迪米特法则~~");
									//创建了一个 SchoolManager 对象
									SchoolManager schoolManager = new SchoolManager();
									//输出学院的员工id 和  学校总部的员工信息
									schoolManager.printAllEmployee(new CollegeManager());
								}
							}
							//学校总部员工类
							class Employee {
								private String id;
								public void setId(String id) {
									this.id = id;
								}
								public String getId() {
									return id;
								}
							}
							//学院的员工类
							class CollegeEmployee {
								private String id;
								public void setId(String id) {
									this.id = id;
								}
								public String getId() {
									return id;
								}
							}
							//管理学院员工的管理类
							class CollegeManager {
								//返回学院的所有员工
								public List<CollegeEmployee> getAllEmployee() {
									List<CollegeEmployee> list = new ArrayList<CollegeEmployee>();
									for (int i = 0; i < 10; i++) { //这里我们增加了10个员工到 list
										CollegeEmployee emp = new CollegeEmployee();
										emp.setId("学院员工id= " + i);
										list.add(emp);
									}
									return list;
								}								
								//输出学院员工的信息
								public void printEmployee() {
									//获取到学院员工
									List<CollegeEmployee> list1 = getAllEmployee();
									System.out.println("------------学院员工------------");
									for (CollegeEmployee e : list1) {
										System.out.println(e.getId());
									}
								}
							}
							//学校管理类
							class SchoolManager {
								//返回学校总部的员工
								public List<Employee> getAllEmployee() {
									List<Employee> list = new ArrayList<Employee>();									
									for (int i = 0; i < 5; i++) { //这里我们增加了5个员工到 list
										Employee emp = new Employee();
										emp.setId("学校总部员工id= " + i);
										list.add(emp);
									}
									return list;
								}
								//该方法完成输出学校总部和学院员工信息(id)
								void printAllEmployee(CollegeManager sub) {									
									//分析问题
									//1. 将输出学院的员工方法，封装到CollegeManager，符合最少知道原则
									sub.printEmployee();								
									//获取到学校总部员工
									List<Employee> list2 = this.getAllEmployee();
									System.out.println("------------学校总部员工------------");
									for (Employee e : list2) {
										System.out.println(e.getId());
									}
								}
							}						
				合成复用原则-尽量使用合成/聚合的方式[UML类图的关系]，而不是使用继承
				总结:针对接口编程，而不是实现编程；为松耦合而努力；			
			UML类图
				定义：统一建模语言，画图
				符号含义：Note:注释；Class：类，可以添加属性与方法；Interface：接口；Dependency：依赖（使用）；Association：关联；
					      Generalization：泛化（继承）；Realization：实现；Aggregation：聚合；Composite：组合
				分类：类图[核心]、用例图、时序图、活动图
				类图关系：依赖（使用）、关联、泛化（继承）、实现、聚合、组合
					依赖：一个类使用到了其他的类，就存在依赖；
					泛化（继承）:继承关系，依赖关系的特例；
					实现：实现关系，依赖关系的特例；
					关联：关联关系，依赖关系的特例；一对一，一对多[多对一]，多对多关系；具有导航性[单向/双向]
					聚合：表示整体与部分之间的关系，整体与部分可以分开，关联关系的特例；代码中体现：setter方法
					组合：表示整体与部分之间的关系，整体与部分可以不可分开[同生共死]，关联关系的特例；代码中体现：new 关键字；				
			设计模式：
				解决某类问题通用的解决方案
				类型：23种
					创建型模式：[对象的创建]，单例模式、抽象工厂模式、原型模式、建造者模式、工厂模式
					结构型模式：[软件结构]，适配器模式、桥接模式、装饰模式、组合模式、外观模式、享元模式、代理模式
					行为型模式：[方法]，模板方法模式、命令模式、访问者模式、迭代器模式、观察者模式、中介者模式、备忘录模式、解析器模式、状态模式、策略模式、职责链模式（责任链模式）			
			创建型模式：	
				单例模式：
					含义：某个类只存在一个对象实例；通过一个静态方法来获取这个对象实例；
					方式：8种
						饿汉式（静态变量）、饿汉式（静态代码块）-2种[核心思想是在类加载的时候创建类的实例]
						懒汉式（线程不安全）、懒汉式（线程安全，同步方法）、懒汉式（线程安全，同步代码块）-3种
						双重检查
						静态内部类
						枚举
					1、饿汉式（静态变量）：
					如：public class SingletonTest01 {
							public static void main(String[] args) {
								//测试
								Singleton instance1 = Singleton.getInstance();
								Singleton instance2 = Singleton.getInstance();
								System.out.println(instance1 == instance2); // true
								System.out.println("instance1.hashCode=" + instance1.hashCode());
								System.out.println("instance2.hashCode=" + instance2.hashCode());
							}
						}
						//饿汉式(静态变量)
						class Singleton {							
							//1. 构造器私有化, 外部能new
							private Singleton() {								
							}							
							//2.本类内部创建对象实例
							private final static Singleton instance = new Singleton();							
							//3. 提供一个公有的静态方法，返回实例对象
							public static Singleton getInstance() {
								return instance;
							}							
						}
					优点缺点：写法简单，类装载时完成实例化，避免线程同步问题；没有完成lazy loading的效果，如果没用过这个实例，会造成内存浪费；
				    2、饿汉式（静态代码块）：	
					如：public class SingletonTest02 {
							public static void main(String[] args) {
								//测试
								Singleton instance1 = Singleton.getInstance();
								Singleton instance2 = Singleton.getInstance();
								System.out.println(instance1 == instance2); // true
								System.out.println("instance1.hashCode=" + instance1.hashCode());
								System.out.println("instance2.hashCode=" + instance2.hashCode());
							}
						}
						//饿汉式(静态代码块)
						class Singleton {							
							//1. 构造器私有化, 外部能new
							private Singleton() {								
							}							
							//2.本类内部创建对象实例
							private  static Singleton instance;							
							static { // 在静态代码块中，创建单例对象
								instance = new Singleton();
							}							
							//3. 提供一个公有的静态方法，返回实例对象
							public static Singleton getInstance() {
								return instance;
							}
						}
					优点缺点：同饿汉式（静态变量）；
					3、懒汉式（线程不安全）：
					如：public class SingletonTest03 {
							public static void main(String[] args) {
								System.out.println("懒汉式1 ， 线程不安全~");
								Singleton instance1 = Singleton.getInstance();
								Singleton instance2 = Singleton.getInstance();
								System.out.println(instance1 == instance2); // true
								System.out.println("instance1.hashCode=" + instance1.hashCode());
								System.out.println("instance2.hashCode=" + instance2.hashCode());
							}
						}
						class Singleton {
							private static Singleton instance;							
							private Singleton() {}							
							//提供一个静态的公有方法，当使用到该方法时，才去创建 instance，即懒汉式
							public static Singleton getInstance() {
								if(instance == null) {
									instance = new Singleton();
								}
								return instance;
							}
						}
					优点缺点：单线程下起到lazy loading的效果，多线程下线程不安全，不推荐使用；
					4、懒汉式（线程安全，同步方法）：
					如：public class SingletonTest04 {
							public static void main(String[] args) {
								System.out.println("懒汉式2 ， 线程安全~");
								Singleton instance1 = Singleton.getInstance();
								Singleton instance2 = Singleton.getInstance();
								System.out.println(instance1 == instance2); // true
								System.out.println("instance1.hashCode=" + instance1.hashCode());
								System.out.println("instance2.hashCode=" + instance2.hashCode());
							}
						}
						// 懒汉式(线程安全，同步方法)
						class Singleton {
							private static Singleton instance;							
							private Singleton() {}							
							//提供一个静态的公有方法，加入同步处理的代码，解决线程安全问题
							public static synchronized Singleton getInstance() {
								if(instance == null) {
									instance = new Singleton();
								}
								return instance;
							}
						}
					优点缺点：解决线程安全问题，但synchronized关键字的使用效率太低，不推荐使用；
					5、懒汉式（线程安全，同步代码块）：
					如：
					// 懒汉式(线程安全，同步代码块)
						class Singleton {
							private static Singleton instance;							
							private Singleton() {}							
							//提供一个静态的公有方法
							public static Singleton getInstance() {
								//加入同步代码块
								if(instance == null) {
									synchronized(Singleton.class){
										instance = new Singleton();
									}
								}
								return instance;
							}
						}
					优点缺点：不能解决线程安全问题，可能会出现多个实例，不推荐使用；
					6、双重检查：[推荐使用]
					如：public class SingletonTest06 {
							public static void main(String[] args) {
								System.out.println("双重检查");
								Singleton instance1 = Singleton.getInstance();
								Singleton instance2 = Singleton.getInstance();
								System.out.println(instance1 == instance2); // true
								System.out.println("instance1.hashCode=" + instance1.hashCode());
								System.out.println("instance2.hashCode=" + instance2.hashCode());								
							}
						}
						class Singleton {
							private static volatile Singleton instance;//volatile变量可以立即刷新到主存						
							private Singleton() {}						
							//提供一个静态的公有方法，加入双重检查代码							
							public static synchronized Singleton getInstance() {
								if(instance == null) {
									synchronized (Singleton.class) {
										if(instance == null) {
											instance = new Singleton();
										}
									}									
								}
								return instance;
							}
						}
					优点缺点：解决线程安全问题, 同时解决懒加载问题；同时保证了效率, 推荐使用；
					7、静态内部类：[推荐使用]
					如：public class SingletonTest07 {
							public static void main(String[] args) {
								System.out.println("使用静态内部类完成单例模式");
								Singleton instance1 = Singleton.getInstance();
								Singleton instance2 = Singleton.getInstance();
								System.out.println(instance1 == instance2); // true
								System.out.println("instance1.hashCode=" + instance1.hashCode());
								System.out.println("instance2.hashCode=" + instance2.hashCode());								
								}
							}
							// 静态内部类完成， 推荐使用
							class Singleton {
							//构造器私有化
							private Singleton() {}
							//写一个静态内部类,该类中有一个静态属性 Singleton
							private static class SingletonInstance {
							//final在JVM底层可以得到优化
								private static final Singleton INSTANCE = new Singleton(); 
							}
							//提供一个静态的公有方法，直接返回SingletonInstance.INSTANCE
							public static synchronized Singleton getInstance() {//调用时才会类装载SingletonInstance，保证线程安全问题，此时别的线程无法进入；								
								return SingletonInstance.INSTANCE;
								}
							}
					优点缺点：采用类加载机制保证线程安全问题, 同时解决懒加载[延迟加载]问题；同时保证了效率, 推荐使用；
					8、枚举：[推荐使用]
					如：public class SingletonTest08 {
							public static void main(String[] args) {
								Singleton instance1 = Singleton.INSTANCE;
								Singleton instance2 = Singleton.INSTANCE;
								System.out.println(instance1 == instance2);								
								System.out.println(instance1.hashCode());
								System.out.println(instance2.hashCode());							
								instance.sayOK();
							}
						}
						//使用枚举，可以实现单例, 推荐
						enum Singleton {
							INSTANCE; //属性
							public void sayOK() {
								System.out.println("ok~");
							}
						}
					优点缺点：保证线程安全, 同时防止反序列化创建对象，推荐使用；
					JDK1.5运用：java.lang.Runtime类使用单例模式[饿汉式]；
					注意事项：
						保证系统内存只有一个对象，节约资源；通过静态方法获取对象；使用场景：频繁创建销毁的对象，重量级对象[消耗资源过多]，
						工具类、文件类、数据库类对象[session工厂、数据源]等；				
				工厂模式：
					1、简单工厂模式[静态工厂模式]：由一个工厂对象决定创建哪一种产品类的实例；定义一个创建对象的类[工厂类]，由这个类来封装实例化对象的行为；
					如：披萨订购示例：
					//抽象类
					public abstract class Pizza {
						protected String name; //名字						
						public abstract void prepare();	//准备原材料, 不同的披萨不一样，因此，我们做成抽象方法				
						public void bake() {
							System.out.println(name + " baking;");
						}
						public void cut() {
							System.out.println(name + " cutting;");
						}
						//打包
						public void box() {
							System.out.println(name + " boxing;");
						}
						public void setName(String name) {
							this.name = name;
						}
					}
					//实现类
					public class CheesePizza extends Pizza {
						@Override
						public void prepare() {
							System.out.println(" 给制作奶酪披萨 准备原材料 ");
						}
					}
					public class GreekPizza extends Pizza {
						@Override
						public void prepare() {
							System.out.println(" 给希腊披萨 准备原材料 ");
						}
					}
					public class PepperPizza extends Pizza {
						@Override
						public void prepare() {
							System.out.println(" 给胡椒披萨准备原材料 ");
						}
					}
					//订单[使用者]
					public class OrderPizza1 {
						//  传统方法：
						//  构造器
						public OrderPizza1() {
							Pizza pizza = null;
							String orderType; // 订购披萨的类型
							do {
								orderType = getType();
								if (orderType.equals("greek")) {
									pizza = new GreekPizza();
									pizza.setName(" 希腊披萨 ");
								} else if (orderType.equals("cheese")) {
									pizza = new CheesePizza();
									pizza.setName(" 奶酪披萨 ");
								} else if (orderType.equals("pepper")) {
									pizza = new PepperPizza();
									pizza.setName("胡椒披萨");
								} else {
									break;
								}
								//输出pizza制作过程
								pizza.prepare();
								pizza.bake();
								pizza.cut();
								pizza.box();								
							} while (true);
						}
						//定义一个简单工厂对象
						SimpleFactory simpleFactory;
						Pizza pizza = null;						
						//构造器
						public OrderPizza1(SimpleFactory simpleFactory) {
							setFactory(simpleFactory);
						}
						//利用UML类图的聚合关系
						public void setFactory(SimpleFactory simpleFactory) {
							String orderType = ""; //用户输入的							
							this.simpleFactory = simpleFactory; //设置简单工厂对象							
							do {
								orderType = getType(); 
								pizza = this.simpleFactory.createPizza1(orderType);	//接收实例化对象						
								//输出pizza
								if(pizza != null) { //订购成功
									pizza.prepare();
									pizza.bake();
									pizza.cut();
									pizza.box();
								} else {
									System.out.println(" 订购披萨失败 ");
									break;
								}
							}while(true);
						}						
						// 写一个方法，可以获取客户希望订购的披萨种类
						private String getType() {
							try {
								BufferedReader strin = new BufferedReader(new InputStreamReader(System.in));
								System.out.println("input pizza 种类:");
								String str = strin.readLine();
								return str;
							} catch (IOException e) {
								e.printStackTrace();
								return "";
							}
						}
					}
					//订单[使用者]
					public class OrderPizza2 {
						Pizza pizza = null;
						String orderType = "";
						// 构造器
						public OrderPizza2() {							
							do {
								orderType = getType();
								pizza = SimpleFactory.createPizza2(orderType);//调用静态工厂方法
								// 输出pizza
								if (pizza != null) { // 订购成功
									pizza.prepare();
									pizza.bake();
									pizza.cut();
									pizza.box();
								} else {
									System.out.println(" 订购披萨失败 ");
									break;
								}
							} while (true);
						}
						// 写一个方法，可以获取客户希望订购的披萨种类
						private String getType() {
							try {
								BufferedReader strin = new BufferedReader(new InputStreamReader(System.in));
								System.out.println("input pizza 种类:");
								String str = strin.readLine();
								return str;
							} catch (IOException e) {
								e.printStackTrace();
								return "";
							}
						}
					}
					//简单工厂类
					public class SimpleFactory {
						//添加orderType返回对应的Pizza对象，实例化过程交给工厂
						public Pizza createPizza1(String orderType) {
							Pizza pizza = null;
							System.out.println("使用简单工厂模式");
							if (orderType.equals("greek")) {
								pizza = new GreekPizza();
								pizza.setName(" 希腊披萨 ");
							} else if (orderType.equals("cheese")) {
								pizza = new CheesePizza();
								pizza.setName(" 奶酪披萨 ");
							} else if (orderType.equals("pepper")) {
								pizza = new PepperPizza();
								pizza.setName("胡椒披萨");
							}
							
							return pizza;
						}						
						//简单工厂模式也叫静态工厂模式 						
						public static Pizza createPizza2(String orderType) {
							Pizza pizza = null;
							System.out.println("使用简单工厂模式");
							if (orderType.equals("greek")) {
								pizza = new GreekPizza();
								pizza.setName(" 希腊披萨 ");
							} else if (orderType.equals("cheese")) {
								pizza = new CheesePizza();
								pizza.setName(" 奶酪披萨 ");
							} else if (orderType.equals("pepper")) {
								pizza = new PepperPizza();
								pizza.setName("胡椒披萨");
							}							
							return pizza;
						}
					}
					//客户端，发出订购
					public class PizzaStore {
						public static void main(String[] args) {
							//传统方式
							//new OrderPizza1();							
							//使用简单工厂模式
							//new OrderPizza1(new SimpleFactory());
							//System.out.println("~~退出程序~~");							
							new OrderPizza2();
						}
					}
					结论：当出现一种新的披萨类型只需修改工厂方法，其他地方都不需要改动；
					2、工厂方法模式：
					   含义：定义创建对象的抽象方法[抽象类]，由子类决定要实例化的类，将对象的实例化推迟到了子类。
					   如：披萨订购示例[添加了地区的概念]：
					   //基础类
					   public abstract class Pizza {
							protected String name; //名字
							//准备原材料, 不同的披萨不一样，因此，我们做成抽象方法
							public abstract void prepare();							
							public void bake() {
								System.out.println(name + " baking;");
							}
							public void cut() {
								System.out.println(name + " cutting;");
							}
							//打包
							public void box() {
								System.out.println(name + " boxing;");
							}
							public void setName(String name) {
								this.name = name;
							}
						}
					   public class BJCheesePizza extends Pizza {
							@Override
							public void prepare() {
								setName("北京的奶酪pizza");
								System.out.println(" 北京的奶酪pizza 准备原材料");
							}
						}
					   public class BJPepperPizza extends Pizza {
							@Override
							public void prepare() {
								setName("北京的胡椒pizza");
								System.out.println(" 北京的胡椒pizza 准备原材料");
							}
						}
					   public class LDCheesePizza extends Pizza{
							@Override
							public void prepare() {
								setName("伦敦的奶酪pizza");
								System.out.println(" 伦敦的奶酪pizza 准备原材料");
							}
						}
					   public class LDPepperPizza extends Pizza{
							@Override
							public void prepare() {
								setName("伦敦的胡椒pizza");
								System.out.println(" 伦敦的胡椒pizza 准备原材料");
							}
						}
					   //使用者
					   public abstract class OrderPizza {
							//定义一个抽象方法，createPizza , 让各个工厂子类自己实现
							abstract Pizza createPizza(String orderType);							
							// 构造器
							public OrderPizza() {
								Pizza pizza = null;
								String orderType; // 订购披萨的类型
								do {
									orderType = getType();
									pizza = createPizza(orderType); //抽象方法，由工厂子类完成
									//输出pizza 制作过程
									pizza.prepare();
									pizza.bake();
									pizza.cut();
									pizza.box();
									
								} while (true);
							}							
							// 写一个方法，可以获取客户希望订购的披萨种类
							private String getType() {
								try {
									BufferedReader strin = new BufferedReader(new InputStreamReader(System.in));
									System.out.println("input pizza 种类:");
									String str = strin.readLine();
									return str;
								} catch (IOException e) {
									e.printStackTrace();
									return "";
								}
							}
						}
					   public class BJOrderPizza extends OrderPizza {//对象的实例化推迟到了子类来实现							
							@Override
							Pizza createPizza(String orderType) {							
								Pizza pizza = null;
								if(orderType.equals("cheese")) {
									pizza = new BJCheesePizza();
								} else if (orderType.equals("pepper")) {
									pizza = new BJPepperPizza();
								}
								return pizza;
							}
						}
					   public class LDOrderPizza extends OrderPizza {							
							@Override
							Pizza createPizza(String orderType) {							
								Pizza pizza = null;
								if(orderType.equals("cheese")) {
									pizza = new LDCheesePizza();
								} else if (orderType.equals("pepper")) {
									pizza = new LDPepperPizza();
								}
								return pizza;
							}
						}
					   //客户端使用
					   public class PizzaStore {
							public static void main(String[] args) {
								String loc = "bj";
								if (loc.equals("bj")) {
									//创建北京口味的各种Pizza
									new BJOrderPizza();
								} else {
									//创建伦敦口味的各种Pizza
									new LDOrderPizza();
								}
							}
						}					   
					3、抽象工厂模式：
					   含义：是简单工厂模式与工厂方法模式的整合，对简单工厂模式的进一步抽象，将工厂分为两层：抽象工厂[是一个接口]和实现的子类工厂[工厂族]。
					   如：披萨订购示例[添加了地区的概念]：
					   //基础类，同工厂方法的基础类
					   //使用者
					    public interface AbsFactory {//一个抽象工厂模式的抽象层(接口)
							//让下面的工厂子类来 具体实现
							public Pizza createPizza(String orderType);
						}
						public class BJFactory implements AbsFactory {//工厂子类
							@Override
							public Pizza createPizza(String orderType) {
								System.out.println("~使用的是抽象工厂模式~");
								Pizza pizza = null;
								if(orderType.equals("cheese")) {
									pizza = new BJCheesePizza();
								} else if (orderType.equals("pepper")){
									pizza = new BJPepperPizza();
								}
								return pizza;
							}
						}
						public class LDFactory implements AbsFactory {
							@Override
							public Pizza createPizza(String orderType) {
								System.out.println("~使用的是抽象工厂模式~");
								Pizza pizza = null;
								if (orderType.equals("cheese")) {
									pizza = new LDCheesePizza();
								} else if (orderType.equals("pepper")) {
									pizza = new LDPepperPizza();
								}
								return pizza;
							}
						}
						public class OrderPizza {//使用者，使用UML类图的聚合关系
							AbsFactory factory;
							// 构造器
							public OrderPizza(AbsFactory factory) {
								setFactory(factory);
							}
							private void setFactory(AbsFactory factory) {
								Pizza pizza = null;
								String orderType = ""; // 用户输入
								this.factory = factory;
								do {
									orderType = getType();
									// factory 可能是北京的工厂子类，也可能是伦敦的工厂子类
									pizza = factory.createPizza(orderType);
									if (pizza != null) { // 订购ok
										pizza.prepare();
										pizza.bake();
										pizza.cut();
										pizza.box();
									} else {
										System.out.println("订购失败");
										break;
									}
								} while (true);
							}
							// 写一个方法，可以获取客户希望订购的披萨种类
							private String getType() {
								try {
									BufferedReader strin = new BufferedReader(new InputStreamReader(System.in));
									System.out.println("input pizza 种类:");
									String str = strin.readLine();
									return str;
								} catch (IOException e) {
									e.printStackTrace();
									return "";
								}
							}
						}
					    //客户端
						public class PizzaStore {
							public static void main(String[] args) {
								//new OrderPizza(new BJFactory());
								new OrderPizza(new LDFactory());
							}
						}
					源码分析：
					JDK中Calendar类使用到了简单工厂模式
					小结：将实例化对象的代码抽取出来，放在一个类[工厂类]中统一维护与管理，以达到与主项目的解耦，增加扩展性；
						  设计模式的依赖抽象原则；创建对象实例的时候，new的动作放在工厂类的方法中；继承抽象类或实现接口；不要覆盖基类已经实现的方法；				
				原型模式：[Prototype模式]
					含义：用原型实例指定创建对象，通过拷贝原型来创建新的对象。核心：对象.clone()；
					UML类图解析：
						Prototype：原型类，声明克隆接口
						ConcretePrototype：具体的原型类，实现克隆操作
						Client：原型类，让原型对象实例克隆自己，从而创建新的对象（属性一样）
					如[克隆羊问题]：public class Sheep implements Cloneable {//实现Cloneable接口
									private String name;
									private int age;
									private String color;
									private String address = "蒙古羊";//默认属性
									public Sheep friend; //是对象, 克隆是会如何处理
									public Sheep(String name, int age, String color) {
										super();
										this.name = name;
										this.age = age;
										this.color = color;
									}
									public String getName() {
										return name;
									}
									public void setName(String name) {
										this.name = name;
									}
									public int getAge() {
										return age;
									}
									public void setAge(int age) {
										this.age = age;
									}
									public String getColor() {
										return color;
									}
									public void setColor(String color) {
										this.color = color;
									}																											
									@Override
									public String toString() {
										return "Sheep [name=" + name + ", age=" + age + ", color=" + color + ", address=" + address + "]";
									}
									//克隆该实例，使用默认的clone方法来完成
									@Override
									protected Object clone()  {										
										Sheep sheep = null;
										try {
											sheep = (Sheep)super.clone();
										} catch (Exception e) {
											System.out.println(e.getMessage());
										}
										return sheep;
									}																		
								}
							public class Client {
								public static void main(String[] args) {
									System.out.println("原型模式完成对象的创建");
									Sheep sheep1 = new Sheep("tom", 1, "白色");
									sheep1.friend = new Sheep("jack", 2, "黑色");
									Sheep sheep2 = (Sheep)sheep1.clone(); //克隆
									Sheep sheep3 = (Sheep)sheep1.clone(); //克隆
									Sheep sheep4 = (Sheep)sheep1.clone(); //克隆
									Sheep sheep5 = (Sheep)sheep1.clone(); //克隆									
									System.out.println("sheep2 =" + sheep2 + "sheep2.friend=" + sheep2.friend.hashCode());//结果hashCode值一样，是浅拷贝！
									System.out.println("sheep3 =" + sheep3 + "sheep3.friend=" + sheep3.friend.hashCode());
									System.out.println("sheep4 =" + sheep4 + "sheep4.friend=" + sheep4.friend.hashCode());
									System.out.println("sheep5 =" + sheep5 + "sheep5.friend=" + sheep5.friend.hashCode());
								}
							}
					源码分析：Spring源码中Bean对象的创建；在beans.xml中，<bean id="" class="com.**.bean.Monster" scope="prototype"/>
					浅拷贝与深拷贝[默认是浅拷贝]：
						浅拷贝：成员变量数据类型是基本数据类型，拷贝进行值传递；成员变量数据类型是引用数据类型，拷贝进行址传递[内存地址]；
						深拷贝：整个对象进行拷贝；方式：2种，一种是利用clone()方法，另一种是利用对象序列化的方式；
						如：[深拷贝]
						//基础类
						public class DeepCloneableTarget implements Serializable, Cloneable {//实现Serializable,Cloneable接口					
							private static final long serialVersionUID = 1L;
							private String cloneName;//属性名
							private String cloneClass;
							//构造器
							public DeepCloneableTarget(String cloneName, String cloneClass) {
								this.cloneName = cloneName;
								this.cloneClass = cloneClass;
							}
							//因为该类的属性，都是String，因此我们这里使用默认的clone完成即可
							@Override
							protected Object clone() throws CloneNotSupportedException {
								return super.clone();
							}
						}
						public class DeepProtoType implements Serializable, Cloneable{							
							public String name; //String 属性
							public DeepCloneableTarget deepCloneableTarget;//引用类型，对象
							public DeepProtoType() {
								super();
							}														
							//深拷贝 - 方式 1 使用clone 方法
							@Override
							protected Object clone() throws CloneNotSupportedException {								
								Object deep = null;
								//这里完成对基本数据类型(属性)和String的克隆
								deep = super.clone(); 
								//对引用类型的属性，进行单独处理
								DeepProtoType deepProtoType = (DeepProtoType)deep;
								deepProtoType.deepCloneableTarget  = (DeepCloneableTarget)deepCloneableTarget.clone();								
								return deepProtoType;
							}							
							//深拷贝 - 方式2 通过对象的序列化实现 (推荐)							
							public Object deepClone() {								
								//创建流对象
								ByteArrayOutputStream bos = null;
								ObjectOutputStream oos = null;
								ByteArrayInputStream bis = null;
								ObjectInputStream ois = null;								
								try {									
									//序列化
									bos = new ByteArrayOutputStream();
									oos = new ObjectOutputStream(bos);//将字节数组输出流转化为对象输出流
									oos.writeObject(this); //当前这个对象以对象流的方式输出									
									//反序列化，出[写]->入[读]
									bis = new ByteArrayInputStream(bos.toByteArray());
									ois = new ObjectInputStream(bis);
									DeepProtoType copyObj = (DeepProtoType)ois.readObject();									
									return copyObj;									
								} catch (Exception e1) {
									e.printStackTrace(e1.getMessage());
									return null;
								} finally {
									//关闭流
									try {
										bos.close();
										oos.close();
										bis.close();
										ois.close();
									} catch (Exception e2) {
										System.out.println(e2.getMessage());
									}
								}								
							}							
						}
						//客户端
						public class Client {
							public static void main(String[] args) throws Exception {
								DeepProtoType p1 = new DeepProtoType();
								p1.name = "宋江";
								p1.deepCloneableTarget = new DeepCloneableTarget("大牛", "小牛");							
								//方式1 完成深拷贝								
						//		DeepProtoType p2 = (DeepProtoType) p1.clone();	
						//		System.out.println("p1.name=" + p1.name + "p1.deepCloneableTarget=" + p1.deepCloneableTarget.hashCode());//结果，属性值相同，hashCode值不同
						//		System.out.println("p2.name=" + p2.name + "p2.deepCloneableTarget=" + p2.deepCloneableTarget.hashCode());							
								//方式2 完成深拷贝
								DeepProtoType p2 = (DeepProtoType) p.deepClone();								
								System.out.println("p1.name=" + p1.name + "p1.deepCloneableTarget=" + p1.deepCloneableTarget.hashCode());
								System.out.println("p2.name=" + p2.name + "p2.deepCloneableTarget=" + p2.deepCloneableTarget.hashCode());							
							}
						}
					小结：简化对象的创建过程，提高效率；动态的获取对象的运行状态；缺点:每一个类必须配备一个克隆方法；
				建造者模式[生产器模式]：
					含义：将产品与产品的建造过程解耦->建造者模式！角色：Product:产品，Builder:抽象建造者，往往是接口或抽象类，展现建造流程，组合Product；ConcreteBuilder：具体建造者，实现接口或继承抽象类，具体实现建造流程，
					      Director：指挥者，聚合Builder，隔离客户与产品对象生产流程，负责控制产品的生产过程；
					如：[盖房子案例]
					//产品->Product
					public class House {
						private String baise;//属性，地基
						private String wall;//墙面
						private String roofed;//屋顶
						public String getBaise() {
							return baise;
						}
						public void setBaise(String baise) {
							this.baise = baise;
						}
						public String getWall() {
							return wall;
						}
						public void setWall(String wall) {
							this.wall = wall;
						}
						public String getRoofed() {
							return roofed;
						}
						public void setRoofed(String roofed) {
							this.roofed = roofed;
						}						
					}
					// 抽象的建造者->Builder
					public abstract class HouseBuilder {
						protected House house = new House();//使用UML类图的组合关系					
						//将建造的流程写好, 抽象的方法，流程与产品解耦分离
						public abstract void buildBasic();
						public abstract void buildWalls();
						public abstract void roofed();						
						//建造房子好，将产品(房子) 返回
						public House buildHouse() {
							return house;
						}						
					}
					//子类继承[泛化过程]，普通房子->ConcreteBuilder
					public class CommonHouse extends HouseBuilder {
						@Override
						public void buildBasic() {
							System.out.println("普通房子打地基5米");
						}
						@Override
						public void buildWalls() {
							System.out.println("普通房子砌墙10cm");
						}
						@Override
						public void roofed() {
							System.out.println("普通房子屋顶");
						}
					}
					//子类继承[泛化过程]，高楼->ConcreteBuilder
					public class HighBuilding extends HouseBuilder {
						@Override
						public void buildBasic() {
							System.out.println("高楼的打地基100米");
						}
						@Override
						public void buildWalls() {
							System.out.println("高楼的砌墙20cm");
						}
						@Override
						public void roofed() {
							System.out.println("高楼的透明屋顶");
						}
					}
					//指挥者->Dirctor，这里去指挥制作流程，返回产品
					public class HouseDirector {						
						HouseBuilder houseBuilder = null;//采用UML类图的聚合关系
						//构造器传入houseBuilder
						public HouseDirector(HouseBuilder houseBuilder) {
							this.houseBuilder = houseBuilder;
						}
						//通过setter 传入 houseBuilder
						public void setHouseBuilder(HouseBuilder houseBuilder) {
							this.houseBuilder = houseBuilder;
						}						
						//如何处理建造房子的流程，交给指挥者
						public House constructHouse() {
							houseBuilder.buildBasic();
							houseBuilder.buildWalls();
							houseBuilder.roofed();
							return houseBuilder.buildHouse();
						}		
					}
					//客户端
					public class Client {
						public static void main(String[] args) {							
							//盖普通房子
							CommonHouse commonHouse = new CommonHouse();
							//准备创建房子的指挥者
							HouseDirector houseDirector = new HouseDirector(commonHouse);							
							//完成盖房子，返回产品(普通房子)
							House house = houseDirector.constructHouse();														
							System.out.println("--------------------------");
							//盖高楼
							HighBuilding highBuilding = new HighBuilding();
							//重置抽象建造者
							houseDirector.setHouseBuilder(highBuilding);
							//完成盖房子，返回产品(高楼)
							houseDirector.constructHouse();																					
						}
					}
					源码分析：JDK中java.lang.StringBuilder中使用到了建造者模式！
				    小结：产品与产品创建过程解耦；每一种具体的建造者相互独立；可以更加细腻的控制产品的建造过程[指挥者]；符合OCP原则；
						  与抽象工厂模式区别：前者强调的是产品组装建造流程，后者强调的是生产出产品；			
			结构型模式[软件结构]：		
				适配器模式：
				含义：将某类的接口转化成客户端期待的另一种接口表示，目的做兼容。目标[Target/dst] <-- 适配器[Adapter] <-- 被适配者[Source/src]
				分类：类适配器模式、对象适配器模式、接口适配器模式
				类适配器模式：
					如：[充电器案例]
					//被适配的类，Source
					public class Voltage220V {
						//输出220V的电压
						public int output220V() {
							int src = 220;
							System.out.println("电压=" + src + "伏");
							return src;
						}
					}
					//适配接口
					public interface IVoltage5V {
						public int output5V();
					}
					//适配器类，Adapter
					public class VoltageAdapter extends Voltage220V implements IVoltage5V {
						@Override
						public int output5V() {
							//获取到220V电压
							int srcV = output220V();
							int dstV = srcV / 44 ; //转成 5v
							return dstV;//Target
						}
					}
					public class Phone {
						//充电，依赖关系
						public void charging(IVoltage5V iVoltage5V) {
							if(iVoltage5V.output5V() == 5) {
								System.out.println("电压为5V, 可以充电~~");
							} else if (iVoltage5V.output5V() > 5) {
								System.out.println("电压大于5V, 不能充电~~");
							}
						}
					}
					//客户端
					public class Client {
						public static void main(String[] args) {
							System.out.println(" === 类适配器模式 ====");
							Phone phone = new Phone();
							phone.charging(new VoltageAdapter());
						}
					}
				优点缺点：adapter继承了src，增加了耦合，暴露了src的方法，增加成本，但同时可以根据需求重写，使灵活性增强。	
				对象配器模式[常用]：
					含义：对类适配器的改进，adapter不在继承了src，而是聚合，使用UML类图的关联关系来代替，符合"合成复用"原则，使得成本降低。
					优化部分：
					//适配器类
					public class VoltageAdapter  implements IVoltage5V {//不在使用继承关系
						private Voltage220V voltage220V; // 关联关系-聚合关系												
						//通过构造器，传入一个 Voltage220V 实例
						public VoltageAdapter(Voltage220V voltage220v) {							
							this.voltage220V = voltage220v;
						}
						@Override
						public int output5V() {							
							int dst = 0;
							if(null != voltage220V) {
								int src = this.voltage220V.output220V();//获取220V 电压
								System.out.println("使用对象适配器，进行适配~~");
								dst = src / 44;
								System.out.println("适配完成，输出的电压为=" + dst);
							}							
							return dst;						
						}
					}
					//客户端
					public class Client {
						public static void main(String[] args) {
							System.out.println(" === 对象适配器模式 ====");
							Phone phone = new Phone();
							phone.charging(new VoltageAdapter(new Voltage220V()));
						}
					}
				接口适配器：
					含义：又称适配器模式或缺省适配器模式，设计一个抽象类实现接口里面的所有方法[默认实现，空方法]，然后该抽象类子类[匿名内部类]有选择性的覆盖某些方法来实现
					如：
					//接口，被适配者->src
					public interface Interface {
						public void m1();
						public void m2();
						public void m3();
						public void m4();
					}
					//抽象类，适配器
					public abstract class AbsAdapter implements Interface {
						//默认实现
						public void m1() {
						}
						public void m2() {
						}
						public void m3() {
						}
						public void m4() {
						}
					}
					//客户端使用
					public class Client {
						public static void main(String[] args) {	
							AbsAdapter absAdapter = new AbsAdapter() {
								//只需要去覆盖需要使用接口方法
								@Override
								public void m1() {
									System.out.println("使用了m1的方法");
								}
							};							
							absAdapter.m1();
						}
					}
					源码分析：在SpringMVC框架中运用到了适配器模式，如：HandleAdapter类；
					//核心思想->src					  
					public interface Controller {//多种Controller实现
					}
					class HttpController implements Controller {
						public void doHttpHandler() {
							System.out.println("http...");
						}
					}
					class SimpleController implements Controller {
						public void doSimplerHandler() {
							System.out.println("simple...");
						}
					}
					class AnnotationController implements Controller {
						public void doAnnotationHandler() {
							System.out.println("annotation...");
						}
					}
					//适配器接口->src	
					public interface HandlerAdapter {
						public boolean supports(Object handler);
						public void handle(Object handler);
					}
					//多种适配器类
					class SimpleHandlerAdapter implements HandlerAdapter {
						public void handle(Object handler) {
							((SimpleController) handler).doSimplerHandler();
						}
						public boolean supports(Object handler) {
							return (handler instanceof SimpleController);
						}
					}
					class HttpHandlerAdapter implements HandlerAdapter {
						public void handle(Object handler) {
							((HttpController) handler).doHttpHandler();
						}
						public boolean supports(Object handler) {
							return (handler instanceof HttpController);
						}
					}
					class AnnotationHandlerAdapter implements HandlerAdapter {
						public void handle(Object handler) {
							((AnnotationController) handler).doAnnotationHandler();
						}
						public boolean supports(Object handler) {
							return (handler instanceof AnnotationController);
						}
					}
					//使用者
					public class DispatchServlet {
						public static List<HandlerAdapter> handlerAdapters = new ArrayList<HandlerAdapter>();//依赖组合关系
						public DispatchServlet() {
							handlerAdapters.add(new AnnotationHandlerAdapter());
							handlerAdapters.add(new HttpHandlerAdapter());
							handlerAdapters.add(new SimpleHandlerAdapter());
						}
						public void doDispatch() {
							// 此处模拟SpringMVC从request取handler的对象，适配器可以获取到希望的Controller
							   HttpController controller = new HttpController();
							// AnnotationController controller = new AnnotationController();
							// SimpleController controller = new SimpleController();
							// 得到对应适配器
							HandlerAdapter adapter = getHandler(controller);
							// 通过适配器执行对应的controller对应方法
							adapter.handle(controller);
						}
						public HandlerAdapter getHandler(Controller controller) {
							//遍历：根据得到的controller(handler), 返回对应适配器
							for (HandlerAdapter adapter : this.handlerAdapters) {
								if (adapter.supports(controller)) {
									return adapter;
								}
							}
							return null;
						}
						public static void main(String[] args) {
							new DispatchServlet().doDispatch(); // http...
						}
					}
					小结：三种适配器根据src以怎样的形式传给Adapter；目的是做接口的兼容；
				桥接模式：
					含义：将抽象[抽象类]与实现[接口和实现类]放在不同的层次中，它是基于类最小设计原则，防止类爆炸；
					原理：
						Client类：调用者，客户端；
						Abstraction抽象类：维护了Implementor/以及实现类；聚合了接口，是调用者与被调用者关系；
						RefinedAbstraction：是Abstraction抽象类子类；
						Implementor：实现类接口；
						ConcreteImplementorA/B：具体实现类；
					如：[手机操作案例]
					//接口
					public interface Brand {//品牌
						void open();//开机
						void close();//关机
						void call();//打电话
					}
					//实现子类
					public class Vivo implements Brand {
						@Override
						public void open() {
							System.out.println("Vivo手机开机");
						}
						@Override
						public void close() {
							System.out.println("Vivo手机关机");
						}
						@Override
						public void call() {
							System.out.println("Vivo手机打电话");
						}
					}
					public class XiaoMi implements Brand {
						@Override
						public void open() {
							System.out.println("小米手机开机");
						}
						@Override
						public void close() {
							System.out.println("小米手机关机");
						}
						@Override
						public void call() {
							System.out.println("小米手机打电话");
						}
					}
					//抽象类
					public abstract class Phone {						
						//利用UML类图聚合关系，组合品牌
						private Brand brand;
						//构造器
						public Phone(Brand brand) {
							super();
							this.brand = brand;
						}					
						protected void open() {
							this.brand.open();
						}
						protected void close() {
							brand.close();
						}
						protected void call() {
							brand.call();
						}						
					}
					//折叠式手机类，继承抽象类Phone
					public class FoldedPhone extends Phone {
						//构造器
						public FoldedPhone(Brand brand) {
							super(brand);
						}						
						public void open() {
							super.open();
							System.out.println("折叠样式手机");
						}						
						public void close() {
							super.close();
							System.out.println("折叠样式手机");
						}						
						public void call() {
							super.call();
							System.out.println("折叠样式手机");
						}
					}
					//直立式手机类，继承抽象类Phone
					public class UpRightPhone extends Phone {					
						//构造器
						public UpRightPhone(Brand brand) {
							super(brand);
						}						
						public void open() {
							super.open();
							System.out.println("直立样式手机");
						}						
						public void close() {
							super.close();
							System.out.println("直立样式手机");
						}						
						public void call() {
							super.call();
							System.out.println("直立样式手机");
						}
					}
					//客户端，依赖Phone与Brand，抽象与实现
					public class Client {
						public static void main(String[] args) {							
							//获取折叠式手机 (样式 + 品牌 )						
							Phone phone1 = new FoldedPhone(new XiaoMi());							
							phone1.open();
							phone1.call();
							phone1.close();							
							System.out.println("=======================");							
							Phone phone2 = new FoldedPhone(new Vivo());							
							phone2.open();
							phone2.call();
							phone2.close();							
							System.out.println("==============");
							//直立式手机 (样式 + 品牌 )	
							UpRightPhone phone3 = new UpRightPhone(new XiaoMi());							
							phone3.open();
							phone3.call();
							phone3.close();							
							System.out.println("==============");							
							UpRightPhone phone4 = new UpRightPhone(new Vivo());							
							phone4.open();
							phone4.call();
							phone4.close();
						}
					}
					源码分析：JDBC源码中使用到了桥接模式：
						其中DriverManger充当的是抽象类的角色，而Connection接口充当的是实现角色[子类/子接口有MysqlConnection、OracleConnection等具体实现子类]；
						客户端直接依赖DriverManger；
					小结：实现了抽象与实现的分离；替代了多层继承问题，增加系统的灵活性；替代了继承，节约成本；缺点：对系统的设计与理解[维度]难度较大；
					应用场景：JDBC驱动，银行转账系统；消息管理等				
				装饰者模式：
					含义：动态的将新功能附加到对象上，比继承更有弹性，符合开闭原则[OCP原则]，防止类爆炸，生活中的物流包裹就是一个典型的生活案列；
					原理：
					   Component ：抽象类
					   ConcreteComponent：子类，继承Component，具体的主体；中间可以适当添加缓冲层；
					   Decorator：装饰者[装饰类]，继承Component，组合Component
					如：[星巴克咖啡订单案例，单品+种类]
						//抽象类，饮料
						public abstract class Drink {
							public String des; // 描述
							private float price = 0.0f;
							public String getDes() {
								return des;
							}
							public void setDes(String des) {
								this.des = des;
							}
							public float getPrice() {
								return price;
							}
							public void setPrice(float price) {
								this.price = price;
							}							
							//计算费用的抽象方法，子类来实现
							public abstract float cost();							
						}
						//缓冲层
						public class Coffee  extends Drink {
							@Override
							public float cost() {
								return super.getPrice();
							}							
						}
						//实现子类
						public class Espresso extends Coffee {							
							public Espresso() {
								setDes("意大利咖啡");
								setPrice(6.0f);
							}
						}
						public class LongBlack extends Coffee {
							public LongBlack() {
								setDes("longblack");
								setPrice(5.0f);
							}
						}
						public class ShortBlack extends Coffee{						
							public ShortBlack() {
								setDes("shortblack");
								setPrice(4.0f);
							}
						}
						public class DeCaf extends Coffee {
							public DeCaf() {
								setDes("无因咖啡");
								setPrice(1.0f);
							}
						}
						//装饰类（种类），继承+聚合
						public class Decorator extends Drink {
							private Drink obj;							
							public Decorator(Drink obj) { //聚合
								this.obj = obj;
							}							
							@Override
							public float cost() {
								// getPrice 自己价格
								return super.getPrice() + obj.cost();
							}							
							@Override
							public String getDes() {
								// obj.getDes() 输出被装饰者的信息
								return des + " " + getPrice() + " && " + obj.getDes();
							}														
						}
						//子类
						public class Chocolate extends Decorator {
							public Chocolate(Drink obj) {
								super(obj);
								setDes("巧克力");
								setPrice(3.0f); // 调味品的价格
							}
						}
						public class Milk extends Decorator {
							public Milk(Drink obj) {
								super(obj);
								setDes("牛奶");
								setPrice(2.0f); 
							}
						}
						public class Soy extends Decorator{
							public Soy(Drink obj) {
								super(obj);
								setDes("豆浆");
								setPrice(1.5f);
							}
						}
						//客户端
						public class CoffeeBar {
							public static void main(String[] args) {
								// 装饰者模式下的订单：2份巧克力+一份牛奶的LongBlack
								// 1. 点一份 LongBlack
								Drink order1 = new LongBlack();
								System.out.println("费用=" + order1.cost());
								System.out.println("描述=" + order1.getDes());
								// 2. order 加入一份牛奶，装饰迭代
								order1 = new Milk(order1);
								System.out.println("order1 加入一份牛奶 费用 =" + order1.cost());
								System.out.println("order1 加入一份牛奶 描述 =" + order1.getDes());
								// 3. order 加入一份巧克力，装饰迭代
								order1 = new Chocolate(order1);
								System.out.println("order1 加入一份牛奶 加入一份巧克力 费用 =" + order1.cost());
								System.out.println("order1 加入一份牛奶 加入一份巧克力 描述 =" + order1.getDes());
								// 3. order 加入一份巧克力，装饰迭代
								order1 = new Chocolate(order1);
								System.out.println("order1 加入一份牛奶 加入2份巧克力 费用 =" + order1.cost());
								System.out.println("order1 加入一份牛奶 加入2份巧克力 描述 =" + order1.getDes());							
								System.out.println("===========================");								
								Drink order2 = new DeCaf();								
								System.out.println("order2 无因咖啡 费用 =" + order2.cost());
								System.out.println("order2 无因咖啡 描述 =" + order2.getDes());								
								order2 = new Milk(order2);								
								System.out.println("order2 无因咖啡 加入一份牛奶 费用 =" + order2.cost());
								System.out.println("order2 无因咖啡 加入一份牛奶 描述 =" + order2.getDes());							
							}
						}
					源码分析：
						JDK中IO结构，FilterInputStream就是一个装饰者而InputStream就是一个被装饰者[抽象类]；FileInputStream是被装饰者的一个子类，DataInputStream是装饰者的一个子类；						
				组合模式：
					含义：部分与整体模式，用树型结构来表示对象与对象组的关系
					原理：
						Component：抽象层，可是接口或抽象类，实现所有类共有的接口默认行为[添加、删除、修改等]，用于访问管理Component的子部件；
						Leaf：叶子节点，下面没有子节点；
						Composite：组合Component，非叶子节点，用于存储子部件，实现Component接口的相关操作，比如：添加、删除等；
					适用场景：组织结构[树形结构]
					如：[学校院系展示案例]
						//抽象层，抽象类
						public abstract class OrganizationComponent {
							private String name; //名字
							private String des; //说明							
							protected  void add(OrganizationComponent organizationComponent) {
								//默认实现
								throw new UnsupportedOperationException();
							}							
							protected  void remove(OrganizationComponent organizationComponent) {
								//默认实现
								throw new UnsupportedOperationException();
							}
							//构造器
							public OrganizationComponent(String name, String des) {
								super();
								this.name = name;
								this.des = des;
							}
							public String getName() {
								return name;
							}
							public void setName(String name) {
								this.name = name;
							}
							public String getDes() {
								return des;
							}
							public void setDes(String des) {
								this.des = des;
							}						
							//方法print，做成抽象的，子类都需要实现
							protected abstract void print();														
						}
						//University就是Composite，可以管理College，即大学管理学院
						public class University extends OrganizationComponent {
							List<OrganizationComponent> organizationComponents = new ArrayList<OrganizationComponent>();//组合OrganizationComponent
							// 构造器
							public University(String name, String des) {
								super(name, des);
							}
							// 重写add
							@Override
							protected void add(OrganizationComponent organizationComponent) {
								organizationComponents.add(organizationComponent);
							}
							// 重写remove
							@Override
							protected void remove(OrganizationComponent organizationComponent) {
								organizationComponents.remove(organizationComponent);
							}
							@Override
							public String getName() {
								return super.getName();
							}

							@Override
							public String getDes() {
								return super.getDes();
							}
							// print方法，就是输出University包含的学院
							@Override
							protected void print() {
								System.out.println("--------------" + getName() + "--------------");
								//遍历organizationComponents 
								for (OrganizationComponent organizationComponent : organizationComponents) {
									organizationComponent.print();
								}
							}
						}
						//学院，管理系[专业]
						public class College extends OrganizationComponent {
							//List中存放的Department
							List<OrganizationComponent> organizationComponents = new ArrayList<OrganizationComponent>();
							// 构造器
							public College(String name, String des) {
								super(name, des);
							}
							// 重写add
							@Override
							protected void add(OrganizationComponent organizationComponent) {
								//将来实际业务中，Colleage的add 和University的add不一定完全一样
								organizationComponents.add(organizationComponent);
							}
							// 重写remove
							@Override
							protected void remove(OrganizationComponent organizationComponent) {
								organizationComponents.remove(organizationComponent);
							}
							@Override
							public String getName() {
								return super.getName();
							}
							@Override
							public String getDes() {
								return super.getDes();
							}
							// print方法，就是输出College包含的系
							@Override
							protected void print() {
								System.out.println("--------------" + getName() + "--------------");
								//遍历 organizationComponents 
								for (OrganizationComponent organizationComponent : organizationComponents) {
									organizationComponent.print();
								}
							}
						}
						//系或专业，子节点->Leaf
						public class Department extends OrganizationComponent {
							//没有集合						
							public Department(String name, String des) {
								super(name, des);
							}						
							//add,remove 就不用写了，因为是叶子节点，没有子节点							
							@Override
							public String getName() {
								return super.getName();
							}							
							@Override
							public String getDes() {
								return super.getDes();
							}							
							@Override
							protected void print() {
								System.out.println(getName());
							}
						}
						//客户端
						public class Client {
							public static void main(String[] args) {								
								//从大到小创建对象，创建学校
								OrganizationComponent university = new University("清华大学", "中国顶级大学");								
								//创建学院
								OrganizationComponent computerCollege = new College("计算机学院", "计算机学院");
								OrganizationComponent infoEngineercollege = new College("信息工程学院", "信息工程学院");																
								//创建各个学院下面的系(专业)
								computerCollege.add(new Department("软件工程", "软件工程不错"));
								computerCollege.add(new Department("网络工程", "网络工程不错"));
								computerCollege.add(new Department("计算机科学与技术", "计算机科学与技术是老牌的专业"));								
								infoEngineercollege.add(new Department("通信工程", " 通信工程不好学 "));
								infoEngineercollege.add(new Department("信息工程", " 信息工程好学 "));							
								//将学院加入到学校
								university.add(computerCollege);
								university.add(infoEngineercollege);								
								//university.print();//大学下所有树形结构
								infoEngineercollege.print();//信息工程学院下树形结构
							}
						}
					源码分析：
						JDK集合类源码分析：Java的集合类-HashMap就适用了组合模式；Map：抽象层，接口[角色:Component]，定义了put/putAll方法，
							HashMap：具体的实现，非叶子节点[角色:Composite]，重写或继承了put/putAll方法，Node: 叶子节点，是HashMap静态内部类，角色Leaf;
					小结：适用于具有明确的组织结构或树形结构的场景，且叶子节点与非叶子节点属性没有明显的差异性；优点：简化客户端操作，有利于扩展；
				外观模式/过程模式：
					含义：定义一个一致性接口（界面类/高层接口），用于屏蔽内部子系统的细节，使调用端只跟这个高层接口发生调用，不需要关系子系统内部的细节；
					原理/角色：
						外观类[Facade]：为调用者提供统一的接口（方法），聚合/组合子系统集合，代理处理请求；
						调用者：外观接口的调用者；
						子系统集合：模块或子系统，处理Facade对象的任务，它是实际功能的提供者；
				    如：[家庭影院案例]
					//子系统集合之DVD播放器
					public class DVDPlayer {					
						//使用单例模式, 使用饿汉式
						private static DVDPlayer instance = new DVDPlayer();					
						public static DVDPlayer getInstanc() {
							return instance;
						}
						//开机
						public void on() {
							System.out.println(" dvd on ");
						}
						//关机
						public void off() {
							System.out.println(" dvd off ");
						}
						//正在播放
						public void play() {
							System.out.println(" dvd is playing ");
						}					
						//暂停播放
						public void pause() {
							System.out.println(" dvd pause ..");
						}
					}
					//子系统集合之爆米花机
					public class Popcorn {						
						private static Popcorn instance = new Popcorn();						
						public static Popcorn getInstance() {
							return instance;
						}
						//开机
						public void on() {
							System.out.println(" popcorn on ");
						}
						//关机
						public void off() {
							System.out.println(" popcorn ff ");
						}
						//出爆米花
						public void pop() {
							System.out.println(" popcorn is poping  ");
						}
					}
					//子系统集合之投影仪
					public class Projector {
						private static Projector instance = new Projector();						
						public static Projector getInstance() {
							return instance;
						}
						//开机
						public void on() {
							System.out.println(" Projector on ");
						}
						//关机
						public void off() {
							System.out.println(" Projector ff ");
						}
						//聚焦
						public void focus() {
							System.out.println(" Projector is Projector  ");
						}
					}
					//子系统集合之大屏
					public class Screen {
						private static Screen instance = new Screen();						
						public static Screen getInstance() {
							return instance;
						}																		
						//大屏上升
						public void up() {
							System.out.println(" Screen up ");
						}
						//大屏降下
						public void down() {
							System.out.println(" Screen down ");
						}						
					}
					//子系统集合之立体声
					public class Stereo {
						private static Stereo instance = new Stereo();						
						public static Stereo getInstance() {
							return instance;
						}
						//打开声音
						public void on() {
							System.out.println(" Stereo on ");
						}
						//关闭声音
						public void off() {
							System.out.println(" Screen off ");
						}
						//声音调高
						public void up() {
							System.out.println(" Screen up.. ");
						}
					}
					//子系统集合之灯光
					public class TheaterLight {
						private static TheaterLight instance = new TheaterLight();
						public static TheaterLight getInstance() {
							return instance;
						}
						//打开灯光
						public void on() {
							System.out.println(" TheaterLight on ");
						}
						//关闭灯光
						public void off() {
							System.out.println(" TheaterLight off ");
						}
						//调暗
						public void dim() {
							System.out.println(" TheaterLight dim.. ");
						}
						//调亮
						public void bright() {
							System.out.println(" TheaterLight bright.. ");
						}
					}
					//高层接口或界面类、外观类
					public class HomeTheaterFacade {						
						//定义各个子系统对象
						private TheaterLight theaterLight;
						private Popcorn popcorn;
						private Stereo stereo;
						private Projector projector;
						private Screen screen;
						private DVDPlayer dVDPlayer;												
						//构造器
						public HomeTheaterFacade() {
							super();
							this.theaterLight = TheaterLight.getInstance();
							this.popcorn = Popcorn.getInstance();
							this.stereo = Stereo.getInstance();
							this.projector = Projector.getInstance();
							this.screen = Screen.getInstance();
							this.dVDPlayer = DVDPlayer.getInstanc();
						}
						//操作分成4步，准备						
						public void ready() {
							popcorn.on();
							popcorn.pop();
							screen.down();
							projector.on();
							stereo.on();
							dVDPlayer.on();
							theaterLight.dim();
						}
						//开启
						public void play() {
							dVDPlayer.play();
						}
						//暂停
						public void pause() {
							dVDPlayer.pause();
						}
						//关闭
						public void end() {
							popcorn.off();
							theaterLight.bright();
							screen.up();
							projector.off();
							stereo.off();
							dVDPlayer.off();
						}
					}
					//客户端
					public class Client {
						public static void main(String[] args) {
							HomeTheaterFacade homeTheaterFacade = new HomeTheaterFacade();
							homeTheaterFacade.ready();
							homeTheaterFacade.play();														
							homeTheaterFacade.end();
						}
					}
				源码分析：
					Mybaits中的Configuration类用到了外观模式；
					大致实现思路：Configuration类外观类依赖MetaObject类[方法：newMetaObject():MetaObject]，组合/聚合了子系统集合[工厂类]，如：DefultObjectFactory，客户端只依赖Configuration外观类；
				小结：
				        屏蔽内部子系统的细节，降低客户端对子系统使用的复杂性；将客户端与子系统解耦；更好的划分访问层次；
			享元模式/蝇量模式：共享对象/数据
				含义：运用共享技术有效的支持大量细粒度的对象，常用于系统底层开发，解决系统性能问题；它可以解决内存浪费问题；经典运用场景就是池技术，如常量池、数据库连接池、缓冲池等；
				角色分析：
					FlyWeight：抽象的享元角色，是产品抽象类，它定义出了对象的外部状态[对象不可分享出来的信息]与内部状态[对象分享出来的信息]的接口或抽象类；
					ConcreteFlyWeight：具体的享元角色，具体的产品类；
					UnSharedConcreteFlyWeight：不可共享的角色，一般不会出现在享元工厂里；
					FlyWeightFactory：享元工厂类，用于构建池容器（集合），同时提供了从池中获取对象的方法；依赖FlyWeight享元角色；
				如：[网站展现案例，网站外包问题]
				//FlyWeight： 抽象类，享元角色；
				public abstract class WebSite {
					public abstract void use(User user);//抽象方法
				}
				//
				//ConcreteFlyWeight：具体的享元角色，具体网站；
				public class ConcreteWebSite extends WebSite {
					//共享的部分，内部状态
					private String type = ""; //网站发布的形式(类型，如：新闻、博客、公众号)					
					//构造器
					public ConcreteWebSite(String type) {							
						this.type = type;
					}
					@Override
					public void use(User user) {
						System.out.println("网站的发布形式为:" + type + " 在使用中 .. 使用者是" + user.getName());
					}												
				}
				// FlyWeightFactory：享元工厂类，根据需要返回一个网站，提供池技术
				public class WebSiteFactory {						
					//集合， 充当池的作用
					private HashMap<String, ConcreteWebSite> pool = new HashMap<>();						
					//根据网站的类型，返回一个网站, 如果没有就创建一个网站，并放入到池中,并返回
					public WebSite getWebSiteCategory(String type) {
						if(!pool.containsKey(type)) {
							//就创建一个网站，并放入到池中
							pool.put(type, new ConcreteWebSite(type));
						}							
						return (WebSite)pool.get(type);
					}						
					//获取网站分类的总数 (池中有多少个网站类型)
					public int getWebSiteCount() {
						return pool.size();
					}
				}
				//用户
				public class User {						
					private String name;						
					public User(String name) {
						super();
						this.name = name;
					}
					public String getName() {
						return name;
					}
					public void setName(String name) {
						this.name = name;
					}											
				}
				//客户端
				public class Client {
					public static void main(String[] args) {
						// 创建一个工厂类
						WebSiteFactory factory = new WebSiteFactory();
						// 客户要一个以新闻形式发布的网站
						WebSite webSite1 = factory.getWebSiteCategory("新闻");							
						webSite1.use(new User("tom"));
						// 客户要一个以博客形式发布的网站
						WebSite webSite2 = factory.getWebSiteCategory("博客");
						webSite2.use(new User("jack"));
						// 客户要一个以博客形式发布的网站
						WebSite webSite3 = factory.getWebSiteCategory("博客");
						webSite3.use(new User("smith"));
						// 客户要一个以博客形式发布的网站
						WebSite webSite4 = factory.getWebSiteCategory("博客");
						webSite4.use(new User("king"));							
						System.out.println("网站的分类共=" + factory.getWebSiteCount());
					}
				}
				源码分析：
					JDK中的Integer类使用到了享元模式；Integer.valueOf（），使用到了享元模式；
					观察源码发现：先判断值是否在IntegerCache缓存池中[范围-128~127]，在的话直接从池中取值，否则使用new Integer（），结论：在-128~127中使用valueOf（）的方式要比new的方式要快；
				小结：享元即共享对象，降低了对象的创建，减少了内存的消耗；缓存池技术的使用，一般使用HashMap或HashTable来存储；提高了系统的复杂度，需要区分内部状态与外部状态；				
			代理模式：
				含义：为目标对象提供一个替身，以实现对这个目标对象的访问；即代理对象访问目标对象；
					  被代理对象可以是远程对象、创建开销大的对象和需要安全控制的对象，代理的形式：静态代理、动态代理（JDK代理、接口代理）以及Cglib代理（可以在内存中动态的创建对象，不需要实现接口，属于动态代理）
				静态代理：
					含义：需要定义一个接口或父类，目标对象与代理对象一起实现接口或继承父类；
					如：[老师授课案例]
					//接口
					public interface ITeacherDao {							
						void teach(); // 授课的方法
					}
					//目标对象
					public class TeacherDao implements ITeacherDao {
						@Override
						public void teach() {
							System.out.println("老师授课中  。。。。。");
						}
					}
					//代理对象，静态代理
					public class TeacherDaoProxy implements ITeacherDao{							
						private ITeacherDao target; // 目标对象，通过接口来聚合														
						//构造器
						public TeacherDaoProxy(ITeacherDao target) {
							this.target = target;
						}
						@Override
						public void teach() {
							System.out.println("开始代理，完成某些操作。。。。。 ");//方法
							target.teach();
							System.out.println("提交。。。。。");//方法
						}
					}
					//客户端
					public class Client {
						public static void main(String[] args) {
							//创建目标对象(被代理对象)
							TeacherDao teacherDao = new TeacherDao();								
							//创建代理对象, 同时将被代理对象传递给代理对象
							TeacherDaoProxy teacherDaoProxy = new TeacherDaoProxy(teacherDao);								
							//通过代理对象，调用到被代理对象的方法，即：执行的是代理对象的方法，代理对象再去调用目标对象的方法 
							teacherDaoProxy.teach();
						}
					}
					优缺点：在不改变目标对象功能前提下，通过代理对目标功能进行了扩展；一旦接口增加了方法，目标对象与代理对象都要维护；
				动态代理：
					含义：
					
----------------------------------------------Java高级运用技术篇之Java8新特性--------------------------------------------------------------------------------------------------------------------------------
	一、初识Lambda表达式		
		示例：
			#匿名内部类形式，比较字符串长度
			@Test
			public void test1(){
				Comparator<String> com = new Comparator<String>(){
					@Override
					public int compare(String o1, String o2) {
						return Integer.compare(o1.length(), o2.length());
					}
				};				
				TreeSet<String> ts1 = new TreeSet<>(com);				
				TreeSet<String> ts2 = new TreeSet<>(new Comparator<String>(){
					@Override
					public int compare(String o1, String o2) {
						return Integer.compare(o1.length(), o2.length());
					}					
				});
			}			
			//Lambda表达式改进版
			@Test
			public void test2(){
				Comparator<String> com = (x, y) -> Integer.compare(x.length(), y.length());
				TreeSet<String> ts = new TreeSet<>(com);
			}
			#案例分析：
			#员工表
			public class Employee {
				private int id;
				private String name;
				private int age;
				private double salary;
				...
			}
			#模拟数据
			List<Employee> emps = Arrays.asList(
			new Employee(101, "张三", 18, 9999.99),
			new Employee(102, "李四", 59, 6666.66),
			new Employee(103, "王五", 28, 3333.33),
			new Employee(104, "赵六", 8, 7777.77),
			new Employee(105, "田七", 38, 5555.55)
			);
			#需求：获取公司中年龄小于35的员工信息
			public List<Employee> filterEmployeeAge(List<Employee> emps){
				List<Employee> list = new ArrayList<>();				
				for (Employee emp : emps) {
					if(emp.getAge() <= 35){
						list.add(emp);
					}
				}				
				return list;
			}
			#需求：获取公司中工资大于5000员工信息
			public List<Employee> filterEmployeeSalary(List<Employee> emps){
				List<Employee> list = new ArrayList<>();				
				for (Employee emp : emps) {
					if(emp.getSalary() >= 5000){
						list.add(emp);
					}
				}				
				return list;
			}
			#客户端测试
			@Test
			public void test3(){
				List<Employee> list = filterEmployeeAge(emps);
				//List<Employee> list = filterEmployeeSalary(emps);
				for (Employee employee : list) {
					System.out.println(employee);
				}
			}
			#优化方式一策略设计模式
			#接口
			@FunctionalInterface
			public interface MyPredicate<T> {
				public boolean test(T t);				
			}
			#实现
			public class FilterEmployeeForAge implements MyPredicate<Employee>{
				@Override
				public boolean test(Employee t) {
					return t.getAge() <= 35;
				}
			}
			public class FilterEmployeeForSalary implements MyPredicate<Employee> {
				@Override
				public boolean test(Employee t) {
					return t.getSalary() >= 5000;
				}
			}			
			public List<Employee> filterEmployee(List<Employee> emps, MyPredicate<Employee> mp){
				List<Employee> list = new ArrayList<>();				
				for (Employee employee : emps) {
					if(mp.test(employee)){
						list.add(employee);
					}
				}				
				return list;
			}
			#客户端
			@Test
			public void test4(){
				List<Employee> list = filterEmployee(emps, new FilterEmployeeForAge());
				for (Employee employee : list) {
					System.out.println(employee);
				}								
				List<Employee> list2 = filterEmployee(emps, new FilterEmployeeForSalary());
				for (Employee employee : list2) {
					System.out.println(employee);
				}
			}
			#优化方式二匿名内部类
			@Test
			public void test5(){
				List<Employee> list = filterEmployee(emps, new MyPredicate<Employee>() {
					@Override
					public boolean test(Employee t) {
						return t.getId() <= 103;
					}
				});				
				for (Employee employee : list) {
					System.out.println(employee);
				}
			}
			#优化方式三Lambda表达式
			@Test
			public void test6(){
				List<Employee> list = filterEmployee(emps, (e) -> e.getAge() <= 35);
				list.forEach(System.out::println);								
				List<Employee> list2 = filterEmployee(emps, (e) -> e.getSalary() >= 5000);
				list2.forEach(System.out::println);
			}
			#优化方式四StreamAPI
			@Test
			public void test7(){
				emps.stream()
					.filter((e) -> e.getAge() <= 35) //Predicate
					.forEach(System.out::println);								
				emps.stream()
					.map(Employee::getName) //Function
					.limit(3)
					.sorted()
					.forEach(System.out::println);
			}
	二、Lambda的基础语法
		1、概念：
		   Java8中引入了一个新的操作符 "->" 该操作符称为箭头操作符或Lambda操作符， 箭头操作符将Lambda表达式拆分成两部分：左侧：Lambda表达式的参数列表，右侧：Lambda表达式中所需执行的功能，即Lambda体；
		2、语法：
		   语法格式一：无参数，无返回值；如：() -> System.out.println("Hello Lambda!");
		   语法格式二：有一个参数，并且无返回值；如：(x) -> System.out.println(x)；
		   语法格式三：若只有一个参数，小括号可以省略不写；如：x -> System.out.println(x)；
		   语法格式四：有两个以上的参数，有返回值，并且Lambda体中有多条语句；如：
			   Comparator<Integer> com = (x, y) -> {
		 			System.out.println("函数式接口");
		 			return Integer.compare(x, y);
		 	   };
		   语法格式五：若Lambda体中只有一条语句，return和大括号都可以省略不写；如：Comparator<Integer> com = (x, y) -> Integer.compare(x, y);
		   语法格式六：Lambda表达式的参数列表的数据类型可以省略不写，因为JVM编译器通过上下文推断出，数据类型，即“类型推断”；如：(Integer x, Integer y) -> Integer.compare(x, y);
		   总结：上联：左右遇一括号省；下联：左侧推断类型省；横批：能省则省；
		3、函数式接口：
		   含义：接口中只有一个抽象方法的接口，称为函数式接口,可以使用注解@FunctionalInterface修饰；
		   示例：
		   @Test
			public void test1(){
				int num = 0;//jdk 1.7 前，必须是 final				
				Runnable r = new Runnable() {
					@Override
					public void run() {
						System.out.println("Hello World!" + num);
					}
				};				
				r.run();				
				//Lambda表达式，Runnable是函数式接口
				Runnable r1 = () -> System.out.println("Hello Lambda!");
				r1.run();
			}
			@Test
			public void test2(){
				Consumer<String> con = x -> System.out.println(x);
				con.accept("我大尚硅谷威武！");
			}
			@Test
			public void test3(){
				Comparator<Integer> com = (x, y) -> {
					System.out.println("函数式接口");
					return Integer.compare(x, y);
				};
			}			
			@Test
			public void test4(){
				Comparator<Integer> com = (x, y) -> Integer.compare(x, y);
			}
			//自定义函数式接口
			@FunctionalInterface
			public interface MyFun {
				public Integer getValue(Integer num);	
			}
			@Test
			public void test5(){
				Integer num = operation(100, (x) -> x * x);
				System.out.println(num);				
				System.out.println(operation(200, (y) -> y + 200));
			}			
			public Integer operation(Integer num, MyFun mf){
				return mf.getValue(num);
			}
		4、四大核心函数式接口：
			Consumer<T> : void accept(T t)	#消费型接口；
			Supplier<T> : T get()	#供给型接口；
			Function<T, R> : R apply(T t)	#函数型接口；
			Predicate<T> : boolean test(T t)	#断言型接口；
			示例：
			#Consumer<T> 消费型接口 
			@Test
			public void test1(){
				happy(10000, (m) -> System.out.println("你们刚哥喜欢大宝剑，每次消费：" + m + "元"));
			} 			
			public void happy(double money, Consumer<Double> con){
				con.accept(money);
			}
			#Supplier<T> 供给型接口
			@Test
			public void test2(){
				List<Integer> numList = getNumList(10, () -> (int)(Math.random() * 100));				
				for (Integer num : numList) {
					System.out.println(num);
				}
			}			
			//需求：产生指定个数的整数，并放入集合中
			public List<Integer> getNumList(int num, Supplier<Integer> sup){
				List<Integer> list = new ArrayList<>();				
				for (int i = 0; i < num; i++) {
					Integer n = sup.get();
					list.add(n);
				}				
				return list;
			}
			#Function<T, R> 函数型接口
			@Test
			public void test3(){
				String newStr = strHandler("\t\t\t 我大尚硅谷威武   ", (str) -> str.trim());
				System.out.println(newStr);				
				String subStr = strHandler("我大尚硅谷威武", (str) -> str.substring(2, 5));
				System.out.println(subStr);
			}			
			//需求：用于处理字符串
			public String strHandler(String str, Function<String, String> fun){
				return fun.apply(str);
			}
			#Predicate<T> 断言型接口
			@Test
			public void test4(){
				List<String> list = Arrays.asList("Hello", "atguigu", "Lambda", "www", "ok");
				List<String> strList = filterStr(list, (s) -> s.length() > 3);				
				for (String str : strList) {
					System.out.println(str);
				}
			}			
			//需求：将满足条件的字符串，放入集合中
			public List<String> filterStr(List<String> list, Predicate<String> pre){
				List<String> strList = new ArrayList<>();				
				for (String str : list) {
					if(pre.test(str)){
						strList.add(str);
					}
				}				
				return strList;
			}
		5、方法引用：
			含义：若Lambda体中的功能，已经有方法提供了实现，可以使用方法引用，可以将方法引用理解为Lambda表达式的另外一种表现形式；
			语法格式：
				对象的引用 :: 实例方法名
				类名 :: 静态方法名
				类名 :: 实例方法名
				注意：①方法引用所引用的方法的（Lambda体中）参数列表与返回值类型，需要与函数式接口中抽象方法的参数列表和返回值类型保持一致！
					  ②若Lambda的参数列表的第一个参数，是实例方法的调用者，第二个参数(或无参)是实例方法的参数时，格式： ClassName::MethodName 或类名 :: 实例方法名
			示例：
			@Test
			public void test1(){
				PrintStream ps = System.out;
				Consumer<String> con = (str) -> ps.println(str);
				con.accept("Hello World！");								
				Consumer<String> con2 = ps::println;
				con2.accept("Hello Java8！");				
				Consumer<String> con3 = System.out::println;				
				con3.accept("Hello Java8！");
			}
			#对象的引用 :: 实例方法名
			@Test
			public void test2(){
				Employee emp = new Employee(101, "张三", 18, 9999.99);				
				Supplier<String> sup = () -> emp.getName();
				System.out.println(sup.get());							
				Supplier<String> sup2 = emp::getName;
				System.out.println(sup2.get());
			}
			#类名 :: 静态方法名
			@Test
			public void test3(){
				BiFunction<Double, Double, Double> fun = (x, y) -> Math.max(x, y);
				System.out.println(fun.apply(1.5, 22.2));				
				BiFunction<Double, Double, Double> fun2 = Math::max;
				System.out.println(fun2.apply(1.2, 1.5));
			}
			@Test
			public void test4(){
				Comparator<Integer> com = (x, y) -> Integer.compare(x, y);								
				Comparator<Integer> com2 = Integer::compare;
				System.out.println(com2.compare(1, 2));
			}
			#类名 :: 实例方法名
			@Test
			public void test5(){
				BiPredicate<String, String> bp = (x, y) -> x.equals(y);
				System.out.println(bp.test("abcde", "abcde"));							
				BiPredicate<String, String> bp2 = String::equals;
				System.out.println(bp2.test("abc", "abc"));												
				Function<Employee, String> fun = (e) -> e.show();
				System.out.println(fun.apply(new Employee()));				
				Function<Employee, String> fun2 = Employee::show;
				System.out.println(fun2.apply(new Employee()));				
			}
			public String show() {
				return "测试方法引用！";
			}
		6、构造器引用: 构造器的参数列表，需要与函数式接口中参数列表保持一致！使用：类名 :: new
			#构造器引用
			@Test
			public void test6(){
				Supplier<Employee> sup = () -> new Employee();
				System.out.println(sup.get());								
				Supplier<Employee> sup2 = Employee::new;
				System.out.println(sup2.get());
			}
			@Test
			public void test7(){
				Function<String, Employee> fun = Employee::new;				
				BiFunction<String, Integer, Employee> fun2 = Employee::new;
			}
		7、数组引用：类型[] :: new
			@Test
			public void test8(){
				Function<Integer, String[]> fun = (args) -> new String[args];
				String[] strs = fun.apply(10);
				System.out.println(strs.length);								
				Function<Integer, Employee[]> fun2 = Employee[] :: new;
				Employee[] emps = fun2.apply(20);
				System.out.println(emps.length);
			}
		8、综合案例：
			#模拟内存数据
			List<Employee> emps = Arrays.asList(
					new Employee(101, "张三", 18, 9999.99),
					new Employee(102, "李四", 59, 6666.66),
					new Employee(103, "王五", 28, 3333.33),
					new Employee(104, "赵六", 8, 7777.77),
					new Employee(105, "田七", 38, 5555.55)
			);
			#按年龄排序，年龄相同按姓名排序
			@Test
			public void test1(){
				Collections.sort(emps, (e1, e2) -> {
					if(e1.getAge() == e2.getAge()){
							return e1.getName().compareTo(e2.getName());
					}else{
						return -Integer.compare(e1.getAge(), e2.getAge());
					}
				});				
				for (Employee emp : emps) {
					System.out.println(emp);
				}
			}
			@Test
			public void test2(){
				String trimStr = strHandler("\t\t\t 我大尚硅谷威武   ", (str) -> str.trim());
				System.out.println(trimStr);				
				String upper = strHandler("abcdef", (str) -> str.toUpperCase());
				System.out.println(upper);				
				String newStr = strHandler("我大尚硅谷威武", (str) -> str.substring(2, 5));
				System.out.println(newStr);
			}			
			//需求：用于处理字符串
			public String strHandler(String str, MyFunction mf){
				return mf.getValue(str);
			}
			@FunctionalInterface
			public interface MyFunction {				
				public String getValue(String str);
			}
			@Test
			public void test3(){
				op(100L, 200L, (x, y) -> x + y);				
				op(100L, 200L, (x, y) -> x * y);
			}			
			//需求：对于两个Long型数据进行处理
			public void op(Long l1, Long l2, MyFunction2<Long, Long> mf){
				System.out.println(mf.getValue(l1, l2));
			}
			@FunctionalInterface
			public interface MyFunction2<T, R> {
				public R getValue(T t1, T t2);				
			}
	三、Stream流操作
		1、StreamaAPI的基本知识
		   操作步骤：创建 Stream  -> 中间操作 -> 终止操作(终端操作)
		   示例：
		   1. 创建Stream
			@Test
			public void test1(){
				//1. Collection 提供了两个方法stream()与parallelStream()
				List<String> list = new ArrayList<>();
				Stream<String> stream = list.stream(); //获取一个顺序流
				Stream<String> parallelStream = list.parallelStream(); //获取一个并行流				
				//2. 通过 Arrays 中的静态方法 stream() 获取一个数组流
				Integer[] nums = new Integer[10];
				Stream<Integer> stream1 = Arrays.stream(nums);				
				//3. 通过 Stream 类中静态方法 of()
				Stream<Integer> stream2 = Stream.of(1,2,3,4,5,6);				
				//4. 创建无限流
				//迭代
				Stream<Integer> stream3 = Stream.iterate(0, (x) -> x + 2).limit(10);
				stream3.forEach(System.out::println);				
				//生成，类名：：静态方法
				Stream<Double> stream4 = Stream.generate(Math::random).limit(2);
				stream4.forEach(System.out::println);				
			}
		   2. 中间操作，模拟内存数据
			List<Employee> emps = Arrays.asList(
					new Employee(102, "李四", 59, 6666.66),
					new Employee(101, "张三", 18, 9999.99),
					new Employee(103, "王五", 28, 3333.33),
					new Employee(104, "赵六", 8, 7777.77),
					new Employee(104, "赵六", 8, 7777.77),
					new Employee(104, "赵六", 8, 7777.77),
					new Employee(105, "田七", 38, 5555.55)
			);
			#筛选与切片
			filter（过滤）——接收Lambda，从流中排除某些元素
			limit（限制）——截断流，使其元素不超过给定数量
			skip(n) —— 跳过元素，返回一个扔掉了前 n 个元素的流。若流中元素不足 n 个，则返回一个空流。与 limit(n) 互补
			distinct——筛选，通过流所生成元素的 hashCode() 和 equals() 去除重复元素
			#内部迭代：迭代操作 Stream API 内部完成
			@Test
			public void test2(){
				//所有的中间操作不会做任何的处理
				Stream<Employee> stream = emps.stream()
					.filter((e) -> {
						System.out.println("测试中间操作");
						return e.getAge() <= 35;
					});//Predicate boolean test(T t);				
				//只有当做终止操作时，所有的中间操作会一次性的全部执行，称为“惰性求值”
				stream.forEach(System.out::println);
			}
			#外部迭代
			@Test
			public void test3(){
				Iterator<Employee> it = emps.iterator();				
				while(it.hasNext()){
					System.out.println(it.next());
				}
			}
			@Test
			public void test4(){
				emps.stream()
					.filter((e) -> {
						System.out.println("短路！"); // &&  ||
						return e.getSalary() >= 5000;
					}).limit(3)
					.forEach(System.out::println);
			}
			@Test
			public void test5(){
				emps.parallelStream()
					.filter((e) -> e.getSalary() >= 5000)
					.skip(2)
					.forEach(System.out::println);
			}
			@Test
			public void test6(){
				emps.stream()
					.distinct()
					.forEach(System.out::println);
			}
			#映射
			map——接收Lambda，将元素转换成其他形式或提取信息。接收一个函数作为参数，该函数会被应用到每个元素上，并将其映射成一个新的元素
			flatMap——接收一个函数作为参数，将流中的每个值都换成另一个流，然后把所有流连接成一个流
			
			
			
----------------------------------------------Java高级篇之网络编程技术---------------------------------------------------------------------------------------------------------------------------------------	
	一、网络编程基础知识
		1、注意区分MQ与网络通讯的区别：
			MQ的目的是为了缓解服务器的压力，在消息生产者与消费者之间添加了一层，使系统解耦，接收的消息可以延迟，不要求完全实时性；
			网络通讯是服务端与客户端之间直接通讯，中间没有添加其他层，实时消息；
		2、Socket基本认识：
			含义：Socket又称“套接字”，即应用程序通过“套接字”向网络发起请求或应答网络请求，在java.net包内有Socket与ServerSocket类分别对应服务端和客户端（建立网络连接）；
				  建立连接成功后，两端都会产生一个Socket实例，操作这个实例，来完成此次会话；具体的工作，都是由子类去实现的；
								发起请求
				  Socket <------------------------>ServerSocket
								应答网络请求
			      套接字的连接过程分为4步骤（3次握手、4次挥手）：
					服务器监听：服务器端处于等待连接状态（accept）（不确定哪一个客户端连接），实时监测网络状态；
					客户端请求服务端：前提是客户端必须描述服务端的套接字，即指出地址和端口号，然后才能发出连接请求；
					服务端连接确认：服务端监听到客户端套接字的连接请求，响应客户端请求，建立一个新的线程（Thread），把自身的套接字描述信息发给客户端；
					客户端连接确认：一旦客户端确认了服务端的描述，双方建立连接，开始通讯；同时，服务端仍然属于监听状态，等待其他客户端来连接；
		3、IO（BIO）与NIO的认识：
			本质是阻塞与非阻塞的区别；
				阻塞：应用程序在获取网络数据的时候，如果网络传输慢，程序必须一直等待着，直到传输完毕为止；完全依赖于网络带宽
				非阻塞：程序直接获取已经准备好的数据，无需等待；即在网路之外添加了一个channel与buffer，客户端直接从这里面取数据；
			BIO：同步阻塞，NIO同步非阻塞，在JDK1.7以后出现了异步非阻塞模型即NIO2.0（AIO）
			同步与异步：面向操作系统的；同步指程序直接参与IO的读写操作；异步所有的IO的读写交给操作系统；同步指的是服务端执行方式，阻塞指的是具体技术；
			BIO通讯：基于TCP/IP协议，跨址传输，C/S模型，Client（多个）------------->Server acceptor（阻塞状态）---------->Thread（多个）
				案例说明：
				//服务端
				public class Server {
					final static int PROT = 8765;					
					public static void main(String[] args) {					
						ServerSocket server = null;
						try {
							server = new ServerSocket(PROT);
							System.out.println(" server start .. ");
							//进行阻塞，开启线程
							Socket socket = server.accept();
							//新建一个线程执行客户端的任务
							new Thread(new ServerHandler(socket)).start();							
						} catch (Exception e) {
							e.printStackTrace();
						} finally {
							if(server != null){
								try {
									server.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
							}
							server = null;
						}																		
					}
				}
				//客户端
				public class Client {
					final static String ADDRESS = "127.0.0.1";
					final static int PORT = 8765;					
					public static void main(String[] args) {						
						Socket socket = null;
						//输入流-读数据，输出流-写数据
						BufferedReader in = null;
						PrintWriter out = null;						
						try {
							socket = new Socket(ADDRESS, PORT);//描述服务端套接字的信息
							in = new BufferedReader(new InputStreamReader(socket.getInputStream()));
							out = new PrintWriter(socket.getOutputStream(), true);							
							//向服务器端发送数据
							out.println("接收到客户端的请求数据...");
							String response = in.readLine();
							System.out.println("Client: " + response);//结果：Client: 服务器端回送响的应数据.							
						} catch (Exception e) {
							e.printStackTrace();
						} finally {
							if(in != null){
								try {
									in.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
							}
							if(out != null){
								try {
									out.close();
								} catch (Exception e) {
									e.printStackTrace();
								}
							}
							if(socket != null){
								try {
									socket.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
							}
							socket = null;
						}
					}
				}
				//Handler
				public class ServerHandler implements Runnable{
					private Socket socket;					
					public ServerHandler(Socket socket){
						this.socket = socket;
					}					
					@Override
					public void run() {
						BufferedReader in = null;
						PrintWriter out = null;
						try {
							in = new BufferedReader(new InputStreamReader(this.socket.getInputStream()));
							out = new PrintWriter(this.socket.getOutputStream(), true);
							String body = null;
							while(true){
								body = in.readLine();
								if(body == null) break;
								System.out.println("Server :" + body);//结果：Server : 接收到客户端的请求数据...
								out.println("服务器端回送响的应数据.");
							}							
						} catch (Exception e) {
							e.printStackTrace();
						} finally {
							if(in != null){
								try {
									in.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
							}
							if(out != null){
								try {
									out.close();
								} catch (Exception e) {
									e.printStackTrace();
								}
							}
							if(socket != null){
								try {
									socket.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
							}
							socket = null;
						}												
					}
				}
			伪异步IO：利用线程池技术来缓解创建过多线程带来的服务器的压力；
				原理：Client（多个）------------->Server acceptor（阻塞状态）---------->ThreadPool，实现Runable接口；
				//案例分析：
				//服务端
				public class Server {
					final static int PORT = 8765;
					public static void main(String[] args) {
						ServerSocket server = null;
						BufferedReader in = null;
						PrintWriter out = null;
						try {
							server = new ServerSocket(PORT);
							System.out.println("server start...");
							Socket socket = null;
							//利用池技术
							HandlerExecutorPool executorPool = new HandlerExecutorPool(50, 1000);
							while(true){
								socket = server.accept();
								executorPool.execute(new ServerHandler(socket));
							}						
						} catch (Exception e) {
							e.printStackTrace();
						} finally {
							if(in != null){
								try {
									in.close();
								} catch (Exception e1) {
									e1.printStackTrace();
								}
							}
							if(out != null){
								try {
									out.close();
								} catch (Exception e2) {
									e2.printStackTrace();
								}
							}
							if(server != null){
								try {
									server.close();
								} catch (Exception e3) {
									e3.printStackTrace();
								}
							}
							server = null;				
						}																
					}										
				}
				//线程池，JDK1.5以后JUC包下
				public class HandlerExecutorPool {
					private ExecutorService executor;
					public HandlerExecutorPool(int maxPoolSize, int queueSize){
						this.executor = new ThreadPoolExecutor(
								Runtime.getRuntime().availableProcessors(),
								maxPoolSize, 
								120L, 
								TimeUnit.SECONDS,
								new ArrayBlockingQueue<Runnable>(queueSize));
					}					
					public void execute(Runnable task){
						this.executor.execute(task);
					}														
				}
				//客户端、Handler类同上；
			NIO：（JDK1.5）非阻塞IO（同步），核心概念：Buffer（缓冲区）、Channel（通道）、Selector（多路复用器、选择器），目的就是减少TCP的3次握手4次挥手操作，减少连接开销；
				原理：Client端（核心类：SocketChannel类，对Socket类的进一步抽象）注册到服务端选择器上
					  Server端（核心类：ServerSocketChannel类，对ServerSocket类的进一步抽象），这里有多路复用器，采用轮询（Key）所有注册通道，查看通道状态（Connect、Accept、Read、Write），执行相关操作；
				基本概念解释：	  
					  Buffer：缓冲区，包含读写数据的对象，实质是一个对象，通常是一个字节数组（ByteBuffer），也可以对应Java的其他基本类型（Boolean除外）；
					  Channel：网络数据通过Channel读写，方向是双向的，与多路复用器结合，有多种状态位；有2种分类：网路读写（SelectableChannel）、文件操作（FileChannel）;
					  Selector：多路复用器、选择器，是NIO基础，轮询注册其上的Channel，查看通道状态；理论上channel是无上限的，底层利用JDK的epoll机制，获取连接句柄；
								类似一个管理者角色，管理channel，在客户端通道注册到选择器后，Selector会分配每一个channel一个key，轮询的是key；当管道准备就绪（accept）状态时，通知cpu进行读写操作；
					  Buffer：API说明示例；
					  public class TestBuffer {						
						public static void main(String[] args) {							
							// 1 基本操作
							//创建指定长度的缓冲区
							IntBuffer buf = IntBuffer.allocate(10);//声明容量
							buf.put(13);// position位置：0 - > 1
							buf.put(21);// position位置：1 - > 2
							buf.put(35);// position位置：2 - > 3
							//把位置复位为0，也就是position位置：3 - > 0
							buf.flip();
							System.out.println("使用flip复位：" + buf);//使用flip复位：java.nio.HeapIntBuffer[pos=0 lim=3 cap=10]
							System.out.println("容量为: " + buf.capacity());	//容量一旦初始化后不允许改变（warp方法包裹数组除外）
							System.out.println("限制为: " + buf.limit());		//由于只装载了三个元素,所以可读取或者操作的元素为3 则limit=3														
							System.out.println("获取下标为1的元素：" + buf.get(1));//读数据
							System.out.println("get(index)方法，position位置不改变：" + buf);//get(index)方法，position位置不改变：java.nio.HeapIntBuffer[pos=0 lim=3 cap=10]
							buf.put(1, 4);//写数据
							System.out.println("put(index, change)方法，position位置不变：" + buf);//java.nio.HeapIntBuffer[pos=0 lim=3 cap=10]						
							for (int i = 0; i < buf.limit(); i++) {
								//调用get方法会使其缓冲区位置（position）向后递增一位
								System.out.print(buf.get() + "\t");
							}
							System.out.println("buf对象遍历之后为: " + buf);	//buf对象遍历之后为: java.nio.HeapIntBuffer[pos=3 lim=3 cap=10]						
							// 2 wrap方法使用
							//  wrap方法会包裹一个数组: 一般这种用法不会先初始化缓存对象的长度，因为没有意义，最后还会被wrap所包裹的数组覆盖掉。 
							//  并且wrap方法修改缓冲区对象的时候，数组本身也会跟着发生变化。                     
							int[] arr = new int[]{1,2,5};
							IntBuffer buf1 = IntBuffer.wrap(arr);
							System.out.println(buf1);//java.nio.HeapIntBuffer[pos=0 lim=3 cap=3]						
							IntBuffer buf2 = IntBuffer.wrap(arr, 0 , 2);
							//这样使用表示容量为数组arr的长度，但是可操作的元素只有实际进入缓存区的元素长度
							System.out.println(buf2);//java.nio.HeapIntBuffer[pos=0 lim=2 cap=3]														
							// 3 其他方法
							IntBuffer buf1 = IntBuffer.allocate(10);
							int[] arr = new int[]{1,2,5};
							buf1.put(arr);
							System.out.println(buf1);//java.nio.HeapIntBuffer[pos=3 lim=10 cap=10]	
							//一种复制方法
							IntBuffer buf3 = buf1.duplicate();
							System.out.println(buf3);//java.nio.HeapIntBuffer[pos=3 lim=10 cap=10]	
							//设置buf1的位置属性
							//buf1.position(0);
							buf1.flip();
							System.out.println(buf1);//java.nio.HeapIntBuffer[pos=0 lim=3 cap=10]							
							System.out.println("可读数据为：" + buf1.remaining());//可读数据为：3						
							int[] arr2 = new int[buf1.remaining()];
							//将缓冲区数据放入arr2数组中去
							buf1.get(arr2);
							for(int i : arr2){
								System.out.print(Integer.toString(i) + ",");//1,2,5,
							}							
						}
					}
				  NIO案例说明（了解）：
					//服务端（读-操作）
					public class Server implements Runnable{
						//1 多路复用器（管理所有的通道）
						private Selector seletor;
						//2 建立缓冲区
						private ByteBuffer readBuf = ByteBuffer.allocate(1024);
						//private ByteBuffer writeBuf = ByteBuffer.allocate(1024);
						public Server(int port){
							try {
								//1 打开路复用器
								this.seletor = Selector.open();
								//2 打开服务器通道
								ServerSocketChannel ssc = ServerSocketChannel.open();
								//3 设置服务器通道为非阻塞模式
								ssc.configureBlocking(false);
								//4 绑定地址
								ssc.bind(new InetSocketAddress(port));
								//5 把服务器通道注册到多路复用器上，并且监听阻塞事件，标识位
								ssc.register(this.seletor, SelectionKey.OP_ACCEPT);								
								System.out.println("Server start, port :" + port);								
							} catch (IOException e) {
								e.printStackTrace();
							}
						}
						@Override
						public void run() {
							while(true){
								try {
									//1 必须要让多路复用器开始监听
									this.seletor.select();
									//2 返回多路复用器已经选择的结果集
									Iterator<SelectionKey> keys = this.seletor.selectedKeys().iterator();
									//3 进行遍历
									while(keys.hasNext()){
										//4 获取一个选择的元素
										SelectionKey key = keys.next();
										//5 直接从容器中移除就可以了
										keys.remove();
										//6 如果是有效的
										if(key.isValid()){
											//7 如果为阻塞状态
											if(key.isAcceptable()){
												this.accept(key);
											}
											//8 如果为可读状态
											if(key.isReadable()){
												this.read(key);
											}
											//9 写数据
											if(key.isWritable()){
												//this.write(key); //ssc
											}
										}										
									}
								} catch (IOException e) {
									e.printStackTrace();
								}
							}
						}						
						private void write(SelectionKey key){
							//ServerSocketChannel ssc =  (ServerSocketChannel) key.channel();
							//ssc.register(this.seletor, SelectionKey.OP_WRITE);
						}
						private void read(SelectionKey key) {
							try {
								//1 清空缓冲区旧的数据
								this.readBuf.clear();
								//2 获取之前注册的socket通道对象
								SocketChannel sc = (SocketChannel) key.channel();
								//3 读取数据
								int count = sc.read(this.readBuf);
								//4 如果没有数据
								if(count == -1){
									key.channel().close();
									key.cancel();
									return;
								}
								//5 有数据则进行读取 读取之前需要进行复位方法(把position 和limit进行复位)
								this.readBuf.flip();
								//6 根据缓冲区的数据长度创建相应大小的byte数组，接收缓冲区的数据
								byte[] bytes = new byte[this.readBuf.remaining()];
								//7 接收缓冲区数据
								this.readBuf.get(bytes);
								//8 打印结果
								String body = new String(bytes).trim();
								System.out.println("Server : " + body);								
								// 9..可以写回给客户端数据 								
							} catch (IOException e) {
								e.printStackTrace();
							}							
						}
						private void accept(SelectionKey key) {
							try {
								//1 获取服务通道
								ServerSocketChannel ssc =  (ServerSocketChannel) key.channel();
								//2 执行阻塞方法
								SocketChannel sc = ssc.accept();
								//3 设置阻塞模式
								sc.configureBlocking(false);
								//4 注册到多路复用器上，并设置读取标识，即sc通道可读
								sc.register(this.seletor, SelectionKey.OP_READ);
							} catch (IOException e) {
								e.printStackTrace();
							}
						}						
						public static void main(String[] args) {							
							new Thread(new Server(8765)).start();
						}											
					}
					//客户端
					public class Client {
						//需要一个Selector 
						public static void main(String[] args) {							
							//创建连接的地址
							InetSocketAddress address = new InetSocketAddress("127.0.0.1", 8765);							
							//声明连接通道
							SocketChannel sc = null;							
							//建立缓冲区
							ByteBuffer buf = ByteBuffer.allocate(1024);							
							try {
								//打开通道
								sc = SocketChannel.open();
								//进行连接
								sc.connect(address);								
								while(true){
									//定义一个字节数组，然后使用系统录入功能：
									byte[] bytes = new byte[1024];
									System.in.read(bytes);									
									//把数据放到缓冲区中
									buf.put(bytes);
									//对缓冲区进行复位
									buf.flip();
									//写出数据
									sc.write(buf);
									//清空缓冲区数据
									buf.clear();
								}
							} catch (IOException e) {
								e.printStackTrace();
							} finally {
								if(sc != null){
									try {
										sc.close();
									} catch (IOException e) {
										e.printStackTrace();
									}
								}
							}							
						}						
					}
				优缺点：优点减少连接数量，采用抽象的通道技术（取代了TCP/IP的通讯技术）以及多路复用等技术；缺点：书写繁琐，所有的细节都要自己去实现；
			AIO：（JDK1.7）	异步非阻塞，引入异步通道概念；在多路复用器轮询通道是异步的，两个核心类：AsynchronousSocketChannel与AsynchronousServerSocketChannel；
				案例说明：
				//服务端
				public class Server {
					//线程池
					private ExecutorService executorService;
					//线程组
					private AsynchronousChannelGroup threadGroup;
					//服务器通道
					public AsynchronousServerSocketChannel assc;					
					public Server(int port){
						try {
							//创建一个缓存池
							executorService = Executors.newCachedThreadPool();
							//创建线程组
							threadGroup = AsynchronousChannelGroup.withCachedThreadPool(executorService, 1);
							//创建服务器通道
							assc = AsynchronousServerSocketChannel.open(threadGroup);
							//进行绑定，便于寻址
							assc.bind(new InetSocketAddress(port));							
							System.out.println("server start , port : " + port);
							//进行阻塞
							assc.accept(this, new ServerCompletionHandler());
							//一直阻塞不让服务器停止，模拟服务器一直处于运行状态，因为非阻塞
							Thread.sleep(Integer.MAX_VALUE);							
						} catch (Exception e) {
							e.printStackTrace();
						}
					}					
					public static void main(String[] args) {
						Server server = new Server(8765);
					}					
				}
				//Handler
				public class ServerCompletionHandler implements CompletionHandler<AsynchronousSocketChannel, Server> {
					@Override
					public void completed(AsynchronousSocketChannel asc, Server attachment) {
						//当有下一个客户端接入的时候直接调用Server的accept方法，这样反复执行下去，保证多个客户端都可以阻塞
						attachment.assc.accept(attachment, this);
						read(asc);
					}
					private void read(final AsynchronousSocketChannel asc) {
						//读取数据，异步读数据
						ByteBuffer buf = ByteBuffer.allocate(1024);
						asc.read(buf, buf, new CompletionHandler<Integer, ByteBuffer>() {
							@Override
							public void completed(Integer resultSize, ByteBuffer attachment) {//数据读完以后
								//进行读取之后,重置标识位
								attachment.flip();
								//获得读取的字节数
								System.out.println("Server -> " + "收到客户端的数据长度为:" + resultSize);
								//获取读取的数据
								String resultData = new String(attachment.array()).trim();
								System.out.println("Server -> " + "收到客户端的数据信息为:" + resultData);
								String response = "服务器响应, 收到了客户端发来的数据: " + resultData;
								write(asc, response);
							}
							@Override
							public void failed(Throwable exc, ByteBuffer attachment) {
								exc.printStackTrace();
							}
						});
					}					
					private void write(AsynchronousSocketChannel asc, String response) {
						try {
							ByteBuffer buf = ByteBuffer.allocate(1024);
							buf.put(response.getBytes());
							buf.flip();
							asc.write(buf).get();//开启一个新的线程，不影响主线程执行，不断的写数据
						} catch (InterruptedException e) {
							e.printStackTrace();
						} catch (ExecutionException e) {
							e.printStackTrace();
						}
					}					
					@Override
					public void failed(Throwable exc, Server attachment) {
						exc.printStackTrace();
					}
				}
				//客户端
				public class Client implements Runnable{
					private AsynchronousSocketChannel asc ;					
					public Client() throws Exception {
						asc = AsynchronousSocketChannel.open();
					}					
					public void connect(){
						asc.connect(new InetSocketAddress("127.0.0.1", 8765));//寻址
					}					
					public void write(String request){
						try {
							asc.write(ByteBuffer.wrap(request.getBytes())).get();
							read();
						} catch (Exception e) {
							e.printStackTrace();
						}
					}
					private void read() {
						ByteBuffer buf = ByteBuffer.allocate(1024);
						try {
							asc.read(buf).get();//不断的读数据
							buf.flip();
							byte[] respByte = new byte[buf.remaining()];
							buf.get(respByte);
							System.out.println(new String(respByte,"utf-8").trim());
						} catch (InterruptedException e) {
							e.printStackTrace();
						} catch (ExecutionException e) {
							e.printStackTrace();
						} catch (UnsupportedEncodingException e) {
							e.printStackTrace();
						}
					}					
					@Override
					public void run() {//模拟客户端服务一直开启状态
						while(true){							
						}
					}					
					public static void main(String[] args) throws Exception {
						Client c1 = new Client();
						c1.connect();						
						Client c2 = new Client();
						c2.connect();					
						Client c3 = new Client();
						c3.connect();						
						new Thread(c1, "c1").start();
						new Thread(c2, "c2").start();
						new Thread(c3, "c3").start();						
						Thread.sleep(1000);						
						c1.write("c1 aaa");
						c2.write("c2 bbbb");
						c3.write("c3 ccccc");
					}					
				}
	二、Netty通讯技术（联想Apache mina通讯框架）
		1、初步认识：
			Netty简单易用，健壮可扩展，当下主流框架技术底层都有用到，如：JMS中的RocketMQ、分布式通信框架Dubbox、Hadoop的RPC框架Avro等等
			Netty是基于Java的NIO（客户端-服务端）网络应用框架，它提供了简易的API使得与业务逻辑解耦，是异步通讯的（非阻塞）；
			Netty支持的传输协议有：Socket、Http，它支持服务有WebSocket、SSL（安全认证、Secure Sockets Layer 安全套接层）以及大文件传输等
			Netty特性：易于使用、高吞吐量低的延迟性能好、安全性高、社区活跃度高
		2、Netty通讯步骤：
			//服务端
			a、创建2个线程组，一个专门用于网络事件处理（接收客户端的连接，客户端可能有多个），另一个进行网络通讯读写；
			b、创建ServerBootstrap对象，配置Netty参数；
			c、创建类ChannelInitalizer，配置初始化工作；
			d、配置端口，启动Netty服务端；
			//客户端
			a、创建1个线程组，进行网络通讯读写；
			b、创建Bootstrap对象，配置Netty参数；
			c、创建类ChannelInitalizer，配置初始化工作；
			d、寻址，连接Netty服务端；
		3、简单示例，入门级HelloWorld：
		   //服务端，调用netty API接口
		   public class Server {
				public static void main(String[] args) throws Exception {
					//1 创建线两个程组，一个是用于处理服务器端接收客户端连接的，一个是进行网络通信的（网络读写）
					EventLoopGroup pGroup = new NioEventLoopGroup();
					EventLoopGroup cGroup = new NioEventLoopGroup();					
					//2 创建辅助工具类，用于服务器通道的一系列配置
					ServerBootstrap b = new ServerBootstrap();
					b.group(pGroup, cGroup)		//绑定俩个线程组
					.channel(NioServerSocketChannel.class)		//指定NIO的模式
					.option(ChannelOption.SO_BACKLOG, 1024)		//设置tcp缓冲区
					.option(ChannelOption.SO_SNDBUF, 32*1024)	//设置发送缓冲大小
					.option(ChannelOption.SO_RCVBUF, 32*1024)	//接收缓冲大小
					.option(ChannelOption.SO_KEEPALIVE, true)	//保持连接
					.childHandler(new ChannelInitializer<SocketChannel>() {
						@Override
						protected void initChannel(SocketChannel sc) throws Exception {
							//3 在这里配置具体数据接收方法的处理
							sc.pipeline().addLast(new ServerHandler());
						}
					});					
					//4 进行绑定，即服务端可以开放多个端口 
					ChannelFuture cf1 = b.bind(8765).sync();
					//ChannelFuture cf2 = b.bind(8764).sync();
					//5 等待关闭，同步优雅关闭
					cf1.channel().closeFuture().sync();
					//cf2.channel().closeFuture().sync();
					pGroup.shutdownGracefully();
					cGroup.shutdownGracefully();
				}
			}
			//ServerHandler，处理服务端业务逻辑
			public class ServerHandler extends ChannelHandlerAdapter {
				@Override
				public void channelActive(ChannelHandlerContext ctx) throws Exception {
					System.out.println("server channel active... ");
				}
				@Override
				public void channelRead(ChannelHandlerContext ctx, Object msg)
						throws Exception {
						ByteBuf buf = (ByteBuf) msg;
						byte[] req = new byte[buf.readableBytes()];
						buf.readBytes(req);
						String body = new String(req, "utf-8");
						System.out.println("Server :" + body );//服务端接收到的shuju
						String response = "进行返回给客户端的响应：" + body ;
						ctx.writeAndFlush(Unpooled.copiedBuffer(response.getBytes()));
						//.addListener(ChannelFutureListener.CLOSE);//将Netty长连接转成短连接
				}
				@Override
				public void channelReadComplete(ChannelHandlerContext ctx)
						throws Exception {
					System.out.println("读完了");
					ctx.flush();
				}
				@Override
				public void exceptionCaught(ChannelHandlerContext ctx, Throwable t)
						throws Exception {
					ctx.close();
				}
			}
			//客户端，调用netty API接口
			public class Client {
				public static void main(String[] args) throws Exception{					
					EventLoopGroup group = new NioEventLoopGroup();
					Bootstrap b = new Bootstrap();
					b.group(group)
					.channel(NioSocketChannel.class)
					.handler(new ChannelInitializer<SocketChannel>() {
						@Override
						protected void initChannel(SocketChannel sc) throws Exception {
							sc.pipeline().addLast(new ClientHandler());
						}
					});					
					ChannelFuture cf1 = b.connect("127.0.0.1", 8765).sync();//寻址，模拟多个客户端连接
					//ChannelFuture cf2 = b.connect("127.0.0.1", 8764).sync();
					//发送消息
					Thread.sleep(1000);
					cf1.channel().writeAndFlush(Unpooled.copiedBuffer("777".getBytes()));
					cf1.channel().writeAndFlush(Unpooled.copiedBuffer("666".getBytes()));
					//cf2.channel().writeAndFlush(Unpooled.copiedBuffer("888".getBytes()));
					Thread.sleep(2000);
					cf1.channel().writeAndFlush(Unpooled.copiedBuffer("888".getBytes()));
					//cf2.channel().writeAndFlush(Unpooled.copiedBuffer("666".getBytes()));					
					cf1.channel().closeFuture().sync();
					//cf2.channel().closeFuture().sync();
					group.shutdownGracefully();															
				}
			}
			// ClientHandler，处理客户端业务逻辑
			public class ClientHandler extends ChannelHandlerAdapter{
				@Override
				public void channelActive(ChannelHandlerContext ctx) throws Exception {
				}
				@Override
				public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
					try {
						ByteBuf buf = (ByteBuf) msg;						
						byte[] req = new byte[buf.readableBytes()];
						buf.readBytes(req);					
						String body = new String(req, "utf-8");
						System.out.println("Client :" + body );//客户端接收到的服务端的响应数据
						String response = "收到服务器端的返回信息：" + body;
					} finally {
						ReferenceCountUtil.release(msg);//释放信息
					}
				}
				@Override
				public void channelReadComplete(ChannelHandlerContext ctx) throws Exception {
				}
				@Override
				public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause)
						throws Exception {
					ctx.close();
				}
			}
		4、Netty拆包、粘包：
			问题产生：TCP是一个“流”的协议，即没有界限的遗传数据，会产生拆包、粘包问题，对应的解决方案：
				1、消息定长（固定报文的长度）；2、在包尾部添加特殊的字符进行分割；3、将消息分为消息头（消息长度）与消息体；
			Netty提供：DelimiterBasedFrameDecoder（自定义分割符类）、FixedLengthFrameDecoder（定长）来处理这一问题；
			案例分析一：
			//服务端
			public class Server {
				public static void main(String[] args) throws Exception{
					//1 创建2个线程，一个是负责接收客户端的连接。一个是负责进行数据传输的
					EventLoopGroup pGroup = new NioEventLoopGroup();
					EventLoopGroup cGroup = new NioEventLoopGroup();					
					//2 创建服务器辅助类
					ServerBootstrap b = new ServerBootstrap();
					b.group(pGroup, cGroup)
					 .channel(NioServerSocketChannel.class)
					 .option(ChannelOption.SO_BACKLOG, 1024)
					 .option(ChannelOption.SO_SNDBUF, 32*1024)
					 .option(ChannelOption.SO_RCVBUF, 32*1024)
					 .childHandler(new ChannelInitializer<SocketChannel>() {
						@Override
						protected void initChannel(SocketChannel sc) throws Exception {
							//设置特殊分隔符$_
							ByteBuf buf = Unpooled.copiedBuffer("$_".getBytes());
							sc.pipeline().addLast(new DelimiterBasedFrameDecoder(1024, buf));
							//设置字符串形式的解码
							sc.pipeline().addLast(new StringDecoder());
							sc.pipeline().addLast(new ServerHandler());
						}
					});					
					//4 绑定连接
					ChannelFuture cf = b.bind(8765).sync();					
					//等待服务器监听端口关闭
					cf.channel().closeFuture().sync();
					pGroup.shutdownGracefully();
					cGroup.shutdownGracefully();					
				}				
			}
			//ServerHandler
			public class ServerHandler extends ChannelHandlerAdapter {
				@Override
				public void channelActive(ChannelHandlerContext ctx) throws Exception {
					System.out.println(" server channel active... ");
				}
				@Override
				public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
					String request = (String)msg;//接收客户端数据是解码后的字符串数据
					System.out.println("Server :" + msg);
					String response = "服务器响应：" + msg + "$_";
					ctx.writeAndFlush(Unpooled.copiedBuffer(response.getBytes()));
				}
				@Override
				public void channelReadComplete(ChannelHandlerContext ctx) throws Exception {					
				}
				@Override
				public void exceptionCaught(ChannelHandlerContext ctx, Throwable t) throws Exception {
					ctx.close();
				}
			}
			//客户端
			public class Client {
				public static void main(String[] args) throws Exception {					
					EventLoopGroup group = new NioEventLoopGroup();					
					Bootstrap b = new Bootstrap();
					b.group(group)
					 .channel(NioSocketChannel.class)
					 .handler(new ChannelInitializer<SocketChannel>() {
						@Override
						protected void initChannel(SocketChannel sc) throws Exception {
							//同服务端
							ByteBuf buf = Unpooled.copiedBuffer("$_".getBytes());
							sc.pipeline().addLast(new DelimiterBasedFrameDecoder(1024, buf));
							sc.pipeline().addLast(new StringDecoder());
							sc.pipeline().addLast(new ClientHandler());
						}
					});					
					ChannelFuture cf = b.connect("127.0.0.1", 8765).sync();					
					cf.channel().writeAndFlush(Unpooled.wrappedBuffer("bbbb$_".getBytes()));
					cf.channel().writeAndFlush(Unpooled.wrappedBuffer("cccc$_".getBytes()));										
					//等待客户端端口关闭
					cf.channel().closeFuture().sync();
					group.shutdownGracefully();				
				}
			}
			//ClientHandler
			public class ClientHandler extends ChannelHandlerAdapter{
				@Override
				public void channelActive(ChannelHandlerContext ctx) throws Exception {
					System.out.println("client channel active... ");
				}
				@Override
				public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
					try {
						String response = (String)msg;
						System.out.println("Client: " + response);
					} finally {
						ReferenceCountUtil.release(msg);
					}
				}
				@Override
				public void channelReadComplete(ChannelHandlerContext ctx) throws Exception {
				}
				@Override
				public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {
					ctx.close();
				}
			}
			//案例分析二：
			//服务端
			public class Server {
				public static void main(String[] args) throws Exception{
					//1 创建2个线程，一个是负责接收客户端的连接。一个是负责进行数据传输的
					EventLoopGroup pGroup = new NioEventLoopGroup();
					EventLoopGroup cGroup = new NioEventLoopGroup();					
					//2 创建服务器辅助类
					ServerBootstrap b = new ServerBootstrap();
					b.group(pGroup, cGroup)
					 .channel(NioServerSocketChannel.class)
					 .option(ChannelOption.SO_BACKLOG, 1024)
					 .option(ChannelOption.SO_SNDBUF, 32*1024)
					 .option(ChannelOption.SO_RCVBUF, 32*1024)
					 .childHandler(new ChannelInitializer<SocketChannel>() {
						@Override
						protected void initChannel(SocketChannel sc) throws Exception {
							//设置定长字符串接收
							sc.pipeline().addLast(new FixedLengthFrameDecoder(5));
							//设置字符串形式的解码
							sc.pipeline().addLast(new StringDecoder());
							sc.pipeline().addLast(new ServerHandler());
						}
					});					
					//4 绑定连接
					ChannelFuture cf = b.bind(8765).sync();					
					//等待服务器监听端口关闭
					cf.channel().closeFuture().sync();
					pGroup.shutdownGracefully();
					cGroup.shutdownGracefully();					
				}				
			}
			//ServerHandler
			public class ServerHandler extends ChannelHandlerAdapter {
				@Override
				public void channelActive(ChannelHandlerContext ctx) throws Exception {
					System.out.println(" server channel active... ");
				}
				@Override
				public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
					String request = (String)msg;
					System.out.println("Server :" + msg);
					String response =  request ;
					ctx.writeAndFlush(Unpooled.copiedBuffer(response.getBytes()));
				}
				@Override
				public void channelReadComplete(ChannelHandlerContext ctx) throws Exception {					
				}
				@Override
				public void exceptionCaught(ChannelHandlerContext ctx, Throwable t) throws Exception {
				}
			}
			//客户端
			public class Client {
				public static void main(String[] args) throws Exception {					
					EventLoopGroup group = new NioEventLoopGroup();					
					Bootstrap b = new Bootstrap();
					b.group(group)
					 .channel(NioSocketChannel.class)
					 .handler(new ChannelInitializer<SocketChannel>() {
						@Override
						protected void initChannel(SocketChannel sc) throws Exception {
							sc.pipeline().addLast(new FixedLengthFrameDecoder(5));
							sc.pipeline().addLast(new StringDecoder());
							sc.pipeline().addLast(new ClientHandler());
						}
					});					
					ChannelFuture cf = b.connect("127.0.0.1", 8765).sync();					
					cf.channel().writeAndFlush(Unpooled.wrappedBuffer("aaaaabbbbb".getBytes()));
					cf.channel().writeAndFlush(Unpooled.copiedBuffer("ccccccc".getBytes()));					
					//等待客户端端口关闭
					cf.channel().closeFuture().sync();
					group.shutdownGracefully();					
				}
			}
			//ClientHandler
			public class ClientHandler extends ChannelHandlerAdapter{
				@Override
				public void channelActive(ChannelHandlerContext ctx) throws Exception {
					System.out.println("client channel active... ");
				}
				@Override
				public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
					String response = (String)msg;
					System.out.println("Client: " + response);
				}
				@Override
				public void channelReadComplete(ChannelHandlerContext ctx) throws Exception {
				}
				@Override
				public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {
				}
			}
		5、Netty编解码问题：
			含义：实质是Java序列化问题，目的：进行网络传输；对象持久化；
				可以使用对象序列化，但性能太低，一般使用编解码框架：Jboss的Marshalling包、google的Protobuf；
			案例分析：
			//服务端
			public class Server {
				public static void main(String[] args) throws Exception{
					//开启2个线程组
					EventLoopGroup pGroup = new NioEventLoopGroup();
					EventLoopGroup cGroup = new NioEventLoopGroup();
					//辅助工具类
					ServerBootstrap b = new ServerBootstrap();
					b.group(pGroup, cGroup)
					 .channel(NioServerSocketChannel.class)
					 .option(ChannelOption.SO_BACKLOG, 1024)
					 //设置日志级别
					 .handler(new LoggingHandler(LogLevel.INFO))
					 //初始化工作
					 .childHandler(new ChannelInitializer<SocketChannel>() {
						protected void initChannel(SocketChannel sc) throws Exception {
							//管道处理
							sc.pipeline().addLast(MarshallingCodeCFactory.buildMarshallingDecoder());//解码
							sc.pipeline().addLast(MarshallingCodeCFactory.buildMarshallingEncoder());//编码
							sc.pipeline().addLast(new ServerHandler());//处理业务逻辑
						}
					});					
					ChannelFuture cf = b.bind(8765).sync();
					//关闭资源
					cf.channel().closeFuture().sync();
					pGroup.shutdownGracefully();
					cGroup.shutdownGracefully();					
				}
			}
			//编解码工具类
			public final class MarshallingCodeCFactory {
				/**
				 * 创建Jboss Marshalling解码器MarshallingDecoder
				 * @return MarshallingDecoder
				 */
				public static MarshallingDecoder buildMarshallingDecoder() {
					//首先通过Marshalling工具类的精通方法获取Marshalling实例对象 参数serial标识创建的是java序列化工厂对象。
					final MarshallerFactory marshallerFactory = Marshalling.getProvidedMarshallerFactory("serial");
					//创建了MarshallingConfiguration对象，配置了版本号为5 
					final MarshallingConfiguration configuration = new MarshallingConfiguration();
					configuration.setVersion(5);
					//根据marshallerFactory和configuration创建provider
					UnmarshallerProvider provider = new DefaultUnmarshallerProvider(marshallerFactory, configuration);
					//构建Netty的MarshallingDecoder对象，俩个参数分别为provider和单个消息序列化后的最大长度
					MarshallingDecoder decoder = new MarshallingDecoder(provider, 1024 * 1024 * 1);
					return decoder;
				}
				/**
				 * 创建Jboss Marshalling编码器MarshallingEncoder
				 * @return MarshallingEncoder
				 */
				public static MarshallingEncoder buildMarshallingEncoder() {
					final MarshallerFactory marshallerFactory = Marshalling.getProvidedMarshallerFactory("serial");
					final MarshallingConfiguration configuration = new MarshallingConfiguration();
					configuration.setVersion(5);
					MarshallerProvider provider = new DefaultMarshallerProvider(marshallerFactory, configuration);
					//构建Netty的MarshallingEncoder对象，MarshallingEncoder用于实现序列化接口的POJO对象序列化为二进制数组
					MarshallingEncoder encoder = new MarshallingEncoder(provider);
					return encoder;
				}
			}
			//服务端业务逻辑处理，ServerHandler类
			public class ServerHandler extends ChannelHandlerAdapter{
				@Override
				public void channelActive(ChannelHandlerContext ctx) throws Exception {
				}
				@Override
				public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
					Req req = (Req)msg;
					System.out.println("Server : " + req.getId() + ", " + req.getName() + ", " + req.getRequestMessage());
					byte[] attachment = GzipUtils.ungzip(req.getAttachment());
					//程序所在的目录下的文件
					String path = System.getProperty("user.dir") + File.separatorChar + "receive" +  File.separatorChar + "001.jpg";
					FileOutputStream fos = new FileOutputStream(path);
					fos.write(attachment);
					fos.close();
					//服务端响应
					Resp resp = new Resp();
					resp.setId(req.getId());
					resp.setName("resp" + req.getId());
					resp.setResponseMessage("响应内容" + req.getId());
					ctx.writeAndFlush(resp);//.addListener(ChannelFutureListener.CLOSE);
				}
				@Override
				public void channelReadComplete(ChannelHandlerContext ctx) throws Exception {					
				}
				@Override
				public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {
					ctx.close();
				}								
			}
			//基础对象类：Req与Resp
			public class Req implements Serializable{
				private static final long  SerialVersionUID = 1L;				
				private String id;
				private String name;
				private String requestMessage;
				private byte[] attachment;				
				public String getId() {
					return id;
				}
				public void setId(String id) {
					this.id = id;
				}
				public String getName() {
					return name;
				}
				public void setName(String name) {
					this.name = name;
				}
				public String getRequestMessage() {
					return requestMessage;
				}
				public void setRequestMessage(String requestMessage) {
					this.requestMessage = requestMessage;
				}
				public byte[] getAttachment() {
					return attachment;
				}
				public void setAttachment(byte[] attachment) {
					this.attachment = attachment;
				}								
			}
			public class Resp implements Serializable{				
				private static final long serialVersionUID = 1L;				
				private String id;
				private String name;
				private String responseMessage;				
				public String getId() {
					return id;
				}
				public void setId(String id) {
					this.id = id;
				}
				public String getName() {
					return name;
				}
				public void setName(String name) {
					this.name = name;
				}
				public String getResponseMessage() {
					return responseMessage;
				}
				public void setResponseMessage(String responseMessage) {
					this.responseMessage = responseMessage;
				}				
			}
			//压缩/解压工具包
			public class GzipUtils {
				public static byte[] gzip(byte[] data) throws Exception{
					ByteArrayOutputStream bos = new ByteArrayOutputStream();
					GZIPOutputStream gzip = new GZIPOutputStream(bos);
					gzip.write(data);
					gzip.finish();
					gzip.close();
					byte[] ret = bos.toByteArray();
					bos.close();
					return ret;
				}				
				public static byte[] ungzip(byte[] data) throws Exception{
					ByteArrayInputStream bis = new ByteArrayInputStream(data);
					GZIPInputStream gzip = new GZIPInputStream(bis);
					byte[] buf = new byte[1024];
					int num = -1;
					ByteArrayOutputStream bos = new ByteArrayOutputStream();
					while((num = gzip.read(buf, 0 , buf.length)) != -1 ){
						bos.write(buf, 0, num);
					}
					gzip.close();
					bis.close();
					byte[] ret = bos.toByteArray();
					bos.flush();
					bos.close();
					return ret;
				}				
				public static void main(String[] args) throws Exception{					
					//读取文件
					String readPath = System.getProperty("user.dir") + File.separatorChar + "sources" +  File.separatorChar + "006.jpg";
					File file = new File(readPath);  
					FileInputStream in = new FileInputStream(file);  
					byte[] data = new byte[in.available()];  
					in.read(data);  
					in.close();  					
					System.out.println("文件原始大小:" + data.length);
					//测试压缩					
					byte[] ret1 = GzipUtils.gzip(data);
					System.out.println("压缩之后大小:" + ret1.length);					
					byte[] ret2 = GzipUtils.ungzip(ret1);
					System.out.println("还原之后大小:" + ret2.length);					
					//写出文件
					String writePath = System.getProperty("user.dir") + File.separatorChar + "receive" +  File.separatorChar + "006.jpg";
					FileOutputStream fos = new FileOutputStream(writePath);
					fos.write(ret2);
					fos.close();    											
				}												
			}
			//客户端
			public class Client {				
				public static void main(String[] args) throws Exception{					
					EventLoopGroup group = new NioEventLoopGroup();
					Bootstrap b = new Bootstrap();
					b.group(group)
					 .channel(NioSocketChannel.class)
					 .handler(new ChannelInitializer<SocketChannel>() {
						@Override
						protected void initChannel(SocketChannel sc) throws Exception {
							sc.pipeline().addLast(MarshallingCodeCFactory.buildMarshallingDecoder());
							sc.pipeline().addLast(MarshallingCodeCFactory.buildMarshallingEncoder());
							sc.pipeline().addLast(new ClientHandler());
						}
					});					
					ChannelFuture cf = b.connect("127.0.0.1", 8765).sync();					
					for(int i = 0; i < 5; i++ ){
						Req req = new Req();
						req.setId("" + i);
						req.setName("pro" + i);
						req.setRequestMessage("数据信息" + i);	
						String path = System.getProperty("user.dir") + File.separatorChar + "sources" +  File.separatorChar + "001.jpg";
						File file = new File(path);
						FileInputStream in = new FileInputStream(file);  
						byte[] data = new byte[in.available()];  
						in.read(data);  
						in.close(); 
						req.setAttachment(GzipUtils.gzip(data));
						cf.channel().writeAndFlush(req);
					}
					cf.channel().closeFuture().sync();
					group.shutdownGracefully();
				}
			}
			//ClientHandler
			public class ClientHandler extends ChannelHandlerAdapter{				
				@Override
				public void channelActive(ChannelHandlerContext ctx) throws Exception {					
				}
				@Override
				public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
					try {
						Resp resp = (Resp)msg;
						System.out.println("Client : " + resp.getId() + ", " + resp.getName() + ", " + resp.getResponseMessage());			
					} finally {
						ReferenceCountUtil.release(msg);
					}
				}
				@Override
				public void channelReadComplete(ChannelHandlerContext ctx) throws Exception {					
				}
				@Override
				public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {
					ctx.close();
				}				
			}
		6、数据通讯
		   含义：在实际工作中，多台机器可以通过netty通讯，对于参数的设置取决于服务器性能，具体通讯方式可以分为三类：
				a、使用长连接，客户端与服务端一直处于开启连接转态，对服务器的性能要求比较高，而且适用于客户端数量较少的情况，业务场景：滴滴打车
				b、使用短链接，客户端一次批量的提交数据，客户端会把数据临时存储在缓存区或临时表中，当条件满足阈值时，才与服务端连接，提交数据，弊端：不能实时的提交数据
				c、特殊的长连接，规定在一定时间内两者没有通讯，则断开连接，下次连接客户端向服务端发起连接请求，建立连接；但需要注意2个因素：
					超时如何关闭通讯，以及后续如何建立连接；服务端宕机，客户端如何与服务端进行连接（方案：客户端使用job任务，定时检测）；
			案例分析：
				//服务端
			public class Server {
				public static void main(String[] args) throws Exception{
					//开启2个线程组
					EventLoopGroup pGroup = new NioEventLoopGroup();
					EventLoopGroup cGroup = new NioEventLoopGroup();
					//辅助类
					ServerBootstrap b = new ServerBootstrap();
					b.group(pGroup, cGroup)
					 .channel(NioServerSocketChannel.class)
					 .option(ChannelOption.SO_BACKLOG, 1024)
					 //设置日志
					 .handler(new LoggingHandler(LogLevel.INFO))
					 .childHandler(new ChannelInitializer<SocketChannel>() {
						protected void initChannel(SocketChannel sc) throws Exception {
							//管道链
							sc.pipeline().addLast(MarshallingCodeCFactory.buildMarshallingDecoder());
							sc.pipeline().addLast(MarshallingCodeCFactory.buildMarshallingEncoder());
							//设置服务端与客户端超时断开连接时间：5s
							sc.pipeline().addLast(new ReadTimeoutHandler(5)); 
							sc.pipeline().addLast(new ServerHandler());
						}
					});					
					ChannelFuture cf = b.bind(8765).sync();
					//关闭通道 
					cf.channel().closeFuture().sync();
					pGroup.shutdownGracefully();
					cGroup.shutdownGracefully();					
				}
			}
			//JavaBean类
			public class Request implements Serializable{
				private static final long  SerialVersionUID = 1L;				
				private String id;
				private String name;
				private String requestMessage;				
				public String getId() {
					return id;
				}
				public void setId(String id) {
					this.id = id;
				}
				public String getName() {
					return name;
				}
				public void setName(String name) {
					this.name = name;
				}
				public String getRequestMessage() {
					return requestMessage;
				}
				public void setRequestMessage(String requestMessage) {
					this.requestMessage = requestMessage;
				}
			}
			public class Response implements Serializable{				
				private static final long serialVersionUID = 1L;				
				private String id;
				private String name;
				private String responseMessage;				
				public String getId() {
					return id;
				}
				public void setId(String id) {
					this.id = id;
				}
				public String getName() {
					return name;
				}
				public void setName(String name) {
					this.name = name;
				}
				public String getResponseMessage() {
					return responseMessage;
				}
				public void setResponseMessage(String responseMessage) {
					this.responseMessage = responseMessage;
				}				
			}
			//MarshallingCodeCFactory类同上
			//ServerHandler
			public class ServerHandler extends ChannelHandlerAdapter{
				@Override
				public void channelActive(ChannelHandlerContext ctx) throws Exception {
				}
				@Override
				public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
					Request request = (Request)msg;
					System.out.println("Server : " + request.getId() + ", " + request.getName() + ", " + request.getRequestMessage());
					Response response = new Response();
					response.setId(request.getId());
					response.setName("response" + request.getId());
					response.setResponseMessage("响应内容" + request.getId());
					ctx.writeAndFlush(response);//.addListener(ChannelFutureListener.CLOSE);
				}
				@Override
				public void channelReadComplete(ChannelHandlerContext ctx) throws Exception {					
				}
				@Override
				public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {
					ctx.close();
				}								
			}
			//客户端
			public class Client {
				//单例获取实例对象
				private static class SingletonHolder {
					static final Client instance = new Client();
				}				
				public static Client getInstance(){
					return SingletonHolder.instance;
				}
				//建立辅助类
				private EventLoopGroup group;
				private Bootstrap b;
				private ChannelFuture cf;				
				private Client(){
						group = new NioEventLoopGroup();
						b = new Bootstrap();
						b.group(group)
						 .channel(NioSocketChannel.class)
						 .handler(new LoggingHandler(LogLevel.INFO))
						 .handler(new ChannelInitializer<SocketChannel>() {
								@Override
								protected void initChannel(SocketChannel sc) throws Exception {
									sc.pipeline().addLast(MarshallingCodeCFactory.buildMarshallingDecoder());
									sc.pipeline().addLast(MarshallingCodeCFactory.buildMarshallingEncoder());
									//超时handler（当服务器端与客户端在指定时间以上没有任何进行通信，则会关闭响应的通道，主要为减小服务端资源占用）
									sc.pipeline().addLast(new ReadTimeoutHandler(5)); 
									sc.pipeline().addLast(new ClientHandler());
								}
						});
				}				
				public void connect(){
					try {
						this.cf = b.connect("127.0.0.1", 8765).sync();//寻址连接
						System.out.println("远程服务器已经连接, 可以进行数据交换..");				
					} catch (Exception e) {
						e.printStackTrace();
					}
				}
				//获取ChannelFuture对象
				public ChannelFuture getChannelFuture(){					
					if(this.cf == null){
						this.connect();
					}
					if(!this.cf.channel().isActive()){
						this.connect();
					}					
					return this.cf;
				}				
				public static void main(String[] args) throws Exception{
					final Client c = Client.getInstance();
					//c.connect();					
					ChannelFuture cf = c.getChannelFuture();
					for(int i = 1; i <= 3; i++ ){
						Request request = new Request();
						request.setId("" + i);
						request.setName("pro" + i);
						request.setRequestMessage("数据信息" + i);
						cf.channel().writeAndFlush(request);
						//间隔4S写入数据
						TimeUnit.SECONDS.sleep(4);
					}
					cf.channel().closeFuture().sync();					
					//模拟客户端连接服务器
					new Thread(new Runnable() {
						@Override
						public void run() {
							try {
								System.out.println("进入子线程...");
								ChannelFuture cf = c.getChannelFuture();
								System.out.println(cf.channel().isActive());
								System.out.println(cf.channel().isOpen());								
								//再次发送数据
								Request request = new Request();
								request.setId("" + 4);
								request.setName("pro" + 4);
								request.setRequestMessage("数据信息" + 4);
								cf.channel().writeAndFlush(request);					
								cf.channel().closeFuture().sync();
								System.out.println("子线程结束.");
							} catch (InterruptedException e) {
								e.printStackTrace();
							}
						}
					}).start();					
					System.out.println("断开连接,主线程结束..");					
				}											
			}
			//ClientHandler
			public class ClientHandler extends ChannelHandlerAdapter{				
				@Override
				public void channelActive(ChannelHandlerContext ctx) throws Exception {
				}
				@Override
				public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
					try {
						Response resp = (Response)msg;
						System.out.println("Client : " + resp.getId() + ", " + resp.getName() + ", " + resp.getResponseMessage());			
					} finally {
						//只做读取操作，没有写数据需要释放消息
						ReferenceCountUtil.release(msg);
					}
				}
				@Override
				public void channelReadComplete(ChannelHandlerContext ctx) throws Exception {					
				}
				@Override
				public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {
					ctx.close();
				}				
			}
		7、心跳检测
			含义：在服务器集群之间需要进行心跳检测，基于Master-Slaver模式，监控各个服务器节点的各个方面情况（CPU、磁盘、网络），把这样的过程叫心跳检测；
			案例分析（利用netty与sigar相关技术实现心跳检测）：
			//服务端
			public class Server {
				public static void main(String[] args) throws Exception{					
					EventLoopGroup pGroup = new NioEventLoopGroup();
					EventLoopGroup cGroup = new NioEventLoopGroup();					
					ServerBootstrap b = new ServerBootstrap();
					b.group(pGroup, cGroup)
					 .channel(NioServerSocketChannel.class)
					 .option(ChannelOption.SO_BACKLOG, 1024)
					 //设置日志
					 .handler(new LoggingHandler(LogLevel.INFO))
					 .childHandler(new ChannelInitializer<SocketChannel>() {
						protected void initChannel(SocketChannel sc) throws Exception {
							sc.pipeline().addLast(MarshallingCodeCFactory.buildMarshallingDecoder());
							sc.pipeline().addLast(MarshallingCodeCFactory.buildMarshallingEncoder());
							//心跳检测类
							sc.pipeline().addLast(new ServerHeartBeatHandler());
						}
					});					
					ChannelFuture cf = b.bind(8765).sync();					
					cf.channel().closeFuture().sync();
					pGroup.shutdownGracefully();
					cGroup.shutdownGracefully();					
				}
			}
			//ServerHeartBeatHandler类
			public class ServerHeartBeatHandler extends ChannelHandlerAdapter {				
				private static HashMap<String, String> AUTH_IP_MAP = new HashMap<String, String>();
				private static final String SUCCESS_KEY = "auth_success_key";				
				static {
					AUTH_IP_MAP.put("192.168.1.200", "1234");
				}				
				private boolean auth(ChannelHandlerContext ctx, Object msg){
						//System.out.println(msg);
						//从客户端取到的信息
						String [] ret = ((String) msg).split(",");
						String auth = AUTH_IP_MAP.get(ret[0]);
						if(auth != null && auth.equals(ret[1])){
							ctx.writeAndFlush(SUCCESS_KEY);//认证通过
							return true;
						} else {
							ctx.writeAndFlush("auth failure !").addListener(ChannelFutureListener.CLOSE);
							return false;
						}
				}				
				@Override
				public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
					if(msg instanceof String){
						//首次认证
						auth(ctx, msg);
					} else if (msg instanceof RequestInfo) {						
						RequestInfo info = (RequestInfo) msg;
						System.out.println("--------------------------------------------");
						System.out.println("当前主机ip为: " + info.getIp());
						System.out.println("当前主机cpu情况: ");
						HashMap<String, Object> cpu = info.getCpuPercMap();
						System.out.println("总使用率: " + cpu.get("combined"));
						System.out.println("用户使用率: " + cpu.get("user"));
						System.out.println("系统使用率: " + cpu.get("sys"));
						System.out.println("等待率: " + cpu.get("wait"));
						System.out.println("空闲率: " + cpu.get("idle"));
						
						System.out.println("当前主机memory情况: ");
						HashMap<String, Object> memory = info.getMemoryMap();
						System.out.println("内存总量: " + memory.get("total"));
						System.out.println("当前内存使用量: " + memory.get("used"));
						System.out.println("当前内存剩余量: " + memory.get("free"));
						System.out.println("--------------------------------------------");
						//响应数据
						ctx.writeAndFlush("info received!");
					} else {
						ctx.writeAndFlush("connect failure!").addListener(ChannelFutureListener.CLOSE);
					}
				}
			}
			//客户端
			public class Client {				
				public static void main(String[] args) throws Exception{					
					EventLoopGroup group = new NioEventLoopGroup();
					Bootstrap b = new Bootstrap();
					b.group(group)
					 .channel(NioSocketChannel.class)
					 .handler(new ChannelInitializer<SocketChannel>() {
						@Override
						protected void initChannel(SocketChannel sc) throws Exception {
							sc.pipeline().addLast(MarshallingCodeCFactory.buildMarshallingDecoder());
							sc.pipeline().addLast(MarshallingCodeCFactory.buildMarshallingEncoder());
							//心跳检测类
							sc.pipeline().addLast(new ClienHeartBeattHandler());
						}
					});
					//寻址连接
					ChannelFuture cf = b.connect("127.0.0.1", 8765).sync();
					cf.channel().closeFuture().sync();
					group.shutdownGracefully();
				}
			}
			//ClienHeartBeattHandler
			public class ClienHeartBeattHandler extends ChannelHandlerAdapter {
				//池化技术，特点是可以定时执行任务
				private ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(1);				
				private ScheduledFuture<?> heartBeat;
				//主动向服务器发送认证信息
				private InetAddress addr;				
				private static final String SUCCESS_KEY = "auth_success_key";
				@Override
				public void channelActive(ChannelHandlerContext ctx) throws Exception {
					addr = InetAddress.getLocalHost();
					String ip = addr.getHostAddress();
					String key = "1234";
					//证书，由两部分构成：IP与KEY
					String auth = ip + "," + key;
					//写出
					ctx.writeAndFlush(auth);
				}				
				@Override
				public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
					try {
						if(msg instanceof String){
							String ret = (String)msg;
							if(SUCCESS_KEY.equals(ret)){
								// 握手成功，主动发送心跳消息，每2S执行一次任务
								this.heartBeat = this.scheduler.scheduleWithFixedDelay(new HeartBeatTask(ctx), 0, 2, TimeUnit.SECONDS);
								System.out.println(msg);    			
							}
							else {
								System.out.println(msg);
							}
						}
					} finally {
						ReferenceCountUtil.release(msg);
					}
				}
				//线程任务
				private class HeartBeatTask implements Runnable {
					private final ChannelHandlerContext ctx;
					public HeartBeatTask(final ChannelHandlerContext ctx) {
						this.ctx = ctx;
					}				
					@Override
					public void run() {
						try {
							RequestInfo info = new RequestInfo();
							//ip
							info.setIp(addr.getHostAddress());
							Sigar sigar = new Sigar();
							//cpu prec
							CpuPerc cpuPerc = sigar.getCpuPerc();
							HashMap<String, Object> cpuPercMap = new HashMap<String, Object>();
							cpuPercMap.put("combined", cpuPerc.getCombined());
							cpuPercMap.put("user", cpuPerc.getUser());
							cpuPercMap.put("sys", cpuPerc.getSys());
							cpuPercMap.put("wait", cpuPerc.getWait());
							cpuPercMap.put("idle", cpuPerc.getIdle());
							// memory
							Mem mem = sigar.getMem();
							HashMap<String, Object> memoryMap = new HashMap<String, Object>();
							memoryMap.put("total", mem.getTotal() / 1024L);
							memoryMap.put("used", mem.getUsed() / 1024L);
							memoryMap.put("free", mem.getFree() / 1024L);
							info.setCpuPercMap(cpuPercMap);
							info.setMemoryMap(memoryMap);
							ctx.writeAndFlush(info);
							
						} catch (Exception e) {
							e.printStackTrace();
						}
					}
					public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {
						cause.printStackTrace();
						if (heartBeat != null) {
							heartBeat.cancel(true);
							heartBeat = null;
						}
						ctx.fireExceptionCaught(cause);
					}					
				}
			}
			//JavaBean类
			public class RequestInfo implements Serializable {
				private String ip ;
				private HashMap<String, Object> cpuPercMap ;
				private HashMap<String, Object> memoryMap;				
				public String getIp() {
					return ip;
				}
				public void setIp(String ip) {
					this.ip = ip;
				}
				public HashMap<String, Object> getCpuPercMap() {
					return cpuPercMap;
				}
				public void setCpuPercMap(HashMap<String, Object> cpuPercMap) {
					this.cpuPercMap = cpuPercMap;
				}
				public HashMap<String, Object> getMemoryMap() {
					return memoryMap;
				}
				public void setMemoryMap(HashMap<String, Object> memoryMap) {
					this.memoryMap = memoryMap;
				}								
			}
		8、基于Http协议实现上传/下载（了解即可，实现文件的上传与下载可以使用专业的框架：如FastDfs、HDFs）
			Http协议的认识：超文本传输协议，是基于TCP协议之上的运用层协议，主要用于WEB开发；Netty下的Http也是异步非阻塞的，Http协议特点：简单（使用简单、在URL中携带必要参数即可）、
			灵活（支持任意类型的数据对象）、无状态（对事务处理没有记忆能力、即想获取之前的信息必须重新请求）；构成：请求行、请求头、请求体组成；
			请求方式：GET、POST、HEAD、PUT、DELETE、TRACE、CONNECT、OPTINS
			响应码：
				1XX：提示信息；2XX：成功；3XX：重定向；4XX:客户端错误；5XX:服务端错误；
				常见状态码：200 OK、400 Bad Request（语法不对）、401 Unauthorized（未授权）、403 Forbidden（服务器拒绝）、404 Not Fund（找不到）、405 Method Not Allowed（请求方式不被允许）
							500 Inernal Server Error（服务器内部错误）、503 Server Unavailable （服务当前不可用）；
			案例分析：（Netty实现文件上传核心利用的是chuck分片断点续传技术）		
			#与Http的整合例子
			public final class HttpHelloWorldServer {
				  //安全验证
				  static final boolean SSL = System.getProperty("ssl") != null;
				  static final int PORT = Integer.parseInt(System.getProperty("port", SSL? "8443" : "8080"));			  
				  public static void main(String[] args) throws Exception {
					  //配置SSL
					  final SslContext sslCtx;
					  if (SSL) {
						  SelfSignedCertificate ssc = new SelfSignedCertificate();
						  sslCtx = SslContext.newServerContext(ssc.certificate(), ssc.privateKey());
					  } else {
						  sslCtx = null;
					  }			  
					  //配置服务端
					  EventLoopGroup bossGroup = new NioEventLoopGroup(1);
					  EventLoopGroup workerGroup = new NioEventLoopGroup();
					  try {
						  ServerBootstrap b = new ServerBootstrap();
						  b.option(ChannelOption.SO_BACKLOG, 1024);
						  b.group(bossGroup, workerGroup)
						   .channel(NioServerSocketChannel.class)
						   .handler(new LoggingHandler(LogLevel.INFO))
						   .childHandler(new HttpHelloWorldServerInitializer(sslCtx));			  
						  Channel ch = b.bind(PORT).sync().channel();			  
						  System.err.println("Open your web browser and navigate to " +
								  (SSL? "https" : "http") + "://127.0.0.1:" + PORT + '/');			  
						  ch.closeFuture().sync();
					  } finally {
						  bossGroup.shutdownGracefully();
						  workerGroup.shutdownGracefully();
					  }
				  }				  				  
			}
			#HttpHelloWorldServerInitializer
			public class HttpHelloWorldServerInitializer extends ChannelInitializer<SocketChannel> {			  
				  private final SslContext sslCtx;			  
				  public HttpHelloWorldServerInitializer(SslContext sslCtx) {
					 this.sslCtx = sslCtx;
				  }			  
				  @Override
				  public void initChannel(SocketChannel ch) {
					  ChannelPipeline p = ch.pipeline();
					  if (sslCtx != null) {
						  p.addLast(sslCtx.newHandler(ch.alloc()));
					  }
					  //管道链
					  p.addLast(new HttpServerCodec());
					  p.addLast(new HttpHelloWorldServerHandler());
				  }
			  }
			  public class HttpHelloWorldServerHandler extends ChannelHandlerAdapter {
				  //连接OK，响应标识
				  private static final byte[] CONTENT = { 'H', 'e', 'l', 'l', 'o', ' ', 'W', 'o', 'r', 'l', 'd' };			  
				  @Override
				  public void channelReadComplete(ChannelHandlerContext ctx) {
					  ctx.flush();
				  }			  
				  @Override
				  public void channelRead(ChannelHandlerContext ctx, Object msg) {
					  if (msg instanceof HttpRequest) {
						  HttpRequest req = (HttpRequest) msg;			  
						  if (HttpHeaderUtil.is100ContinueExpected(req)) {
							  ctx.write(new DefaultFullHttpResponse(HTTP_1_1, CONTINUE));
						  }
						  boolean keepAlive = HttpHeaderUtil.isKeepAlive(req);
						  FullHttpResponse response = new DefaultFullHttpResponse(HTTP_1_1, OK, Unpooled.wrappedBuffer(CONTENT));
						  response.headers().set(CONTENT_TYPE, "text/plain");
						  response.headers().setInt(CONTENT_LENGTH, response.content().readableBytes());			  
						  if (!keepAlive) {
							  ctx.write(response).addListener(ChannelFutureListener.CLOSE);
						  } else {
							  response.headers().set(CONNECTION, HttpHeaderValues.KEEP_ALIVE);
							  ctx.write(response);
						  }
					  }
				  }			  
				  @Override
				  public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {
					  cause.printStackTrace();
					  ctx.close();
				  }
			  }
			  #注：浏览器访问:127.0.0.1:8080，页面出现Hello Word，说明netty与http配置成功！
			  #FileList列表
			  public class HttpFileServer {
				private static final String DEFAULT_URL = "/sources/";
				public void run(final int port, final String url) throws Exception {
					EventLoopGroup bossGroup = new NioEventLoopGroup();
					EventLoopGroup workerGroup = new NioEventLoopGroup();
					try {
						ServerBootstrap b = new ServerBootstrap();
						b.group(bossGroup, workerGroup)
							.channel(NioServerSocketChannel.class)
							.childHandler(new ChannelInitializer<SocketChannel>() {
							@Override
							protected void initChannel(SocketChannel ch)
								throws Exception {
								// 加入http的解码器
								ch.pipeline().addLast("http-decoder", new HttpRequestDecoder());
								// 加入ObjectAggregator解码器，作用是他会把多个消息转换为单一的FullHttpRequest或者FullHttpResponse
								ch.pipeline().addLast("http-aggregator", new HttpObjectAggregator(65536));
								// 加入http的编码器
								ch.pipeline().addLast("http-encoder", new HttpResponseEncoder());
								// 加入chunked 主要作用是支持异步发送的码流（大文件传输），但不专用过多的内存，防止java内存溢出
								ch.pipeline().addLast("http-chunked", new ChunkedWriteHandler());
								// 加入自定义处理文件服务器的业务逻辑handler
								ch.pipeline().addLast("fileServerHandler",new HttpFileServerHandler(url));									
							}
							});
						ChannelFuture future = b.bind("192.168.1.200", port).sync();
						System.out.println("HTTP文件目录服务器启动，网址是 : " + "http://192.168.1.200:"  + port + url);
						future.channel().closeFuture().sync();
					} finally {
						bossGroup.shutdownGracefully();
						workerGroup.shutdownGracefully();
					}
				}
				public static void main(String[] args) throws Exception {
					int port = 8765;
					String url = DEFAULT_URL;
					new HttpFileServer().run(port, url);
				}
			}
			public class HttpFileServerHandler extends SimpleChannelInboundHandler<FullHttpRequest> {				
				private final String url;
				public HttpFileServerHandler(String url) {
					this.url = url;
				}
				@Override
				public void messageReceived(ChannelHandlerContext ctx, FullHttpRequest request) throws Exception {
					//对请求的解码结果进行判断：
					if (!request.decoderResult().isSuccess()) {
						// 400
						sendError(ctx, BAD_REQUEST);
						return;
					}
					//对请求方式进行判断：如果不是get方式（如post方式）则返回异常
					if (request.method() != GET) {
						// 405
						sendError(ctx, METHOD_NOT_ALLOWED);
						return;
					}
					//获取请求uri路径
					final String uri = request.uri();
					//对url进行分析，返回本地系统
					final String path = sanitizeUri(uri);
					//如果 路径构造不合法，则path为null
					if (path == null) {
						//403
						sendError(ctx, FORBIDDEN);
						return;
					}
					// 创建file对象
					File file = new File(path);
					// 判断文件是否为隐藏或者不存在
					if (file.isHidden() || !file.exists()) {
						// 404 
						sendError(ctx, NOT_FOUND);
						return;
					}
					// 如果为文件夹
					if (file.isDirectory()) {
						if (uri.endsWith("/")) {
							//如果以正常"/"结束 说明是访问的一个文件目录：则进行展示文件列表（web服务端则可以跳转一个Controller，遍历文件并跳转到一个页面）
							sendListing(ctx, file);
						} else {
							//如果非"/"结束 则重定向，补全"/" 再次请求
							sendRedirect(ctx, uri + '/');
						}
						return;
					}
					// 如果所创建的file对象不是文件类型
					if (!file.isFile()) {
						// 403
						sendError(ctx, FORBIDDEN);
						return;
					}					
					//随机文件读写类
					RandomAccessFile randomAccessFile = null;
					try {
						randomAccessFile = new RandomAccessFile(file, "r");// 以只读的方式打开文件
					} catch (FileNotFoundException fnfe) {
						// 404
						sendError(ctx, NOT_FOUND);
						return;
					}					
					//获取文件长度
					long fileLength = randomAccessFile.length();
					//建立响应对象
					HttpResponse response = new DefaultHttpResponse(HTTP_1_1, OK);
					//设置响应信息
					HttpHeaderUtil.setContentLength(response, fileLength);
					//设置响应头
					setContentTypeHeader(response, file);
					//如果一直保持连接则设置响应头信息为：HttpHeaders.Values.KEEP_ALIVE
					if (HttpHeaderUtil.isKeepAlive(request)) {
						response.headers().set(CONNECTION, HttpHeaderValues.KEEP_ALIVE);
					}
					//进行写出
					ctx.write(response);					
					//构造发送文件线程，将文件写入到Chunked缓冲区中
					ChannelFuture sendFileFuture;
					//写出ChunkedFile
					sendFileFuture = ctx.write(new ChunkedFile(randomAccessFile, 0, fileLength, 8192), ctx.newProgressivePromise());
					//添加传输监听，文件上传进度监听
					sendFileFuture.addListener(new ChannelProgressiveFutureListener() {
						@Override
						public void operationProgressed(ChannelProgressiveFuture future, long progress, long total) {
							if (total < 0) { // total unknown
								System.err.println("Transfer progress: " + progress);
							} else {
								System.err.println("Transfer progress: " + progress + " / " + total);
							}
						}
						@Override
						public void operationComplete(ChannelProgressiveFuture future) throws Exception {
							System.out.println("Transfer complete.");
						}
					});					
					//如果使用Chunked编码，最后则需要发送一个编码结束的看空消息体，进行标记，表示所有消息体已经成功发送完成。
					ChannelFuture lastContentFuture = ctx.writeAndFlush(LastHttpContent.EMPTY_LAST_CONTENT);
					//如果当前连接请求非Keep-Alive ，最后一包消息发送完成后 服务器主动关闭连接
					if (!HttpHeaderUtil.isKeepAlive(request)) {
						lastContentFuture.addListener(ChannelFutureListener.CLOSE);
					}
				}
				@Override
				public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {
					if (ctx.channel().isActive()) {
						sendError(ctx, INTERNAL_SERVER_ERROR);
						ctx.close();
					}
				}
				//非法URI正则
				private static final Pattern INSECURE_URI = Pattern.compile(".*[<>&\"].*");
				/**
				 * <B>方法名称：</B>解析URI<BR>
				 * <B>概要说明：</B>对URI进行分析<BR>
				 * @param uri netty包装后的字符串对象
				 * @return path 解析结果
				 */
				private String sanitizeUri(String uri) {
					try {
						//使用UTF-8字符集
						uri = URLDecoder.decode(uri, "UTF-8");
					} catch (UnsupportedEncodingException e) {
						try {
							//尝试ISO-8859-1
							uri = URLDecoder.decode(uri, "ISO-8859-1");
						} catch (UnsupportedEncodingException e1) {
							//抛出预想外异常信息
							throw new Error();
						}
					}
					// 对uri进行细粒度判断：4步验证操作
					// step 1 基础验证
					if (!uri.startsWith(url)) {
						return null;
					}
					// step 2 基础验证
					if (!uri.startsWith("/")) {
						return null;
					}
					// step 3 将文件分隔符替换为本地操作系统的文件路径分隔符
					uri = uri.replace('/', File.separatorChar);
					// step 4 二次验证合法性
					if (uri.contains(File.separator + '.')
						|| uri.contains('.' + File.separator) || uri.startsWith(".")
						|| uri.endsWith(".") || INSECURE_URI.matcher(uri).matches()) {
						return null;
					}
					//当前工程所在目录 + URI构造绝对路径进行返回 
					return System.getProperty("user.dir") + File.separator + uri;
				}				
				//文件是否被允许访问下载验证
				private static final Pattern ALLOWED_FILE_NAME = Pattern.compile("[A-Za-z0-9][-_A-Za-z0-9\\.]*");
				private static void sendListing(ChannelHandlerContext ctx, File dir) {
					// 设置响应对象
					FullHttpResponse response = new DefaultFullHttpResponse(HTTP_1_1, OK);
					// 响应头
					response.headers().set(CONTENT_TYPE, "text/html; charset=UTF-8");
					// 追加文本内容
					StringBuilder ret = new StringBuilder();
					String dirPath = dir.getPath();
					ret.append("<!DOCTYPE html>\r\n");
					ret.append("<html><head><title>");
					ret.append(dirPath);
					ret.append(" 目录：");
					ret.append("</title></head><body>\r\n");
					ret.append("<h3>");
					ret.append(dirPath).append(" 目录：");
					ret.append("</h3>\r\n");
					ret.append("<ul>");
					ret.append("<li>链接：<a href=\"../\">..</a></li>\r\n");					
					// 遍历文件 添加超链接
					for (File f : dir.listFiles()) {
						//step 1: 跳过隐藏或不可读文件 
						if (f.isHidden() || !f.canRead()) {
							continue;
						}
						String name = f.getName();
						//step 2: 如果不被允许，则跳过此文件
						if (!ALLOWED_FILE_NAME.matcher(name).matches()) {
							continue;
						}
						//拼接超链接即可
						ret.append("<li>链接：<a href=\"");
						ret.append(name);
						ret.append("\">");
						ret.append(name);
						ret.append("</a></li>\r\n");
					}
					ret.append("</ul></body></html>\r\n");
					//构造结构，写入缓冲区
					ByteBuf buffer = Unpooled.copiedBuffer(ret, CharsetUtil.UTF_8);
					//进行写出操作
					response.content().writeBytes(buffer);
					//重置写出区域
					buffer.release();
					//使用ctx对象写出并且刷新到SocketChannel中去 并主动关闭连接(这里是指关闭处理发送数据的线程连接)
					ctx.writeAndFlush(response).addListener(ChannelFutureListener.CLOSE);
				}
				//重定向操作
				private static void sendRedirect(ChannelHandlerContext ctx, String newUri) {
					//建立响应对象
					FullHttpResponse response = new DefaultFullHttpResponse(HTTP_1_1, FOUND);
					//设置新的请求地址放入响应对象中去
					response.headers().set(LOCATION, newUri);
					//使用ctx对象写出并且刷新到SocketChannel中去 并主动关闭连接(这里是指关闭处理发送数据的线程连接)
					ctx.writeAndFlush(response).addListener(ChannelFutureListener.CLOSE);
				}
				//错误信息
				private static void sendError(ChannelHandlerContext ctx, HttpResponseStatus status) {
					//建立响应对象
					FullHttpResponse response = new DefaultFullHttpResponse(HTTP_1_1, status, Unpooled.copiedBuffer("Failure: " + status.toString()+ "\r\n", CharsetUtil.UTF_8));
					//设置响应头信息
					response.headers().set(CONTENT_TYPE, "text/plain; charset=UTF-8");
					//使用ctx对象写出并且刷新到SocketChannel中去 并主动关闭连接(这里是指关闭处理发送数据的线程连接)
					ctx.writeAndFlush(response).addListener(ChannelFutureListener.CLOSE);
				}
				private static void setContentTypeHeader(HttpResponse response, File file) {
					//使用mime对象获取文件类型
					MimetypesFileTypeMap mimeTypesMap = new MimetypesFileTypeMap();
					response.headers().set(CONTENT_TYPE, mimeTypesMap.getContentType(file.getPath()));
				}
			}			  
----------------------------------------------Java高级篇之数据结构与算法---------------------------------------------------------------------------------------------------------
		一、	
			
----------------------------------------------Java高级篇之JVM虚拟机优化篇----------------------------------------------------------------------------------------------------------		
	一、VM含义：
		虚拟机：虚拟的机器，是一款软件，用于执行虚拟计算机指令，可以分为系统虚拟机与程序虚拟机。
				系统虚拟机有：Visual Box、VMare，使用时注意三种网络适配器的模式（主机模式（JVM不能访问外网）、NAT网络地址转化模式（宿主机与主机在不同的网段）、桥接模式（同一网段、可能会造成IP地址冲突））
				程序虚拟机有：典型的Java虚拟机（JVM）		
	二、JVM：
		基本结构：
			类加载子系统（加载.class的编译文件）、方法区（类、静态常量以及方法、池的概念，线程共享的，永久区）、Java堆（存储对象实例，线程共享的）、直接内存（epoll机制处理、NIO 2.0（异步）读写）、Java栈（存储变量、对象引用，独享一块线程）、本地方法栈、垃圾回收系统（GC机制、核心）、
			PC寄存器（指针计数作用）、执行引擎（执行Java代码）
		需要掌握的地方：
			1、堆、栈、方法区的概念与联系
				堆：存储对象实例，解决数据存储问题，数据怎么放、怎么存；主要是对象实例；共享线程；
				栈：解决程序运行问题，即程序如何运行，如何处理数据；主要存变量、对象引用，独占一块线程；
				方法区：一块永久区，是先决条件；存储类信息、静态方法以及常量，池的概念，共享的区域；
			2、底层情况：
				堆：几乎所有对象实例都存放在堆里面，而且堆是完全自动化管理的，即通过垃圾回收机制（GC），垃圾对象自动清理；根据GC机制不同，堆的结构也不同，分为新生代与老年代。
					新生代指的是新生的对象或年龄不大的对象，而老年代指的是老年的对象。
					新生代细分可以分为eden区、s0区（from区）与s1区（to区），而且s0区与s1区是大小相同可以相互转换角色的区域。
					新创建的对象先进入eden区，经过一次的GC清理后会进入s0区或s1区（涉及到复制算法概念），经过多轮的GC之后（默认15次），绝大多数对象会被清洗掉，剩下来的最终会进入老年区。
				栈：是一块线程私有的内存空间，一般由三部分组成：
					局部变量表：存放的是局部变量
					操作数栈：保存的是计算的中间过程（Temp）
					帧数据区：保存访问常量池的指针，异常处理表也是一部分
				方法区：一块线程共享的区域，存储类的信息，包括：类的字段、方法、常量池等
		虚拟机参数：
			主要围绕堆、栈、方法区进行配置
			1、堆的参数设置：
				基本概念：
					-XX：属于系统级别（JVM）的配置，可以配置日志信息、以及JVM使用什么样的垃圾回收器
					非-XX：属于应用级别的配置；
					+：启用
					-：禁用
				常见参数解析：
					-XX:+PrintGC：虚拟机启动后，会打印GC的日志信息
					-XX:+UseSerialGC：使用串行回收器
					-XX:+PrintGCDetails：打印详细的信息，包括各区情况（新生代、老年代）
					-Xms：设置Java程序初始化堆大小
					-Xmx：设置Java程序最大堆大小
					-Xmx20m -Xms5m -XX:+PrintCommandLineFlags：将显示或隐式的传给虚拟机的参数打印输出
					总结：实际工作中，将初始堆大小与最大的堆大小设置相同，可以减少程序运行时垃圾回收GC次数，从而提高系统性能
					案例说明：
					public class Test01 {
						public static void main(String[] args) {
							//-Xms5m -Xmx20m -XX:+PrintGCDetails -XX:+UseSerialGC -XX:+PrintCommandLineFlags							
							//查看GC信息
							System.out.println("max memory:" + Runtime.getRuntime().maxMemory());
							System.out.println("free memory:" + Runtime.getRuntime().freeMemory());
							System.out.println("total memory:" + Runtime.getRuntime().totalMemory());							
							byte[] b1 = new byte[1*1024*1024];
							System.out.println("分配了1M");
							System.out.println("max memory:" + Runtime.getRuntime().maxMemory());
							System.out.println("free memory:" + Runtime.getRuntime().freeMemory());
							System.out.println("total memory:" + Runtime.getRuntime().totalMemory());							
							byte[] b2 = new byte[4*1024*1024];
							System.out.println("分配了4M");
							System.out.println("max memory:" + Runtime.getRuntime().maxMemory());
							System.out.println("free memory:" + Runtime.getRuntime().freeMemory());
							System.out.println("total memory:" + Runtime.getRuntime().totalMemory());							
						}						
					}
					#新生代的配置
					-Xmn：设置新生代的大小，这个参数对GC的行为有很大影响（GC主要回收这块内存），一般设置为整个堆内存的1/3到1/4左右
					-XX:SurvivorRatio：设置新生代中的eden空间和from/to空间的比例，含义：-XX:SurvivorRatio=eden/to=eden/from
					-XX:NewRatio：设置新生代与老年代的比例，即：-XX:NewRatio=老年代/新生代
					总结：尽可能的将对象预留在新生代，减少老年代GC的次数
					案例说明：
					public class Test02 {
						public static void main(String[] args) {							
							//第一次配置
							//-Xms20m -Xmx20m -Xmn1m -XX:SurvivorRatio=2 -XX:+PrintGCDetails -XX:+UseSerialGC							
							//第二次配置
							//-Xms20m -Xmx20m -Xmn7m -XX:SurvivorRatio=2 -XX:+PrintGCDetails -XX:+UseSerialGC							
							//第三次配置
							//-XX:NewRatio=老年代/新生代
							//-Xms20m -Xmx20m -XX:NewRatio=2 -XX:+PrintGCDetails -XX:+UseSerialGC							
							byte[] b = null;
							//连续向系统申请10MB空间
							for(int i = 0 ; i <10; i ++){
								b = new byte[1*1024*1024];
							}
						}
					}
				堆内存溢出处理：
					含义：Java程序在运行的时候，如果堆空间不足，则会抛出堆内存溢出的错误（Out Of Memory）OOM，在生产环境下，严重影响业务中断；JVM提供了-XX:+HeapDumpOnOutOfMemoryError参数，
						  可以导出整个堆信息，配合-XX:+HeapDumpPath来设置存储路径；配合使用插件：Memory Analyzer 1.5.0进行分析；
					案例分析：
					public class Test03 {
						public static void main(String[] args) {							
							//-Xms1m -Xmx1m -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=d:/Test03.dump
							//堆内存溢出
							Vector v = new Vector();
							for(int i=0; i < 5; i ++){
								v.add(new Byte[1*1024*1024]);
							}							
						}
					}
			2、栈的参数设置：
				-Xss：指定线程的最大栈空间，决定了函数调用的最大深度；
				案例分析：
				public class Test04 {
					//-Xss1m  
					//-Xss5m					
					//栈调用深度
					private static int count;					
					public static void recursion(){
						count++;
						recursion();
					}
					public static void main(String[] args){
						try {
							recursion();
						} catch (Throwable t) {
							System.out.println("调用最大深入：" + count);
							t.printStackTrace();
						}
					}
				}
			3、方法区的参数设置：
				-XX:MaxPermSize=64MB
				-XX:PermSize=64MB，默认设置就是64MB
			4、直接内存的参数设置（了解）：		
				-XX:MaxDirectMemorySize：利用这一参数设置，可以忽略；广泛用于NIO中；
			5、对象如何进入老年代？参数设置：
				-XX:MaxTenuringThreshold=15，默认值15，即GC次数15次
				案例分析：
				public class Test05 {
					public static void main(String[] args) {
						//初始的对象在eden区
						//参数：-Xmx64M -Xms64M -XX:+PrintGCDetails
				//		for(int i=0; i< 5; i++){//5M
				//			byte[] b = new byte[1024*1024];
				//		}																		
						//测试进入老年代的对象
						//参数：-Xmx1024M -Xms1024M -XX:+UseSerialGC -XX:MaxTenuringThreshold=15 -XX:+PrintGCDetails -XX:+PrintHeapAtGC
				//		Map<Integer, byte[]> m = new HashMap<Integer, byte[]>();
				//		for(int i =0; i <5 ; i++) {
				//			byte[] b = new byte[1024*1024];
				//			m.put(i, b);
				//		}	
				//		for(int k = 0; k<20; k++) {
				//			for(int j = 0; j<300; j++){
				//				byte[] b = new byte[1024*1024]; 
				//			}
				//		}											
					}
				}
			6、当对象过大，eden区装不了直接进入老年代，可以设置参数来确定，但要注意TLAB区域，也可能进入TLAB区域：
				-XX:PretenureSizeThreshold
				TLAB区：全程为Thread Local Allocation Buffer，即线程本地分配缓存，线程专用的，目的是为了加速对象分配而产生的，避免多线程冲突的问题；一般不会太大，但TLAB装不下，会直接分配到堆上；
						相关参数设置：
							-XX:+UseTLAB：使用TLAB
							-XX:+TLABSize：设置TLAB的大小
							-XX:TLABRefillWasteFraction：设置进入TLAB区单个对象的大小，是一个比值，默认64，即但单个对象大于整个区的1/64，则在堆内存中创建对象
							-XX:+PrintTLAB：打印信息
							-XX:ResizeTLAB：自动调整TLABRefillWasteFraction的阈值
				案例分析：
				public class Test06 {
					public static void main(String[] args) {						
						//参数：-Xmx30M -Xms30M -XX:+UseSerialGC -XX:+PrintGCDetails -XX:PretenureSizeThreshold=1000
						//出现这种现象原因为：JVM虚拟机对于体积不大的对象会优先把数据分配到TLAB区域中，因此就失去了在老年代分配的机会
						//参数：-Xmx30M -Xms30M -XX:+UseSerialGC -XX:+PrintGCDetails -XX:PretenureSizeThreshold=1000 -XX:-UseTLAB
						Map<Integer, byte[]> m = new HashMap<Integer, byte[]>();
						for(int i=0; i< 5*1024; i++){
							byte[] b = new byte[1024];
							m.put(i, b);
						}
					}
				}
				public class Test07 {
					public static void alloc(){
						byte[] b = new byte[2];
					}
					public static void main(String[] args) {						
						//TLAB分配
						//参数：-XX:+UseTLAB -XX:+PrintTLAB -XX:+PrintGC -XX:TLABSize=102400 -XX:-ResizeTLAB -XX:TLABRefillWasteFraction=100 -XX:-DoEscapeAnalysis -server
						for(int i=0; i<10000000;i++){
							alloc();
						}																																																
					}
				}
			7、对象创建流程图：
				new 关键字创建对象 --------->尝试栈上分配（临时变量、对象）----N---->尝试TLAB分配（逻辑概念）----N---->是否满足进入老年代-----N---->eden区分配---->END
													|Y										|Y									|Y
													栈										TLAB								老年代								
		虚拟机工作模式：
			JVM支持Client和Server两种工作模式，使用相应的参数：-client或-server调用相应的模式，区别：Client模式启动快，用于测试环境；Server模式启动慢，用于生产环境，JDK1.7以后都是Server模式
		垃圾回收和算法：
			垃圾回收：
				概念：Garbage Collection，简称GC，在GC机制内存中不再使用的对象，需要回收。垃圾回收涉及多种算法，如：引用计数法，标记压缩法，复制算法，分代、分区思想
					引用计数法：古老的方法，核心思想是：对象被引用时计数加1，对象失去引用时计数减1，缺点：在循环迭代时易出错，频繁的加减操作影响系统性能
					标记清除法：分为标记和清除2个阶段，缺点存在空间碎片问题，GC以后内存空间是不连续的
					复制算法：Jvm新生代中的S0区或S1区使用这种算法
					标记压缩法：Jvm老年代使用这种算法，在标记清除基础之上，对标记对象进行压缩放置到一端而进行的垃圾清理
					分代算法：将内存分成多块，每块使用不同的算法
					分区算法：分区概念类似于磁盘分区，将整个内存空间分成独立的N块小空间，每个空间都可以独立使用，GC时只需对某一块内存空间进行GC，提高性能，减少GC停顿时间
			垃圾回收停顿想象：
				在GC的时候，会要求系统进入一个停顿的状态，此时程序会终止所有的线程，此刻程序是不会产生新的垃圾，也有利于更好的标记垃圾对象；
				
----------------------------------------------VUE核心基础知识----------------------------------------------------------------------------------	
	一、基本认识：渐进式JavaScript框架；作者: 尤雨溪(一位华裔前Google工程师)；作用: 动态构建用户界面
		英文官网: https://vuejs.org/；中文官网: https://cn.vuejs.org/
		特点：
			1) 遵循MVVM模式
			2) 编码简洁, 体积小, 运行效率高, 适合移动/PC 端开发
			3) 它本身只关注UI, 可以轻松引入 vue 插件或其它第三库开发项目
		与其它前端JS框架的关联：
			借鉴angular的模板和数据绑定技术；借鉴react的组件化和虚拟DOM技术；
		Vue扩展插件：
			1) vue-cli: vue 脚手架
			2) vue-resource(axios): ajax 请求
			3) vue-router: 路由
			4) vuex: 状态管理
			5) vue-lazyload: 图片懒加载
			6) vue-scroller: 页面滑动相关
			7) mint-ui: 基于 vue 的 UI 组件库(移动端)
			8) element-ui: 基于 vue 的 UI 组件库(PC 端)
		基本使用：
			如：<div id="app">
					<input type="text" v-model="username">
					<p>Hello, {{username}}</p>
				</div>
				<script type="text/javascript" src="../js/vue.js"></script>
				<script type="text/javascript">
					new Vue({
					el: '#app',
					data: {
						username: 'atguigu'
					}
					})
				</script>
		开发者工具调试：vuejs devtools
		理解Vue的MVVM：	
			View ------------>ViewModel----------->Model（扁平化的JS对象）
			DOM            数据绑定/DOM监听
		基础语法：
			模板理解：动态的html页面；包含了一些 JS 语法代码（双大括号表达式、指令(以v-开头的自定义标签属性)）；
			1、双大括号表达式：{{exp}}；功能: 向页面输出数据；可以调用对象的方法；
			2、强制数据绑定：功能: 指定变化的属性值；完整写法: v-bind:xxx='yyy'；简写: :xxx='yyy'；
			3、绑定事件监听：功能: 绑定指定事件名的回调函数；完整写法:v-on:keyup='xxx'；v-on:keyup='xxx(参数)' v-on:keyup.enter='xxx'等等；简写:@keyup='xxx'；@keyup.enter='xxx'；
			如：<div id="app">
					<h2>1. 双大括号表达式</h2>
					<p>{{msg}}</p>
					<p>{{msg.toUpperCase()}}</p>
					<h2>2. 指令一: 强制数据绑定</h2>
					<a href="url">访问指定站点</a><br><!--不能使用-->
					<a v-bind:href="url">访问指定站点 2</a><br>
					<a :href="url">访问指定站点 3</a><br>
					<h2>3. 指令二: 绑定事件监听</h2>
					<button v-on:click="handleClick">点我</button>
					<button @click="handleClick">点我 2</button>
				</div>
				<script type="text/javascript" src="../js/vue.js"></script>
				<script type="text/javascript">
					new Vue({
					el: '#app',
					data: {// data的所有属性都会成功 vm 对象的属性, 而模板页面中可以直接访问
						msg: 'NBA I Love This Game!',
						url: 'http://www.baidu.com'
					},
					methods: {
						handleClick () {
							alert('处理点击')
						}
					}
					})
				</script>
			4、计算属性和监视：
			   计算属性：在computed属性对象中定义计算属性的方法；在页面中使用{{方法名}}来显示计算的结果；
			   监视属性：通过通过vm对象的$watch()或watch配置来监视指定的属性；当属性变化时, 回调函数自动调用, 在函数内部进行计算；
			   计算属性高级：通过getter/setter实现对属性数据的显示和监视，计算属性存在缓存, 多次读取只执行一次getter计算；
			   如：<div id="demo">
						姓: <input type="text" placeholder="First Name" v-model="firstName"><br>
						名: <input type="text" placeholder="Last Name" v-model="lastName"><br>
						姓名 1(单向): <input type="text" placeholder="Full Name" v-model="fullName1"><br>
						姓名 2(单向): <input type="text" placeholder="Full Name" v-model="fullName2"><br>
						姓名 3(双向): <input type="text" placeholder="Full Name2" v-model="fullName3"><br>
				   </div>
				   <script type="text/javascript" src="../js/vue.js"></script>
					<script type="text/javascript">
					var vm = new Vue({
					el: '#demo',
					data: {
						firstName: 'Kobe',
						lastName: 'bryant',
						fullName2: 'Kobe bryant'
					},
					computed: {
						fullName: function () {
							return this.firstName + " " + this.lastName
						},
						fullName3: {
							get: function () {
								return this.firstName + " " + this.lastName
							},
							set: function (value) {
								var names = value.split(' ')
								this.firstName = names[0]
								this.lastName = names[1]
							}
						}
					},
					watch: {
						lastName: function (newVal, oldVal) {
							this.fullName2 = this.firstName + ' ' + newVal
						}
					}
					})
					vm.$watch('firstName', function (val) {
						this.fullName2 = val + ' ' + this.lastName
					})
					</script>
			5、class与style绑定：
			   理解：在应用界面中, 某个(些)元素的样式是变化的；class/style绑定就是专门用来实现动态样式效果的技术；
			   class绑定：:class='xxx'；表达式是字符串: 'classA'；表达式是对象: {classA:isA, classB: isB}；表达式是数组: ['classA', 'classB']；
			   style绑定：:style="{ color: activeColor, fontSize: fontSize + 'px' }"，其中activeColor/fontSize是data属性；
			   如：<style>
					.classA {
						color: red;
					}
					.classB {
						background: blue;
					}
					.classC {
						font-size: 20px;
					}
					</style>
					<div id="demo">
						<h2>1. class 绑定: :class='xxx'</h2>
						<p class="classB" :class="a">表达式是字符串: 'classA'</p>
						<p :class="{classA: isA, classB: isB}">表达式是对象: {classA:isA, classB: isB}</p>
						<p :class="['classA', 'classC']"> 表达式是数组: ['classA', 'classB']</p>
						<h2>2. style 绑定</h2>
						<p :style="{ color: activeColor, fontSize: fontSize +
						'px' }"</p>
						<button @click="update">更新</button>
					</div>
					<script type="text/javascript" src="../js/vue.js"></script>
					<script type="text/javascript">
					new Vue({
						el : '#demo',
						data : {
							a: 'classA',
							isA: true,
							isB: false,
							activeColor: 'red',
							fontSize: '20px'
						},
						methods : {
							update () {
								this.a = 'classC'
								this.isA = false
								this.isB = true
								this.activeColor = 'blue'
								this.fontSize = '30px'
							}
						}
					})
					</script>
			6、条件渲染：
			   条件渲染指令：v-if与v-else；v-show；比较：需要频繁切换v-show较好；当条件不成立时, v-if的所有子节点不会解析(项目中使用)；
			   如：<div id="demo">
						<h2 v-if="ok">表白成功</h2>
						<h2 v-else>表白失败</h2>
						<h2 v-show="ok">求婚成功</h2>
						<h2 v-show="!ok">求婚失败</h2>
						<br>
						<button @click="ok=!ok">切换</button>
					</div>
			    <script type="text/javascript" src="../js/vue.js"></script>
				<script type="text/javascript">
				var vm = new Vue({
				el: '#demo',
				data: {
					ok: false
				}
				})
				</script>
			7、列表渲染：
			   列表显示指令：数组: v-for / index；对象: v-for / key；
			   列表的更新显示：删除 item；替换 item；
			   列表的高级处理：列表过滤、列表排序；
			   如：<div id="demo">
					<h2>测试: v-for 遍历数组</h2>
					<ul>
						<li v-for="(p, index) in persons" :key="index">
						{{index}}--{{p.name}}--{{p.age}}
						--
						<button @click="deleteItem(index)">删除</button>
						--
						<button @click="updateItem(index, {name:'Jok',age:15})">更新</button>
						</li>
					</ul>
					<h2>测试: v-for 遍历对象</h2>
					<ul>
						<li v-for="(value, key) in persons[0]">
						{{ key }} : {{ value }}
						</li>
					</ul>
					</div>
					<script type="text/javascript" src="../js/vue.js"></script>
					<script type="text/javascript">
					new Vue({
						el: '#demo',
						data: {
						persons: [
							{id: 1, name: 'Tom', age: 13},
							{id: 2, name: 'Jack', age: 12},
							{id: 3, name: 'Bob', age: 14}
						]
						},
						methods: {
						deleteItem(index) {
							this.persons.splice(index, 1) //splice()；用于删除、修改、新增；
						},
						updateItem(index, p) {
							// this.persons[index] = p // 页面不会更新
							this.persons.splice(index, 1, p)
						}
						}
					})
					</script>
			   如：<div id="demo">
						<input type="text" name="searchName" placeholder="搜索指定用户名"
						v-model="searchName">
						<ul>
						<li v-for="(p, index) in filterPerson" :key="index">
						{{index}}--{{p.name}}--{{p.age}}
						</li>
						</ul>
						<button @click="setOrderType(1)">年龄升序</button>
						<button @click="setOrderType(2)">年龄降序</button>
						<button @click="setOrderType(0)">原本顺序</button>
					</div>
					<script type="text/javascript" src="../js/vue.js"></script>
					<script type="text/javascript">
					new Vue({
					el: '#demo',
					data: {
						orderType: 0, //0 代表不排序, 1 为升序, 2 为降序
						searchName: '',
						persons: [
							{id: 1, name: 'Tom', age: 13},
							{id: 2, name: 'Jack', age: 12},
							{id: 3, name: 'Bob', age: 17},
							{id: 4, name: 'Cat', age: 14},
							{id: 4, name: 'Mike', age: 14},
							{id: 4, name: 'Monica', age: 16}
						]
					},
					methods: {
						setOrderType (orderType) {
							this.orderType = orderType
						}
					},
					computed: {
						filterPerson() {
							// let 声明的变量只在 let 命令所在的代码块内有效；const 声明一个只读的常量，一旦声明，常量的值就不能改变；
							let {orderType, searchName, persons} = this
							// 过滤
							persons = persons.filter(p => p.name.indexOf(searchName)!=-1)
							// 排序
							if(orderType!==0) {
								persons = persons.sort(function (p1, p2) {
								if(orderType===1) {
									return p1.age-p2.age
								} else {
									return p2.age-p1.age
								}
								})
							}
							return persons
						}
					}
					})
					</script>
			8、事件处理：
			   绑定监听: v-on:xxx="fun"；@xxx="fun"；@xxx="fun(参数)"；默认事件形参: event；隐含属性对象: $event；
			   事件修饰符：.prevent: 阻止事件的默认行为event.preventDefault()；.stop: 停止事件冒泡event.stopPropagation()；
			   按键修饰符：.keycode: 操作的是某个keycode值的键；.keyName: 操作的某个按键名的键(少部分)；
			   如：<div id="example">
						<h2>1. 绑定监听</h2>
						<button v-on:click="test1">Greet</button>
						<button @click="test1">Greet2</button>
						<button @click="test2($event, 'hello')">Greet3</button>
						<h2>2. 事件修饰符</h2>
						<!-- 阻止事件默认行为 -->
						<a href="http://www.baidu.com" @click.prevent="test3">百度一下</a>
						<br/>
						<br/>
						<!-- 停止事件冒泡 -->
						<div style="width: 200px;height: 200px;background: red" @click="test4">
						<div style="width: 100px;height: 100px;background: green"
						@click.stop="test5"></div>
						</div>
						<h2>3. 按键修饰符</h2>
						<input @keyup.8="test6">
						<input @keyup.enter="test6">
					</div>
					<script type="text/javascript" src="../js/vue.js"></script>
					<script type="text/javascript">
					new Vue({
					el: '#example',
					data: {
						name: 'Vue.js'
					},
					methods: {
						test1 (event) {
							// 方法内 `this` 指向 vm
							// alert('Hello ' + this.name + '!')
							// `event` 是原生 DOM 事件
							alert(event.target.innerHTML)
						},
						test2 (event, msg) {
							alert(event.target.innerHTML + '---' + msg)
						},
						test3() {
							alert('阻止事件的默认行为')
						},
						test4() {
							alert('out')
						},
						test5() {
							alert('inner')
						},
						test6(event) {
							alert(event.keyCode + '---' + event.target.value)
						}
					}
					})
					</script>
			9、表单输入绑定：
			   使用v-model对表单数据自动收集；text/textarea password checkbox radio select；
			   如：<div id="demo">
						<form @submit.prevent="handleSubmit">
							<span>用户名: </span>
							<input type="text" v-model="user.username"><br>
							<span>密码: </span>
							<input type="password" v-model="user.pwd"><br>
							<span>性别: </span>
							<input type="radio" id="female" value="female" v-model="user.sex">
							<label for="female">女</label>
							<input type="radio" id="male" value="male" v-model="user.sex">
							<label for="male">男</label><br>
							<span>爱好: </span>
							<input type="checkbox" id="basket" value="basketball"
							v-model="user.likes">
							<label for="basket">篮球</label>
							<input type="checkbox" id="foot" value="football"
							v-model="user.likes">
							<label for="foot">足球</label>
							<input type="checkbox" id="pingpang" value="pingpang"
							v-model="user.likes">
							<label for="pingpang">乒乓</label><br>
							<span>城市: </span>
							<select v-model="user.cityId">
							<option value="">未选择</option>
							<option v-for="city in allCitys" :value="city.id">
							{{ city.name }}
							</option>
							</select><br>
							<span>介绍: </span>
							<textarea v-model="user.desc" rows="10"></textarea><br><br>
							<input type="submit" value="注册">
						</form>
					</div>
					<script type="text/javascript" src="../js/vue.js"></script>
					<script type="text/javascript">
					var vm = new Vue({
					el: '#demo',
					data: {
						user: {
							username: '',
							pwd: '',
							sex: 'female',
							likes: [],
							cityId: '',
							desc: '',
						},
						allCitys: [{id: 1, name: 'BJ'}, {id: 2, name: 'SZ'},{id: 4, name:
						'SH'}],
					},
					methods: {
						handleSubmit (event) {
							alert(JSON.stringify(this.user))
						}
					}
					})
					</script>
			10、Vue实例生命周期：
				生命周期流程图：
									new Vue()#新建实例
									    |   
									init event#初始化事件&生命周期
									    |    -------beforeCreated
									初始化注入&校验
									    |    -------created
									是否指定EL（元素）选项？N ---->当调用vm.$mount(el)函数时-|
									    Y ------------------------------------------------->是否指定template（模板）选项？N 将el外的html作为template编译
																								  Y                                           |
																							将template编译到render（渲染函数）中              |
																							              |                                   |
																							                              |   ----beforeMount
																							                           创建$el并用其替换el
																													      |  ----mounted
																														挂载完毕 （当data被修改时->beforeUpdate->虚拟DOM重新渲染并应用更新->updated->挂载完毕） 
																														  |
																														当调用vm.$destory()函数时  
																														  |  -----beforeDestroy
																														解除绑定销毁子组件以及事件监听器
																														  |
																														销毁完成（destroyed）
				Vue生命周期分析：	
				初始化显示：beforeCreate() * created() * beforeMount() * mounted()；
				更新状态: this.xxx = value；* beforeUpdate() * updated()；
				销毁 vue 实例: vm.$destory()；* beforeDestory() * destoryed()；
				常用的生命周期方法：
				created()/mounted(): 发送 ajax 请求, 启动定时器等异步任务；
				beforeDestory(): 做收尾工作, 如: 清除定时器；
				如：<div>
						<button @click="destoryVue">destory vue</button>
						<p v-show="isShowing">{{msg}}</p>
					</div>
					<script type="text/javascript" src="../js/vue.js"></script>
					<script type="text/javascript">
					var vue = new Vue({
					el: 'div',
					data: {
						msg: '尚硅谷 IT 教育',
						isShowing: true,
						persons: []
					},
					beforeCreate () {
						console.log('beforeCreate() msg=' + this.msg)
					},
					created () {
						console.log('created() msg='+this.msg)
						this.intervalId = setInterval(() => {
						console.log('-----')
						this.isShowing = !this.isShowing
						}, 1000)
					},
					beforeMount () {
						console.log('beforeMount() msg='+this.msg)
					},
					mounted () {
						console.log('mounted() msg='+this.msg)
					},
					beforeUpdate() {
						console.log('beforeUpdate isShowing='+this.isShowing)
					},
					updated () {
						console.log('updated isShowing='+this.isShowing)
					},
					beforeDestroy () {
						console.log('beforeDestroy() msg='+this.msg)
						clearInterval(this.intervalId)
					},
					destroyed () {
						console.log('destroyed() msg='+this.msg)
					},
					methods: {
						destoryVue () {
							vue.$destroy()
						}
						}
					})
					</script>		
			11、过渡&动画：
				理解：操作css的trasition或animation；vue会给目标元素添加/移除特定的class；
				      过渡的相关类名：xxx-enter-active: 指定显示的transition；xxx-leave-active: 指定隐藏的transition；xxx-enter/xxx-leave-to: 指定隐藏时的样式；
					Enter:
						Opacity：0   ------------> Opacity：1
					      v-enter                  v-enter-to
								   v-enter-active
					Leave
						Opacity：1   ------------> Opacity：0
					      v-enter                  v-enter-to
								   v-enter-active
				基本过渡动画的编码：
					在目标元素外包裹<transition name="xxx">；定义class样式；指定过渡样式: transition；指定隐藏时的样式: opacity/其它；
				如：<style>
					.fade-enter-active, .fade-leave-active {
					transition: opacity .5s
					}
					.fade-enter, .fade-leave-to {
					opacity: 0
					}
					/* 可以设置不同的进入和离开动画 */
					.slide-fade-enter-active {
					transition: all .3s ease;
					}
					.slide-fade-leave-active {
					transition: all .8s cubic-bezier(1.0, 0.5, 0.8, 1.0);
					}
					.slide-fade-enter, .slide-fade-leave-to {
					transform: translateX(10px);
					opacity: 0;
					}
					</style>
					<div id="demo1">
						<button @click="show = !show">
						Toggle1
						</button>
						<transition name="fade">
						<p v-if="show">hello</p>
						</transition>
					</div>
					<div id="demo2">
						<button @click="show = !show">
						Toggle2
						</button>
						<transition name="slide-fade">
						<p v-if="show">hello</p>
						</transition>
					</div>
					<script type="text/javascript" src="../js/vue.js"></script>
					<script type="text/javascript">
					new Vue({
					el: '#demo1',
						data: {
						show: true
						}
					})
					new Vue({
					el: '#demo2',
						data: {
						show: true
						}
					})
					</script>
				如：<style>
					.bounce-enter-active {
					animation: bounce-in .5s;
					}
					.bounce-leave-active {
					animation: bounce-in .5s reverse;
					}
					@keyframes bounce-in {
					0% {
					transform: scale(0);
					}
					50% {
					transform: scale(1.5);
					}
					100% {
					transform: scale(1);
					}
					}
					</style>
					<div id="test2">
						<button @click="show = !show">Toggle show</button>
						<br>
						<transition name="bounce">
						<p v-if="show" style="display: inline-block">Look at me!</p>
						</transition>
					</div>
					<script type="text/javascript" src="../js/vue.js"></script>
					<script>
					new Vue({
					el: '#test2',
						data: {
						show: true
						}
					})
					</script>	
			12、过滤器：功能: 对要显示的数据进行特定格式化后再显示；注意: 并没有改变原本的数据, 可是产生新的对应的数据；
				定义和使用过滤器：
					定义过滤器：Vue.filter(filterName, function(value[,arg1,arg2,...]){
								// 进行一定的数据处理
								return newValue
								})
					使用过滤器：
					<div>{{myData | filterName}}</div>
					<div>{{myData | filterName(arg)}}</div>
				如：<div id="test">
						<p>当前时间为: {{currentTime}}</p>
						<p>当前时间 1 为: {{currentTime | dateStr}}</p>
						<p>当前时间 2 为: {{currentTime | dateStr('YYYY-MM-DD')}}</p>
						<p>当前时间 3 为: {{currentTime | dateStr('HH:mm:ss')}}</p>
					</div>
					<script type="text/javascript" src="../js/vue.js"></script>
					<script type="text/javascript"
						src="https://cdn.bootcss.com/moment.js/2.19.0/moment.js"></script>
					<script>
					// 注册过滤器
					Vue.filter('dateStr', function (value, format) {
						return moment(value).format(format || 'YYYY-MM-DD HH:mm:ss')
					})
					new Vue({
					el: '#test',
					data: {
						currentTime: new Date()
					}
					})
					</script>
			13、内置指令与自定义指令：
				常用内置指令：
				1) v:text : 更新元素的 textContent
				2) v-html : 更新元素的 innerHTML
				3) v-if : 如果为 true, 当前标签才会输出到页面
				   v-else: 如果为 false, 当前标签才会输出到页面
				5) v-show : 通过控制display样式来控制显示/隐藏
				6) v-for : 遍历数组/对象
				7) v-on : 绑定事件监听, 一般简写为@
				8) v-bind : 强制绑定解析表达式, 可以省略 v-bind
				9) v-model : 双向数据绑定
				10) ref : 指定唯一标识, vue对象通过$refs属性访问这个元素对象
				11) v-cloak : 防止闪现, 与 css 配合: [v-cloak] { display: none }
				自定义指令：
				注册全局指令：
				Vue.directive('my-directive', function(el, binding){
					el.innerHTML = binding.value.toupperCase()
				})
				注册局部指令：
				directives : {
					'my-directive' : {
						bind (el, binding) {
							el.innerHTML = binding.value.toupperCase()
						}
					}
				}
				使用指令：v-my-directive='xxx'
				如：（内置指令）
				<style>
				[v-cloak] {
				display: none
				}
				</style>
				<div id="example">
					<p v-text="url"></p>
					<p v-html="url"></p>
					<img :id="myid" :src="imageSrc">
					<p>
					<span ref="message">atguigu.com</span>
					<button @click="showMsg">显示左侧文本</button>
					</p>
					<p v-cloak>{{url}}</p>
				</div>
				<script type="text/javascript" src="../js/vue.js"></script>
				<script type="text/javascript">
				alert('模拟加载慢')
				new Vue({
				el: '#example',
				data: {
					url: '<a href="http://www.atguigu.com">尚硅谷</a>',
					myid: 'abc123',
					imageSrc: 'http://cn.vuejs.org/images/logo.png'
				},
				methods: {
					showMsg: function () {
						alert(this.$refs.message.textContent)
					}
				}
				})
				</script>
				如：（自定义指令）；需求：功能类型于 v-text, 但转换为全大写；功能类型于 v-text, 但转换为全小写；
				<div id="demo1">
					<p v-upper-text="msg"></p>
					<p v-lower-text="msg"></p>
				</div>
				<div id="demo2">
					<p v-upper-text="msg2"></p>
					<p v-lower-text="msg2"></p> <!--局部指令, 此处不能使用-->
				</div>
				<script type="text/javascript" src="../js/vue.js"></script>
				<script type="text/javascript">
				//注册全局指令
				Vue.directive('upper-text', function (el, binding) {
				el.innerHTML = binding.value.toUpperCase()
				})
				new Vue({
				el: '#demo1',
				data: {
					msg: 'NBA love this game!'
				},
				directives: { // 注册局部指令
					'lower-text': {
						bind (el, binding) {
							el.innerHTML = binding.value.toLowerCase()
						}
					}
				}
				})
				new Vue({
				el: '#demo2',
				data: {
					msg2: 'I Like You'
				}
				})
				</script>
			14、自定义插件：Vue 插件是一个包含 install 方法的对象；通过 install 方法给 Vue 或 Vue 实例添加方法，定义全局指令等；
				如：/**
					* 自定义 Vue 插件
					*/
					(function () {
					const MyPlugin = {}
					MyPlugin.install = function (Vue, options) {
					// 1. 添加全局方法或属性
					Vue.myGlobalMethod = function () {
						alert('Vue 函数对象方法执行')
					}
					// 2. 添加全局资源
					Vue.directive('my-directive', function (el, binding) {
						el.innerHTML = "MyPlugin my-directive " + binding.value
					})
					// 3. 添加实例方法
					Vue.prototype.$myMethod = function () {
						alert('vue 实例对象方法执行')
					}
					}
					window.MyPlugin = MyPlugin
					})()
					页面使用插件：
					<div id="demo">
					<!--使用自定义指令-->
					<p v-my-directive="msg"></p>
					</div>
					<script type="text/javascript" src="../js/vue.js"></script>
					<script type="text/javascript" src="vue-myPlugin.js"></script>
					<script type="text/javascript">
					//使用自定义插件
					Vue.use(MyPlugin)
					var vm = new Vue({
					el: '#demo',
					data: {
						msg: 'atguigu'
					}
					})
					//调用自定义的静态方法
					Vue.myGlobalMethod()
					//调用自定义的对象方法
					vm.$myMethod()
					</script>
	二、Vue组件化编码：
		使用 vue-cli 创建模板项目：vue-cli 是 vue 官方提供的脚手架工具；github: https://github.com/vuejs/vue-cli；作用: 从 https://github.com/vuejs-templates 下载模板项目；
		创建 vue 项目：
			npm install -g vue-cli 
			vue init webpack vue_demo
			cd vue_demo
			npm install
			npm run dev
			访问: http://localhost:8080/ 
		模板项目的结构：
			|-- build : webpack 相关的配置文件夹(基本不需要修改)
				|-- dev-server.js : 通过 express 启动后台服务器
			|-- config: webpack 相关的配置文件夹(基本不需要修改)
				|-- index.js: 指定的后台服务的端口号和静态资源文件夹
			|-- node_modules
			|-- src : 源码文件夹
				|-- components: vue 组件及其相关资源文件夹
				|-- App.vue: 应用根主组件
				|-- main.js: 应用入口 js
			|-- static: 静态资源文件夹
			|-- .babelrc: babel 的配置文件
			|-- .eslintignore: eslint 检查忽略的配置
			|-- .eslintrc.js: eslint 检查的配置
			|-- .gitignore: git 版本管制忽略的配置
			|-- index.html: 主页面文件
			|-- package.json: 应用包配置文件
			|-- README.md: 应用描述说明的 readme 文件
		项目的打包与发布：
			打包：npm run build；
			发布 1: 使用静态服务器工具包；
					npm install -g serve
					serve dist
					访问: http://localhost:5000
				 2：使用动态 web 服务器(tomcat、nginx)
					修改配置: webpack.prod.conf.js
					output: {
						publicPath: '/xxx/' //打包文件夹的名称
					}
					重新打包:
					npm run build
					修改 dist 文件夹为项目名称: xxx
					将 xxx 拷贝到运行的 tomcat 的 webapps 目录下
					访问: http://localhost:8080/xxx
		ESLint：
			说明：ESLint 是一个代码规范检查工具；它定义了很多特定的规则, 一旦你的代码违背了某一规则, eslint会作出非常有用的提示；官网: http://eslint.org/；基本已替代以前的 JSLint；
			ESLint 提供支持：ES； JSX； style 检查； 自定义错误和提示；
			ESLint 提供校验：语法错误校验；不重要或丢失的标点符号，如分号；没法运行到的代码块（使用过 WebStorm 的童鞋应该了解）；未被使用的参数提醒；确保样式的统一规则，如 sass 或者 less；检查变量的命名；
			规则的错误等级有三种：
				1) 0：关闭规则。
				2) 1：打开规则，并且作为一个警告（信息打印黄色字体）
				3) 2：打开规则，并且作为一个错误（信息打印红色字体）
			相关配置文件：
				1) .eslintrc.js : 全局规则配置文件
				'rules': {
					'no-new': 1
				}
				2) 在 js/vue 文件中修改局部规则
				/* eslint-disable no-new */
				new Vue({
					el: 'body', 
					components: { App }
				})
				3) .eslintignore: 指令检查忽略的文件
				*.js 
				*.vue
		组件定义与使用：
			vue 文件的组成(3 个部分)：
			1) 模板页面
				<template>
					页面模板
				</template>
			2) JS 模块对象
				<script>
				export default {
					data() {return {}}, methods: {}, computed: {}, components: {}
				}
				</script>
			3) 样式
				<style>
					样式定义
				</style>
		基本使用：引入组件；映射成组件标签；使用组件标签；
			如：<template>
				<HelloWorld></HelloWorld>
				<hello-world></hello-world>
				</template>
				<script>
				import HelloWorld from './components/HelloWorld' 
				export default {
					components: {
						HelloWorld
					}
				}
				</script>
			关于标签名与标签属性名书写问题：写法一: 一模一样；写法二: 大写变小写, 并用-连接；
		组件间通信：
			组件间通信基本原则：不要在子组件中直接修改父组件的状态数据；数据在哪, 更新数据的行为(函数)就应该定义在哪；
			组件间通信方式：props；自定义事件；消息订阅与发布(如: pubsub 库)；slot；vuex；
				props；
					使用组件标签时：<my-component name='tom' :age='3' :set-name='setName'></my-component>；
					定义 MyComponent 时：在组件内声明所有的 props				
					方式一: 只指定名称
					props: ['name', 'age', 'setName']
					方式二: 指定名称和类型
					props: {
					name: String, age: Number, setNmae: Function
					}
					方式三: 指定名称/类型/必要性/默认值
					props: {
						name: {type: String, required: true, default:xxx}, 
						age: {type: Number, required: true, default:xxx},
						setNmae: {type: Function, required: true, default:xxx}
					}
					如：//App.vue父组件
					<template>
					  <div id="app">
						<users v-bind:users="users"></users>//前者自定义名称便于子组件调用，后者要传递数据名
					  </div>
					</template>
					<script>
					import Users from "./components/Users"
					export default {
					  name: 'App',
					  data(){
						return{
						  users:["Henry","Bucky","Emily"]
						}
					  },
					  components:{
						"users":Users
					  }
					}
					//users子组件
					<template>
					  <div class="hello">
						<ul>
						  <li v-for="user in users">{{user}}</li>
						</ul>
					  </div>
					</template>
					<script>
					export default {
					  name: 'HelloWorld',
					  props:{
						users:{//这个就是父组件中子标签自定义名字
						  type:Array,
						  required:true
						}
					  }
					}
					</script>					
				注意：此方式用于父组件向子组件传递数据；所有标签属性都会成为组件对象的属性，模板页面可以直接引用；
				问题:
					a. 如果需要向非子后代传递数据必须多层逐层传递；b. 兄弟组件间也不能直接 props 通信, 必须借助父组件才可以；
				VUE自定义事件：
				   绑定事件监听（父组件）：
				    //方式一: 通过v-on绑定
					@delete_todo="deleteTodo"
					//方式二: 通过$on()
					this.$refs.xxx.$on('delete_todo', function (todo) {
						this.deleteTodo(todo)
					})
				   触发事件（子组件）：				    
					this.$emit(eventName, data)//触发事件(只能在父组件中接收)
				   如：// 子组件
					<template>
					  <header>
						<h1 @click="changeTitle">{{title}}</h1>//绑定一个点击事件
					  </header>
					</template>
					<script>
					export default {
					  name: 'app-header',
					  data() {
						return {
						  title:"Vue.js Demo"
						}
					  },
					  methods:{
						changeTitle() {
						  this.$emit("titleChanged","子向父组件传值");//自定义事件，传递值“子向父组件传值”
						}
					  }
					}
					</script>
				    // 父组件
					<template>
					  <div id="app">
						<app-header v-on:titleChanged="updateTitle" ></app-header>//与子组件titleChanged自定义事件保持一致
						<!-- 或 
						<app-header ref="titleChanged"></app-header> -->
					   // updateTitle($event)接受传递过来的文字
						<h2>{{title}}</h2>
					  </div>
					</template>
					<script>
					import Header from "./components/Header"
					export default {
					  name: 'App',
					  data(){
						return{
						  title:"传递的是一个值"
						}
					  },
					  /*mounted(){
						  this.$refs.titleChanged.$on('titleChanged', function (event) {
								this.updateTitle(event)
						  })
					  },*/
					  methods:{
						updateTitle(event){//声明这个函数
						  this.title = event;
						}
					  },
					  components:{
					   "app-header":Header,
					  }
					}
					</script>
				注意：此方式只用于子组件向父组件发送消息(数据)；问题: 隔代组件或兄弟组件间通信此种方式不合适；
				消息订阅与发布(PubSubJS库)：
				订阅消息：PubSub.subscribe('msg', function(msg, data){})
				发布消息：PubSub.publish('msg', data)
				如：
				<template>
				  <section class="jumbotron">
					<h3 class="jumbotron-heading">Search Github Users</h3>
					<div>
					  <input type="text" placeholder="enter the name you search" v-model="searchName"/>
					  <button @click="search">Search</button>
					</div>
				  </section>
				</template>
				<script>
				  import PubSub from 'pubsub-js'
				  export default {
					data () {
					  return {
						searchName: ''
					  }
					},
					methods: {
					  search () {
						const searchName = this.searchName.trim()
						if(searchName) {
						  PubSub.publish('search', searchName) //分发一个search的消息
						}
					  }
					}
				  }
				</script>
				<template>
				  <div>
					<h2 v-show="firstView">请输入关键字搜索</h2>
					<h2 v-show="loading">请求中...</h2>
					<h2 v-show="errorMsg">{{errorMsg}}</h2>
					<div class="row" v-show="users.length>0">
					  <div class="card" v-for="(user,index) in users" :key="index">
						<a :href="user.url" target="_blank">
						  <img :src="user.avatarUrl" style='width: 100px'/>
						</a>
						<p class="card-text">{{user.username}}</p>
					  </div>
					</div>
				  </div>
				</template>
				<script>
				  import PubSub from 'pubsub-js'
				  import axios from 'axios'
				  export default {
					data () {
					  return {
						firstView: true, // 是否显示初始页面
						loading: false, // 是否正在请求中
						users: [], // 用户数组
						errorMsg: ''  //错误信息
					  }
					},
					mounted () {
					  // 订阅消息(search)
					  PubSub.subscribe('search', (message,searchName) => { //点击了搜索, 发ajax请求进行搜索
						// 更新数据(请求中)
						this.firstView = false
						this.loading = true
						this.users = []
						this.errorMsg = ''
						// 发ajax请求进行搜索
						const url = `https://api.github.com/search/users?q=${searchName}`
						axios.get(url)
						  .then(response => {
							// 成功了, 更新数据(成功)
							this.loading = false
							this.users = response.data.items.map(item => ({
							  url: item.html_url,
							  avatarUrl: item.avatar_url,
							  username: item.login
							}))
						  })
						  .catch(error => {
							// 失败了, 更新数据(失败)
							this.loading = false
							this.errorMsg = '请求失败!'
						  })
					  })
					}
				  }
				</script>
				注意：此方式可实现任意关系组件间通信(数据)；
				总结：触发事件 (发布消息)：DOM 事件: 用户在浏览器上对应的界面上做对应的操作；自定义: 编码手动触发；
					  绑定事件监听 (订阅消息)：目标: 标签元素<button> ；事件名(类型): click/focus ；回调函数: function(event){}；
				slot：
				理解：此方式用于父组件向子组件传递`标签数据`；
				子组件: Child.vue；
				如：<template>
					<div>
					<slot name="xxx">不确定的标签结构 1</slot>
					<div>组件确定的标签结构</div>
					<slot name="yyy">不确定的标签结构 2</slot>
					</div>
					</template>				
				父组件: Parent.vue；
				<child>
				<div slot="xxx">xxx 对应的标签结构</div>
				<div slot="yyy">yyyy 对应的标签结构</div>
				</child>
		vue-ajax：
			Vue项目中常用的 2 个 ajax 库；vue-resource：vue 插件，非官方库，vue1.x 使用广泛；axios：通用的 ajax 请求库, 官方推荐，vue2.x 使用广泛；
			vue-resource：
			在线文档：https://github.com/pagekit/vue-resource/blob/develop/docs/http.md
			下载：npm install vue-resource --save；
			如：// 引入模块
			import VueResource from 'vue-resource' // 使用插件
			Vue.use(VueResource)
			// 通过 vue/组件对象发送 ajax 请求
			this.$http.get('/someUrl').then((response) => {
			// success callback
			console.log(response.data) //返回结果数据
			}, (response) => {
			// error callback
			console.log(response.statusText) //错误信息
			})
			vue-axios：
			下载：npm install axios --save；
			如：// 引入模块
			import axios from 'axios' // 发送 ajax 请求
			axios.get(url)
			.then(response => {
			console.log(response.data) // 得到返回结果数据
			})
			.catch(error => {
			console.log(error.message)
			})
			测试：接口 1: https://api.github.com/search/repositories?q=v&sort=stars
				  接口 2: https://api.github.com/search/users?q=aa
		VUE UI组件库：
			常用：Mint UI:
				  主页: http://mint-ui.github.io/#!/zh-cn；
				  说明: 饿了么开源的基于 vue 的移动端 UI 组件库；
				  Elment UI:
				  主页: http://element-cn.eleme.io/#/zh-CN；
				  说明: 饿了么开源的基于 vue 的 PC 端 UI 组件库；
			使用 Mint UI：
				下载：npm install mint-ui --save；
				实现按需打包：
				1. 下载
				npm install babel-plugin-component --save-dev；
				2. 修改 babel 配置
				"plugins": ["transform-runtime",["component", [
				{
				"libraryName": "mint-ui",
				"style": true
				}
				]]]
				组件分类：标签组件；非标签组件；
				使用：
				如：#index.html
				<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1,
				minimum-scale=1, user-scalable=no" />
				<script
				src="https://as.alipayobjects.com/g/component/fastclick/1.0.6/fastclick.js"></scrip
				t>
				<script>
				if ('addEventListener' in document) {
				document.addEventListener('DOMContentLoaded', function() {
				FastClick.attach(document.body);
				}, false);
				}
				if(!window.Promise) {
				document.writeln('<script
				src="https://as.alipayobjects.com/g/component/es6-promise/3.2.2/es6-promise.min.js"
				'+'>'+'<'+'/'+'script>');
				}
				</script>
				#main.js
				import {Button} from 'mint-ui'
				Vue.component(Button.name, Button)
				#App.vue
				<template>
				<mt-button @click="handleClick" type="primary" style="width: 100%">Test</mt-button>
				</template>
				<script>
				import {Toast} from 'mint-ui'
				export default {
					methods: {
					handleClick () {
						Toast('点击了测试');
					}
					}
				}
				</script>
		vue-router：
			理解：路由器；
			说明：官方提供的用来实现 SPA（单页应用） 的 vue 插件；
			官方文档：github: https://github.com/vuejs/vue-router；中文文档: http://router.vuejs.org/zh-cn/；
			下载: npm install vue-router --save；
			API说明：
			1) VueRouter(): 用于创建路由器的构建函数
			new VueRouter({
			// 多个配置项
			})
			2) 路由配置，src/router/index.js；
			routes: [
			{ // 一般路由
			path: '/about', 
			component: About
			},
			{ // 自动跳转路由
			path: '/', redirect: '/about' }
			]
			3) 注册路由器，main.js入口注册
			import router from './router' 
			new Vue({
			router
			})
			4) 使用路由组件标签；
			1. <router-link>: 用来生成路由链接
			<router-link to="/xxx">Go to XXX</router-link>
			2. <router-view>: 用来显示当前路由组件界面
			<router-view></router-view>
			基本路由组件：Home.vue、About.vue；
			应用组件: App.vue；
			<div>
			<!--路由链接-->
			<router-link to="/about">About</router-link>
			<router-link to="/home">Home</router-link>
			<!--用于渲染当前路由组件-->
			<router-view></router-view>
			</div>
			路由器模块：src/router/index.js；
			export default new VueRouter({
			routes: [
			{
			path: '/', redirect: '/about' },{
			path: '/about', component: About
			},{
			path: '/home', component: Home
			}
			]
			})
			注册路由器: main.js；
			import Vue from 'vue' 
			import router from './router' // 创建VUE配置路由器
			new Vue({
				el: '#app', 
				router, 
				render: h => h(app)
			})
			优化路由器配置：linkActiveClass: 'active', // 指定选中的路由链接的class；
			总结: 编写使用路由的 3 步：定义路由组件；注册路由；使用路由：<router-link> <router-view>
			嵌套路由：
			子路由组件：News.vue、Message.vue；
			配置嵌套路由: router/index.js；
			path: '/home', 
			component: home, 
			children: [
			{
			path: 'news', component: News
			},
			{
			path: 'message', component: Message
			}
			]
			路由链接: Home.vue；
			<router-link to="/home/news">News</router-link>
			<router-link to="/home/message">Message</router-link>
			<router-view></route-view>
			向路由组件传递数据：
			方式 1: 路由路径携带参数(param/query)：
			1) 配置路由
			children: [
			{
			path: 'mdetail/:id', 
			component: MessageDetail
			}
			]
			2) 路由路径
			<router-link :to="'/home/message/mdetail/'+m.id">{{m.title}}</router-link>
			3) 路由组件中读取请求参数
			this.$route.params.id
			方式 2: <router-view>属性携带数据：
			<router-view :msg="msg"></router-view>
			缓存路由组件对象：
			理解：默认情况下, 被切换的路由组件对象会死亡释放，再次回来时是重新创建的；如果可以缓存路由组件对象, 可以提高用户体验；
			使用：<keep-alive>
					<router-view></router-view>
				</keep-alive>
		编程式路由导航：
			相关API：
			1) this.$router.push(path): 相当于点击路由链接(可以返回到当前路由界面)
			2) this.$router.replace(path): 用新路由替换当前路由(不可以返回到当前路由界面)
			3) this.$router.back(): 请求(返回)上一个记录路由
			4) this.$router.go(-1): 请求(返回)上一个记录路由
			5) this.$router.go(1): 请求下一个记录路由
			完整示例说明：
			#入口JS、main.js
			import Vue from 'vue'
			import App from './App.vue'
			import router from './router'
			/* eslint-disable no-new */
			new Vue({
			  el: '#app',
			  components: {App}, // 映射组件标签
			  template: '<App/>', // 指定需要渲染到页面的模板
			  router  // 注册路由器
			})
			#App.vue
			<template>
			  <div>
				<div class="row">
				  <div class="col-xs-offset-2 col-xs-8">
					<div class="page-header"><h2>Router Test</h2></div>
				  </div>
				</div>
				<div class="row">
				  <div class="col-xs-2 col-xs-offset-2">
					<div class="list-group">
					  <!--生成路由链接-->
					  <router-link to="/about" class="list-group-item">About</router-link>
					  <router-link to="/home" class="list-group-item">Home</router-link>
					</div>
				  </div>
				  <div class="col-xs-6">
					<div class="panel">
					  <div class="panel-body">
						<!--显示当前组件-->
						<keep-alive>
						  <router-view :msg="abc"></router-view>
						</keep-alive>
					  </div>
					</div>
				  </div>
				</div>
			  </div>
			</template>
			<script>
			  export default {}
			</script>
			#index.js
			import Vue from 'vue'
			import VueRouter from 'vue-router'
			import About from '../pages/About.vue'
			import Home from '../pages/Home.vue'
			import News from '../pages/News.vue'
			import Message from '../pages/Message.vue'
			import MessageDetail from '../pages/MessageDetail.vue'
			// 内部定义并注册了2个组件标签(router-link/router-view)，给组件对象添加了2个属性:1. $router: 路由器；2. $route: 当前路由
			Vue.use(VueRouter)
			export default new VueRouter ({
			  // 注册应用中所有的路由
			  routes: [
				{
				  path: '/about',
				  component: About
				},
				{
				  path: '/home',
				  component: Home,
				  children: [
					{
					  path: '/home/news',
					  component: News
					},
					{
					  path: 'message',
					  component: Message,
					  children: [
						{
						  path:'detail/:id',
						  component: MessageDetail
						}
					  ]
					},
					{
					  path: '',
					  redirect: '/home/news'
					}
				  ]
				},
				{
				  path: '/',
				  redirect: '/about'
				}
			  ]
			})
			#Home.vue
			<template>
			  <div>
				<h2>Home</h2>
				<div>
				  <ul class="nav nav-tabs">
					<li><router-link to="/home/news">News</router-link></li>
					<li><router-link to="/home/message">Message</router-link></li>
				  </ul>
				  <router-view></router-view>
				</div>
			  </div>
			</template>
			<script>
			  export default {}
			</script>
			#About.vue
			<template>
			  <div>
				<h2>About</h2>
				<p>{{msg}}</p>
				<input type="text">
			  </div>
			</template>
			<script>
			  export default {
				props: {
				  msg: String
				}
			  }
			</script>
			#New.vue
			<template>
			  <ul>
				<li v-for="(news, index) in newsArr" :key="index">{{news}}</li>
			  </ul>
			</template>
			<script>
			  export default {
				data () {
				  return {
					newsArr: ['News001', 'News002', 'News003']
				  }
				}
			  }
			</script>
			#Message.vue
			<template>
			  <div>
				<ul>
				  <li v-for="m in messages" :key="m.id">
					<router-link :to="`/home/message/detail/${m.id}`">{{m.title}}</router-link>
					<button @click="pushShow(m.id)">push查看</button>
					<button @click="replaceShow(m.id)">replace查看</button>
				  </li>
				</ul>
				<button @click="$router.back()">回退</button>
				<hr>
				<router-view></router-view>
			  </div>
			</template>
			<script>
			  export default {
				data () {
				  return {
					messages: [
					 /* {id: 1, title: 'Message001'},{id: 3, title: 'Message003'},{id: 5, title: 'Message005'}*/
					]
				  }
				},
				//生命周期，只加载1次
				mounted () {
				  setTimeout(() => {
					const messages = [
					   {id: 1, title: 'Message001'},
					   {id: 3, title: 'Message003'},
					   {id: 5, title: 'Message005'}
					]
					this.messages = messages
				  }, 1000)
				},
				methods: {
				  pushShow (id) {
					this.$router.push(`/home/message/detail/${id}`)
				  },
				  replaceShow(id) {
					this.$router.replace(`/home/message/detail/${id}`)
				  }
				}
			  }
			</script>
			#MessageDetail.vue
			<template>
			  <ul>
				<li>id: {{this.$route.params.id}}</li>
				<li>title: {{detail.title}}</li>
				<li>content: {{detail.content}}</li>
			  </ul>
			</template>
			<script>
			  const messageDetails = [
				{id: 1, title: 'Message001', content: 'message content00111....'},
				{id: 3, title: 'Message003', content: 'message content00222....'},
				{id: 5, title: 'Message005', content: 'message content00333....'}
			  ]
			  export default {
				data() {
				  return {
					detail: {}
				  }
				},
				mounted () {// 改变当前路由组件参数数据时，不会重新创建组件对象，mounted不会重新执行
				  const id = this.$route.params.id
				  this.detail = messageDetails.find(detail => detail.id===id*1)
				},
				watch: {
				  $route: function () { // 改变当前路由组件参数数据时自动调用
					const id = this.$route.params.id
					this.detail = messageDetails.find(detail => detail.id===id*1)
				  }
				}
			  }
			</script>
		VUEX：状态管理
			理解：github 站点: https://github.com/vuejs/vuex；在线文档: https://vuex.vuejs.org/zh-cn/；简单来说: 对 vue 应用中多个组件的共享状态进行集中式的管理(读/写)；
			状态自管理应用：
			state: 驱动应用的数据源；view: 以声明方式将 state 映射到视图；actions: 响应在 view 上的用户输入导致的状态变化(包含 n 个更新状态的方法)；三者组成 一个闭环；
			多组件共享状态的问题：多个视图依赖于同一状态；来自不同视图的行为需要变更同一状态；
            以前的解决办法：将数据以及操作数据的行为都定义在父组件，将数据以及操作数据的行为传递给需要的各个子组件(有可能需要多级传递)，vuex 就是用来解决这个问题的；
			核心API：
			state：管理状态对象，是唯一的；
			格式：const state = {
					xxx: initValue
				  }
			mutations：包含多个直接更新 state 的方法(回调函数)的对象；
			谁来触发: action 中的 commit('mutation名称')；只能包含同步的代码, 不能写异步代码；
			格式：const mutations = {
					yyy (state, {data1}) {
					// 更新 state 的某个属性
				  }
				  }
			actions：包含多个事件回调函数的对象；通过执行: commit()来触发 mutation 的调用, 间接更新 state；
			谁来触发: 组件中: $store.dispatch('action名称', data1)；可以包含异步代码(定时器, ajax)；
			格式：const actions = {
					zzz ({commit, state}, data1) {
						commit('yyy', {data1})
					}
					}
			getters：包含多个计算属性(get)的对象；谁来读取: 组件中: $store.getters.xxx；
			格式：const getters = {
						mmm (state) {
						return ...
						}
					}			
			modules：包含多个 module；一个 module 是一个 store 的配置对象；与一个组件(包含有共享数据)对应；
			向外暴露 store 对象：
			格式：export default new Vuex.Store({
					   state, mutations, actions, getters
				    })
			组件中使用：
			格式：import {mapState, mapGetters, mapActions} from 'vuex' 
			export default {
				computed: {
				...mapState(['xxx']), 
				...mapGetters(['mmm']), 
				}
				methods: mapActions(['zzz'])
			}
			{{xxx}} {{mmm}} 
			@click="zzz(data)"
			映射 store：
			import store from './store' 
			new Vue({
				store
			})
			store 对象：所有用 vuex 管理的组件中都多了一个属性$store, 它就是一个 store 对象；
			属性：state: 注册的 state 对象；getters: 注册的 getters 对象；
			方法: dispatch(actionName, data): 分发调用 action；
		VUEX结构分析：
							$state.dispatch                     commit
			VUE 组件 -----------------------------> Actions ----------------> mutations
			   |              mapAction                                            | -Mutate
			     --------------------------------------------------------------- State
									Render （mapGetters()、mapState()）										
		完整示例：
			#搜索示例
			#入口，main.js
			import Vue from 'vue'
			import App from './App.vue'
			import store from './vuex/store'
			// 创建vm
			/* eslint-disable no-new */
			new Vue({
			  el: '#app',
			  render: h => h(App),
			  store
			})
			/*
			new Vue({
			  el: '#app',
			  components: {App}, // 映射组件标签
			  template: '<App/>', // 指定需要渲染到页面的模板
			  store
			})*/
			#应用组件App.vue
			<template>
			  <div class="container">
				<Search/>
				<UsersMain/>
			  </div>
			</template>
			<script>
			  import Search from './components/Search.vue'
			  import Main from './components/Main.vue'

			  export default {
				components: {
				  Search,// 映射组件标签
				  UsersMain: Main
				}
			  }
			</script>
			#基本组件-Search.vue
			<template>
			  <section class="jumbotron">
				<h3 class="jumbotron-heading">Search Github Users</h3>
				<div>
				  <input type="text" placeholder="enter the name you search" v-model="searchName"/>
				  <button @click="search">Search</button>
				</div>
			  </section>
			</template>
			<script>
			  export default {
				data () {
				  return {
					searchName: ''
				  }
				},
				methods: {
				  search () {
					const searchName = this.searchName.trim()
					if(searchName) {
					  this.$store.dispatch('search', searchName)
					}
				  }
				}
			  }
			</script>
			#基本组件-Main.vue
			<template>
			  <div>
				<h2 v-show="firstView">请输入关键字搜索</h2>
				<h2 v-show="loading">请求中...</h2>
				<h2 v-show="errorMsg">{{errorMsg}}</h2>
				<div class="row" v-show="users.length>0">
				  <div class="card" v-for="(user, index) in users" :key="index">
					<a :href="user.url" target="_blank">
					  <img :src="user.avatarUrl" style='width: 100px'/>
					</a>
					<p class="card-text">{{user.username}}</p>
				  </div>
				</div>
			  </div>
			</template>
			<script>
			  import {mapState} from 'vuex'
			  export default {
				computed: {
				  ...mapState(['firstView', 'loading', 'errorMsg', 'users'])
				}
			  }
			</script>
			#state.js
			export default {
			  firstView: true, // 是否显示初始页面
			  loading: false, // 是否正在请求中
			  users: [], // 用户数组
			  errorMsg: ''  //错误信息
			}
			#mutations.js
			import {REQUESTING, REQUEST_SUCCESS, REQUEST_ERROR} from './mutation-types'
			export default {
			  [REQUESTING] (state) {
				state.firstView = false
				state.loading = true
				state.users = []
				state.errorMsg = ''
			  },
			  [REQUEST_SUCCESS] (state, {users}) {
				state.loading = false
				state.users = users
			  },
			  [REQUEST_ERROR] (state, {msg}) {
				state.loading  = false
				state.errorMsg = msg
			  },
			}
			#mutations-types.js
			export const REQUESTING = 'requesting' // 请求中
			export const REQUEST_SUCCESS = 'request_success' // 请求成功
			export const REQUEST_ERROR = 'request_error' // 请求失败
			#actions.js
			import axios from 'axios'
			import {REQUESTING, REQUEST_SUCCESS, REQUEST_ERROR} from './mutation-types'
			export default {
			  search({commit}, searchName) {
				// 提交mutation: 更新状态(请求中)
				commit(REQUESTING)
				// 发送异步ajax请求获取数据
				const url = `https://api.github.com/search/users?q=${searchName}`
				axios.get(url)
				  .then(response => {
					// 成功了, 提交mutation: 更新状态(成功)
					const users = response.data.items.map(item => ({
					  url: item.html_url,
					  avatarUrl: item.avatar_url,
					  username: item.login
					}))
					commit(REQUEST_SUCCESS, {users})
				  })
				  .catch(error => {
					// 失败了, 提交mutation: 更新状态(失败)
					commit(REQUEST_ERROR, {msg: '请求失败'})
				  })
			  }
			}
			#getters.js
			export default {
			}
			#store.js
			import Vue from 'vue'
			import Vuex from 'vuex'
			import state from './state'
			import mutations from './mutations'
			import actions from './actions'
			import getters from './getters'
			Vue.use(Vuex)
			export default new Vuex.Store({
			  state,
			  mutations,
			  actions,
			  getters
			})
			#计数器示例
			#store.js
			import Vue from 'vue'
			import Vuex from 'vuex'
			Vue.use(Vuex)
			const state = {
				count: 0 // 初始化状态数据
			}
			// mutations 对象，包含个方法: 
			// 能直接更新 state 一个方法就是一个 mutation，mutation 只能包含更新 state 的同步代码,也不会有逻辑；
			// mutation 由 action 触发调用: commit('mutationName')；
			const mutations = {
				INCREMENT(state) {
					state.count++
				},
				DECREMENT (state) { // ctrl + shift + x
					state.count--
				}
			}
			// actions 对象，包含个方法: 触发 mutation 调用, 间接更新 state 一个方法就是一个 action
			// action 中可以有逻辑代码和异步代码；action 由组件来触发调用: this.$store.dispatch('actionName')；
			const actions = {
				increment ({commit}) {
					commit('INCREMENT')
				},
				decrement ({commit}) {
					commit('DECREMENT')
				},
				incrementIfOdd ({commit, state}) {
					if(state.count%2===1) {
					commit('INCREMENT')
					}
				},
				incrementAsync ({commit}) {
					setTimeout(() => {
					commit('INCREMENT')
					}, 1000)
				}
			}			
			const getters = {
				oddOrEven (state) {
				return state.count%2===0 ? '偶数' : '奇数'
				},
				count (state) {
				return state.count
				}
			}
			//向外暴露 store 实例对象
			export default new Vuex.Store({
				state,
				mutations,
				actions,
				getters
			})
			#main.js
			import Vue from 'vue'
			import app from './app1.vue'
			// import app from './app.vue'
			import store from './store'
			new Vue({
			el: '#app',
			render: h => h(app),
			store // 所有组件都多个一个属性: $store
			})
			#app.vue（优化前）
			<template>
				<div>
				<p>clicked: {{$store.state.count}} times, count is {{oddOrEven}}</p>
				<button @click="increment">+</button>
				<button @click="decrement">-</button>
				<button @click="incrementIfOdd">increment if odd</button>
				<button @click="incrementAsync">increment async</button>
				</div>
			</template>
			<script>
			export default {
			computed: {
				oddOrEven () {
					return this.$store.getters.oddOrEven
				}
			},
			methods: {
				increment () {
					this.$store.dispatch('increment')
				},
				decrement () {
					this.$store.dispatch('decrement')
				},
				incrementIfOdd () {
					this.$store.dispatch('incrementIfOdd')
				},
				incrementAsync () {
					this.$store.dispatch('incrementAsync')
				}
			}
			}
			</script>
			#app1.vue（优化后）
			<template>
				<div>
				<p>clicked: {{count}} times, count is {{oddOrEven}}</p>
				<button @click="increment">+</button>
				<button @click="decrement">-</button>
				<button @click="incrementIfOdd">increment if odd</button>
				<button @click="incrementAsync">increment async</button>
				</div>
			</template>
			<script>
			import {mapGetters, mapActions} from 'vuex'
			export default {
			computed: mapGetters({ // 名称不一样
				oddOrEven: 'oddOrEven',
				count: 'count'
			}),
			methods: mapActions(['increment', 'decrement', 'incrementIfOdd','incrementAsync']) // 名称一样			
			}
			</script>
			
----------------------------------------------大数据定制技术篇----------------------------------------------------------------------------------	
	一、大数据：
		概念：Big Data，指的是一段时间范围内内无法使用常规的工具[JavaEE]处理数据集合，需要新的处理模式来处理海量、高增长率、多样化的信息。主要解决的是海量的数据存储与海量的数据分析计算问题。
		数据的存储单位：
			bit、Byte、KB、MB、GB、TB、PB、EB、ZB、YB、BB、NB、DB 
			转化：除了1Byte=8bit，其他都是间隔1024
		特点：4V + 4高
			4V：Volume[海量]：人类的数据总量达到EB级别
				Velocity[实时/高速]：如每年天猫双十一
				Variety[多样]：结构化[数据库/文本]与非结构化[网络日志、音视频、地理位置]数据
				Value[价值密度]：低价值密度
			4高：
				高可靠[高性能]：多个数据副本
				高可扩[高扩展]：集群下任意扩展节点
				高效率[高并发]：并行工作
				高容错：
				
		运用场景：
			物流仓储[如京东]、零售[分析用户行为]、旅游、商品的广告推荐、金融、保险、房产、人工智能AI...
		发展前景：
			政策支持、人才缺口、工资高
		大数据部门的业务流程：
			产品经理[人员]提要求[统计指标]	-------------->数据部门搭建数据平台、分析数据 ----------->数据可视化[JavaEE]
		大数据部门的组织结构[适用于大中型企业]：
			平台组：[技术] 															--平台搭建[hadoop、Flume[日志收集]、Spark[数据挖掘、分析]、Kafka[消息队列]、Hbase[数据存储]]、集群监控、集群调优
			数据仓库组：[业务]													    --ETL工程师[抽取、转化、加载]：数据清洗；Hive[数据查询]工程师：数据分析、数据仓库建模
			数据挖掘组：														    --算法、推荐系统、用户头像工程师
			报表开发组：JavaEE
		大数据技术生态圈体系
			数据来源层：结构化数据[数据库]、半结构化数据[文件日志]、非结构化数据[音视频]
			数据传输层[DTL]：Sqoop数据传递、Flume日志收集
				Sqoop是一款开源的工具，主要用于在Hadoop、Hive(数据查询)与传统的数据库(MySql)间进行数据的传递，可以将一个关系型数据库中的数据导进到Hadoop的HDFS中，也可以将HDFS的数据导进到关系型数据库中
				Flume是Cloudera提供的一个高可用的，高可靠的，分布式的海量日志采集、聚合和传输的系统，Flume支持在日志系统中定制各类数据发送方，用于收集数据；同时，Flume提供对数据进行简单处理，并写到各种数据接受方（可定制）的能力
			数据存储层：HDFS文件存储、HBase非关系型数据库、Kafka消息队列
				Kafka是一种高吞吐量的分布式发布订阅消息系统，有如下特性：
				（1）通过O(1)的磁盘数据结构提供消息的持久化，这种结构对于即使数以TB的消息存储也能够保持长时间的稳定性能。
				（2）高吞吐量：即使是非常普通的硬件Kafka也可以支持每秒数百万的消息。
				（3）支持通过Kafka服务器和消费集群来分区消息。
				（4）支持Hadoop并行数据加载。
				HBase是一个分布式的、面向列的开源数据库。HBase不同于一般的关系数据库，它是一个适合于非结构化数据存储的数据库
			资源管理层：Yarn资源管理
			数据计算层：离线计算、内存计算、实时计算
				离线计算：MapReduce[Hive数据查询、Mahout数据挖掘]
					Hive是基于Hadoop的一个数据仓库工具，可以将结构化的数据文件映射为一张数据库表，并提供简单的SQL查询功能，可以将SQL语句转换为MapReduce任务进行运行。 
				        其优点是学习成本低，可以通过类SQL语句快速实现简单的MapReduce统计，不必开发专门的MapReduce应用，十分适合数据仓库的统计分析
					Apache Mahout是个可扩展的机器学习和数据挖掘库
				内存计算：Spark[Spark Milib数据挖掘、Spark R数据分析、Spark SQL数据查询。Spark Streaming实时计算]
					Spark是当前最流行的开源大数据内存计算框架，可以基于Hadoop上存储的大数据进行计算。
					R是用于统计分析、绘图的语言和操作环境。R是属于GNU系统的一个自由、免费、源代码开放的软件，它是一个用于统计计算和统计制图的优秀工具。
				实时计算：Stream
					Storm用于“连续计算”，对数据流做连续查询，在计算时就将结果以流的形式输出给用户
			任务调度层：Oozie任务调度、AzKaban任务调度			
				Oozie是一个管理Hdoop作业（job）的工作流程调度管理系统
			业务模型层[JavaEE]：业务模型、数据可视化、业务运用
			数据平台的调度与配置：Zookeeper
				Zookeeper是Google的Chubby一个开源的实现。它是一个针对大型分布式系统的可靠协调系统，提供的功能包括：配置维护、名字服务、 分布式同步、组服务等。
				ZooKeeper的目标就是封装好复杂易出错的关键服务，将简单易用的接口和性能高效、功能稳定的系统提供给用户
			
	二、Hadoop
			含义：Hadoop是一个由Apache基金会所开发的分布式系统基础架构，主要解决的是海量数据的存储和海量数据的分析计算问题。
				  广义上来说，HADOOP通常是指一个更广泛的概念——HADOOP生态圈。
			发展历史：Lucene ->Nutch -> Hadoop
				1）Lucene--Doug Cutting开创的开源软件，用java书写代码，实现与Google类似的全文搜索功能，它提供了全文检索引擎的架构，包括完整的查询引擎和索引引擎 
				2）2001年年底成为apache基金会的一个子项目			
				3）对于大数量的场景，Lucene面对与Google同样的困难，存储数据困难，检索数据慢。			  
				4）学习和模仿Google解决这些问题的办法 ：微型版Nutch				  
				5）可以说Google是hadoop的思想之源
					GFS --->HDFS
					Map-Reduce --->MR
					BigTable --->Hbase				  
				6）2003-2004年，Google公开了部分GFS和MapReduce思想的细节，以此为基础Doug Cutting等人用了2年业余时间实现了HDFS和MapReduce机制，使Nutch性能飙升 				  
				7）2005 年Hadoop作为Lucene的子项目Nutch的一部分正式引入Apache基金会。2006 年 3 月份，MapReduce和Nutch Distributed File System (NDFS) 分别被纳入称为 Hadoop 的项目中 				  
				9）Hadoop就此诞生并迅速发展，标志这云计算时代来临
			版本：
				Apache、Cloudera、Hortonworks
				Apache：最原始（最基础）的版本，对于入门学习最好
				Cloudera：在大型互联网企业中用的较多，收费
				Hortonworks：文档较好
			组成：
				Hadoop1.x与Hadoop2.x区别：
					Hadoop1.x：MapReduce（计算+资源调度）、HDFS（数据存储）、Common（辅助工具）
					Hadoop2.x：MapReduce（计/运算）Yarn（资源调度）、HDFS（数据存储）、Common（辅助工具）
				HDFS：是一个高可靠、高吞吐量的分布式文件系统。构成：
					NameNode[目录]：存储文件的元数据，如：文件名、文件目录名、文件属性...
					DataNode[资源]：数据
					Secondary NameNode：监控HDFS后台服务
				Yarn：
					构成：
						1）ResourceManager(rm)：处理客户端请求、启动/监控ApplicationMaster、监控NodeManager、资源分配与调度；
						2）NodeManager(nm)：单个节点上的资源管理、处理来自ResourceManager的命令、处理来自ApplicationMaster的命令；
						3）ApplicationMaster：数据切分、为应用程序申请资源(CPU、硬盘...)，并分配给内部任务、任务监控与容错;
						4）Container：对任务运行环境的抽象，封装了CPU、内存等多维资源以及环境变量、启动命令等任务运行相关的信息
				MapReduce：
					构成：MapReduce将计算过程分为两个阶段：Map和Reduce
						  1）Map阶段并行处理输入数据
					      2）Reduce阶段对Map结果进行汇总
			环境搭建：
				环境准备：
					安装JDK、安装Hadoop[可以配置环境变量]
			目录结构：
				（1）bin目录：存放对Hadoop相关服务（HDFS，YARN）进行操作的脚本
				（2）etc目录：Hadoop的配置文件目录，存放Hadoop的配置文件
				（3）lib目录：存放Hadoop的本地库（对数据进行压缩解压缩功能）
				（4）sbin目录：存放启动或停止Hadoop相关服务的脚本
				（5）share目录：存放Hadoop的依赖jar包、文档、和官方案例
			运行模式：
				本地模式、伪分布式模式以及完全分布式模式
				本地运行模式：不需要启用单独进程，直接可以运行，测试和开发时使用。
					官方示例：
					安装路径：opt/module/hadoop-2.7.2/
						Grep案例：
							1）在安装路径下创建一个input文件夹，mkdir input
							2）将Hadoop的xml配置文件复制到input，cp ./etc/hadoop/*.xml input
							3）执行share目录下的MapReduce程序，./bin/hadoop jar
															   share/hadoop/mapreduce/hadoop-mapreduce-examples-2.7.2.jar grep ./input/ output 'dfs[a-z.]+'
							4）查看输出结果，cat ./output/*	
						WordCount案例：
							1）在安装路径下创建一个wcinput文件夹，mkdir wcinput
							2）在wcinput文件夹下创建文件wc.iput并输入内容保存， touch wc.input
								内容如：zhangsan lisi wangwu lisi zhaoliu 
							3）执行share目录下的MapReduce程序，hadoop jar
																share/hadoop/mapreduce/hadoop-mapreduce-examples-2.7.2.jar wordcount ./wcinput/ wcoutput
							4）查看输出结果，cat wcoutput/part-r-00000，即可查看统计内容出现的次数
				
				伪分布式运行模式：等同于完全分布式，只有一个节点。
					启动HDFS并运行MapReduce程序：
						环境准备：
							准备1台客户机[hadoop101]、安装jdk并配置环境变量、安装hadoop并配置环境变量、配置集群、
							启动、测试集群增、删、查、执行wordcount案例
						步骤：
							1）配置集群
								配置：hadoop-env.sh <!-- 修改JAVA_HOME 路径 -->
										Linux系统中获取JDK的安装路径：echo $JAVA_HOME   ->/opt/module/jdk1.8.0_144									
										修改JAVA_HOME 路径：export JAVA_HOME=/opt/module/jdk1.8.0_144
								      core-site.xml <!--Hadoop公用配置-->
										<!-- 指定HDFS中NameNode的地址 -->
										<property>
											<name>fs.defaultFS</name>
											<value>hdfs://hadoop101:9000</value>
										</property>
										<!-- 指定Hadoop运行时产生文件的存储目录 -->
										<property>
											<name>hadoop.tmp.dir</name>
											<value>/opt/module/hadoop-2.7.2/data/tmp</value>
										</property>
									  hdfs-site.xml hdfs自定义配置
										<!-- 指定HDFS副本的数量 -->
										<property>
											<name>dfs.replication</name>
											<value>1</value>
										</property>
							2）启动集群
									格式化NameNode：bin/hdfs namenode -format 注意：初次启动时格式化，以后就不要总格式化							 
									启动NameNode：sbin/hadoop-daemon.sh start namenode									 
									启动DataNode：sbin/hadoop-daemon.sh start datanode
						
							3）查看集群
									查看是否启动成功：jps，结果如下：[注意：jps是JDK中的命令，不是Linux命令。]
									13586 NameNode
									13668 DataNode
									13786 Jps
									web端查看HDFS文件系统：http://hadoop101:50070/dfshealth.html#tab-overview
								    查看产生的Log日志：
										当前目录路径下会生成logs文件夹：/opt/module/hadoop-2.7.2/logs
									思考：为什么不能一直格式化NameNode，格式化NameNode，要注意什么？？？
										在运行的存储临时目录下：data/tmp/dfs/name/current/或data/tmp/dfs/data/current/中产生VERSION文件存储了clusterID是相同的。
										结论：格式化NameNode，会产生新的clusterID,导致NameNode和DataNode的clusterID不一致，集群找不到已往数据。
											  所以格式NameNode时，一定要先删除data数据和log日志，然后再格式化NameNode。
							4）操作集群[执行wordcount案例]
									在HDFS文件系统上创建一个input文件夹：bin/hdfs dfs -mkdir -p /user/atguigu/input
								    将测试文件内容上传到文件系统上：bin/hdfs dfs -put wcinput/wc.input /user/atguigu/input/
									查看上传的文件是否正确：bin/hdfs dfs -ls  /user/atguigu/input/ 或 bin/hdfs dfs -cat /user/atguigu/input/wc.input
									运行MapReduce程序：bin/hadoop jar
													   share/hadoop/mapreduce/hadoop-mapreduce-examples-2.7.2.jar wordcount /user/atguigu/input/ /user/atguigu/output
									查看输出结果：bin/hdfs dfs -cat /user/atguigu/output/*
									将测试文件内容下载到本地：bin/hdfs dfs -get /user/atguigu/output/part-r-00000 ./wcoutput/
									删除输出结果：hdfs dfs -rm -r /user/atguigu/output	
									
					启动YARN并运行MapReduce程序:
						环境准备：
							准备1台客户机、安装jdk并配置环境变量、安装hadoop并配置环境变量、配置集群在YARN上运行MR、
							启动、测试集群增、删、查、在YARN上执行WordCount案例
						步骤：
							1）配置集群
								配置：yarn-env.sh 修改JAVA_HOME 路径
										Linux系统中获取JDK的安装路径：echo $JAVA_HOME   ->/opt/module/jdk1.8.0_144									
										修改JAVA_HOME 路径：export JAVA_HOME=/opt/module/jdk1.8.0_144
									  yarn-site.xml <!-- yarn自定义配置 -->
										<!-- Reducer获取数据的方式 -->
										<property>
												<name>yarn.nodemanager.aux-services</name>
												<value>mapreduce_shuffle</value>
										</property>
										<!-- 指定YARN的ResourceManager的地址 -->
										<property>
											<name>yarn.resourcemanager.hostname</name>
											<value>hadoop101</value>
										</property>
									  mapred-env.sh 修改JAVA_HOME 路径
									    Linux系统中获取JDK的安装路径：echo $JAVA_HOME   ->/opt/module/jdk1.8.0_144									
										修改JAVA_HOME 路径：export JAVA_HOME=/opt/module/jdk1.8.0_144
									  mapred-site.xml <!-- mapreduce自定义配置 -->
										重命名：mv mapred-site.xml.template mapred-site.xml 
										<!-- 指定MR运行在YARN上 -->
										<property>
												<name>mapreduce.framework.name</name>
												<value>yarn</value>
										</property>
							2）启动集群
									启动前必须保证NameNode和DataNode已经启动[HDFS服务启动]
								    启动ResourceManager：sbin/yarn-daemon.sh start resourcemanager
									启动NodeManager：sbin/yarn-daemon.sh start nodemanager
							3）集群操作
									YARN的浏览器页面查看：http://hadoop101:8088/cluster
									删除文件系统上的output文件：bin/hdfs dfs -rm -R /user/atguigu/output
									执行MapReduce程序：bin/hadoop jar
													   share/hadoop/mapreduce/hadoop-mapreduce-examples-2.7.2.jar wordcount /user/atguigu/input  /user/atguigu/output
									查看运行结果：bin/hdfs dfs -cat /user/atguigu/output/*
					
					配置历史服务器MR：为了查看程序的历史运行情况，需要配置一下历史服务器
						配置：mapred-site.xml <!-- mapreduce自定义配置-->
							<!-- 历史服务器端地址 -->
							<property>
								<name>mapreduce.jobhistory.address</name>
								<value>hadoop101:10020</value>
							</property>
							<!-- 历史服务器web端地址 -->
							<property>
								<name>mapreduce.jobhistory.webapp.address</name>
								<value>hadoop101:19888</value>
							</property>
						启动历史服务器：sbin/mr-jobhistory-daemon.sh start historyserver
						查看历史服务器是否启动：jps
						查看JobHistory：http://hadoop101:19888/jobhistory
					
					配置日志的聚集[YARN中配置]
						日志聚集概念：应用运行完成以后，将程序运行日志信息上传到HDFS系统上，可以方便的查看到程序运行详情，方便开发调试。
						注意：开启日志聚集功能，需要重新启动NodeManager 、ResourceManager和HistoryManager。
						步骤：
							配置：yarn-site.xml 
								<!-- 日志聚集功能使能 -->
								<property>
									<name>yarn.log-aggregation-enable</name>
									<value>true</value>
								</property>
								<!-- 日志保留时间设置7天 -->
								<property>
									<name>yarn.log-aggregation.retain-seconds</name>
									<value>604800</value>
								</property>
							关闭NodeManager 、ResourceManager和HistoryManager：
								sbin/yarn-daemon.sh stop resourcemanager
								sbin/yarn-daemon.sh stop nodemanager
								sbin/mr-jobhistory-daemon.sh stop historyserver
							启动NodeManager 、ResourceManager和HistoryManager：
								sbin/yarn-daemon.sh start resourcemanager
								sbin/yarn-daemon.sh start nodemanager
								sbin/mr-jobhistory-daemon.sh start historyserver
							删除HDFS上已经存在的输出文件：bin/hdfs dfs -rm -R /user/atguigu/output
							执行WordCount程序：hadoop jar
											   share/hadoop/mapreduce/hadoop-mapreduce-examples-2.7.2.jar wordcount /user/atguigu/input /user/atguigu/output	
							查看日志：http://hadoop101:19888/jobhistory
				
				配置文件说明：Hadoop配置文件分两类：默认配置文件和自定义配置文件，只有用户想修改某一默认配置值时，才需要修改自定义配置文件，更改相应属性值
					默认配置文件：存放在hadoop相应的jar包中
					自定义配置文件：core-site.xml、hdfs-site.xml、yarn-site.xml、mapred-site.xml四个配置文件存放在$HADOOP_HOME/etc/hadoop这个路径上，用户可以根据项目需求重新进行修改配置。

				完全分布式运行模式[重点]：多个节点一起运行。	
					环境准备：
						准备3台客户机（关闭防火墙、静态ip、主机名称，分别为：102、103、104）、安装jdk并配置环境变量、安装hadoop并配置环境变量、
						配置集群、单点启动、配置ssh、群起并测试集群
							注：[学习阶段]可以从已安装好的Linux客户机copy三份来使用，主要修改的配置有：
							vim /etc/udev/rules.d/70-persistent-net.rules                   -获取address地址
							vim /etc/sysconfig/network-scripts/ifcfg-eth0					-修改address地址和IP地址
							vim /etc/sysconfig/network										-添加主机名称
							vim /etc/hosts													-添加映射
					集群分发脚本xsync：
						前提准备：
							scp（secure copy）安全拷贝：
								含义：scp可以实现服务器与服务器之间的数据拷贝[from server1 to server2]。
								基本语法:
								scp    -r          $pdir/$fname              $user@hadoop$host:$pdir/$fname
								命令   递归       要拷贝的文件路径/名称    目的用户@主机:目的路径/名称
							步骤：[hadoop101是实现准备好的客户机]								
								在hadoop101上，将hadoop101中/opt/module目录下的软件拷贝到hadoop102上
									scp -r /opt/module  root@hadoop102:/opt/module
								在hadoop103上，将hadoop101服务器上的/opt/module目录下的软件拷贝到hadoop103上
									sudo scp -r atguigu@hadoop101:/opt/module root@hadoop103:/opt/module
								在hadoop103上操作将hadoop101中/opt/module目录下的软件拷贝到hadoop104上
									scp -r atguigu@hadoop101:/opt/module root@hadoop104:/opt/module
								注意：拷贝过来的/opt/module目录，别忘了在hadoop102、hadoop103、hadoop104上修改所有文件的所有者和所有者组。
									  使用：sudo chown atguigu:atguigu -R /opt/module
								将hadoop101中/etc/profile文件拷贝到hadoop102、hadoop103、hadoop104的/etc/profile上
									sudo scp /etc/profile root@hadoop102:/etc/profile
									sudo scp /etc/profile root@hadoop103:/etc/profile
									sudo scp /etc/profile root@hadoop104:/etc/profile
								在hadoop102、hadoop103、hadoop104 的客户机上分别执行：source /etc/profile 
							
							rsync 远程同步工具
								含义：主要用于备份和镜像。具有速度快、避免复制相同内容和支持符号链接的优点。
								rsync和scp区别：用rsync做文件的复制要比scp的速度快，rsync只对差异文件做更新。scp是把所有文件都复制过去。
								基本语法：
									rsync    -rvl       $pdir/$fname              $user@hadoop$host:$pdir/$fname
									命令   选项参数   要拷贝的文件路径/名称    目的用户@主机:目的路径/名称
									参数说明：-r：递归；-v：显示复制过程；-l：拷贝符号链接
									如：rsync -rvl /opt/software/ root@hadoop102:/opt/software
						集群分发脚本：
							1）在当前用户的家目录下新建脚本，如：/home/atguigu/bin，注意：：如果将xsync放到/home/atguigu/bin目录下仍然不能实现全局使用，可以将xsync移动到/usr/local/bin目录下或添加到系统的PATH变量里去。
								touch xsync
							2）编辑内容，格式如下：
								#!/bin/bash
								#1 获取输入参数个数，如果没有参数，直接退出
								pcount=$#
								if((pcount==0)); then
								echo no args;
								exit;
								fi

								#2 获取文件名称
								p1=$1
								fname=`basename $p1`
								echo fname=$fname

								#3 获取上级目录到绝对路径
								pdir=`cd -P $(dirname $p1); pwd`
								echo pdir=$pdir

								#4 获取当前用户名称
								user=`whoami`

								#5 循环
								for((host=103; host<105; host++)); do
										echo ------------------- hadoop$host --------------
										rsync -rvl $pdir/$fname $user@hadoop$host:$pdir
								done
							3）修改脚本 xsync 具有执行权限：chmod 777 xsync
							4）调用脚本形式：xsync 文件名称
					集群配置：
						集群部署规划：HDFS YARN
							hadoop102 ：NameNode DataNode NodeManager		
							hadoop103 ：DataNode ResourceManager NodeManager
							hadoop104 :	SecondaryNameNode DataNode NodeManager
							重点解释：hadoop102 配置 NameNode
									  hadoop103 配置 ResourceManager
									  hadoop104 配置 SecondaryNameNode
								这三点分别配置在不同的客户机上
						配置集群[先配置好一台服务器，如：hadoop102，再集群分发同步过去]：
							1）配置core-site.xml <!-- 公共配置 -->
								<!-- 指定HDFS中NameNode的地址，namenode常用的端口：9000、50070、8088、50090、19888 -->
								<property>
										<name>fs.defaultFS</name>
									  <value>hdfs://hadoop102:9000</value>
								</property>
								<!-- 指定Hadoop运行时产生文件的存储目录 -->
								<property>
										<name>hadoop.tmp.dir</name>
										<value>/opt/module/hadoop-2.7.2/data/tmp</value>
								</property>
							2）配置HDFS配置文件
							   配置hadoop-env.sh  export JAVA_HOME=/opt/module/jdk1.8.0_144
							   配置hdfs-site.xml <!-- hdfs的配置 -->
							   <property>
										<name>dfs.replication</name>
										<value>3</value>
								</property>
								<!-- 指定Hadoop辅助名称节点主机配置 -->
								<property>
									  <name>dfs.namenode.secondary.http-address</name>
									  <value>hadoop104:50090</value>
								</property>
							3）配置YARN配置文件
							   配置yarn-env.sh export JAVA_HOME=/opt/module/jdk1.8.0_144
							   配置yarn-site.xml <!-- yarn的配置 -->
							   !-- Reducer获取数据的方式 -->
								<property>
										<name>yarn.nodemanager.aux-services</name>
										<value>mapreduce_shuffle</value>
								</property>
								<!-- 指定YARN的ResourceManager的地址 -->
								<property>
										<name>yarn.resourcemanager.hostname</name>
										<value>hadoop103</value>
								</property>
							4）MapReduce配置文件
							   配置mapred-env.sh export JAVA_HOME=/opt/module/jdk1.8.0_144
							   配置mapred-site.xml <!-- mr的配置 -->
							   重命名：cp mapred-site.xml.template mapred-site.xml
							   <!-- 指定MR运行在Yarn上 -->
								<property>
										<name>mapreduce.framework.name</name>
										<value>yarn</value>
								</property>
						集群分发：
							在hadoop102上执行：xsync /opt/module/hadoop-2.7.2/
						查看文件分发情况：
							如在hadoop103上面执行：cat /opt/module/hadoop-2.7.2/etc/hadoop/core-site.xml 看看文件是否与hadoop102同步
					
					集群单点启动
						1）如果集群是第一次启动，需要格式化NameNode
							[atguigu@hadoop102 hadoop-2.7.2]$ hadoop namenode -format 或 bin/hdfs namenode -format 
						2）在hadoop102上启动NameNode
							[atguigu@hadoop102 hadoop-2.7.2]$ hadoop-daemon.sh start namenode
							[atguigu@hadoop102 hadoop-2.7.2]$ jps
							3461 NameNode
						3）在hadoop102、hadoop103以及hadoop104上分别启动DataNode
							[atguigu@hadoop102 hadoop-2.7.2]$ hadoop-daemon.sh start datanode
							[atguigu@hadoop102 hadoop-2.7.2]$ jps
							[atguigu@hadoop103 hadoop-2.7.2]$ hadoop-daemon.sh start datanode
							[atguigu@hadoop103 hadoop-2.7.2]$ jps
							[atguigu@hadoop104 hadoop-2.7.2]$ hadoop-daemon.sh start datanode
							[atguigu@hadoop104 hadoop-2.7.2]$ jps
						问题：每次都一个一个节点启动，效率低下
					
					SSH无密登录配置
						原理：
										ssh访问B（数据用私钥A加密）			（B接收到数据用公钥A解密）
						A服务器		------------------------------------------>B服务器
				（ssh-key-gen/生成密钥对[公/私钥A]）						  （公钥A存储在Authorized_key）
									<------------------------------------------
				（用私钥A解密返回的数据）		采用公钥A加密数据返回A
				
						语法：ssh 另一台电脑的ip地址/域名
						
						生成公钥/私钥：在家目录的.ssh文件夹下执行：ssh-keygen -t rsa 回车三次，就会生成两个文件id_rsa（私钥）、id_rsa.pub（公钥）
						将公钥拷贝到要免密登录的目标机器上，如：
							ssh-copy-id hadoop102
							ssh-copy-id hadoop103
							ssh-copy-id hadoop104
						注意：
							还需要在hadoop102上采用root账号，配置一下无密登录到hadoop102、hadoop103、hadoop104；
							还需要在hadoop103上采用atguigu账号配置一下无密登录到hadoop102、hadoop103、hadoop104服务器上。
						
						.ssh文件夹下文件解释：
							known_hosts	记录ssh访问过计算机的公钥(public key)
							id_rsa	生成的私钥
							id_rsa.pub	生成的公钥
							authorized_keys	存放授权过得无密登录服务器公钥
					
					群起集群
						配置slaves
						路径：/opt/module/hadoop-2.7.2/etc/hadoop/slaves下添加内容：
							hadoop102
							hadoop103
							hadoop104
						注意：该文件中添加的内容结尾不允许有空格，文件中不允许有空行。
						同步所有节点配置文件，[atguigu@hadoop102 hadoop]$ xsync slaves
					启动集群
						1）如果集群是第一次启动，需要格式化NameNode（注意格式化之前，一定要先停止上次启动的所有namenode和datanode进程，然后再删除data和log数据）
							[atguigu@hadoop102 hadoop-2.7.2]$ bin/hdfs namenode -format
						2）启动HDFS
							[atguigu@hadoop102 hadoop-2.7.2]$ sbin/start-dfs.sh
							[atguigu@hadoop102 hadoop-2.7.2]$ jps
							4166 NameNode
							4482 Jps
							4263 DataNode
							[atguigu@hadoop103 hadoop-2.7.2]$ jps
							3218 DataNode
							3288 Jps
							[atguigu@hadoop104 hadoop-2.7.2]$ jps
							3221 DataNode
							3283 SecondaryNameNode
							3364 Jps
						3）启动YARN
							[atguigu@hadoop103 hadoop-2.7.2]$ sbin/start-yarn.sh
							注意：NameNode和ResourceManger如果不是同一台机器，不能在NameNode上启动 YARN，应该在ResouceManager所在的机器上启动YARN。
						4）Web端查看SecondaryNameNode，浏览器中输入：http://hadoop104:50090/status.html
					
					集群基本测试
						1）上传文件到集群
							上传小文件
							[atguigu@hadoop102 hadoop-2.7.2]$ hdfs dfs -mkdir -p /user/atguigu/input
							[atguigu@hadoop102 hadoop-2.7.2]$ hdfs dfs -put wcinput/wc.input /user/atguigu/input
							上传大文件
							[atguigu@hadoop102 hadoop-2.7.2]$ bin/hadoop fs -put /opt/software/hadoop-2.7.2.tar.gz  /user/atguigu/input
						2）上传文件后查看文件存放在什么位置
						   查看HDFS文件存储路径
						   [atguigu@hadoop102 subdir0]$ pwd
						   /opt/module/hadoop-2.7.2/data/tmp/dfs/data/current/BP-938951106-192.168.10.107-1495462844069/current/finalized/subdir0/subdir0
					
					集群启动/停止方式总结
						1.	各个服务组件逐一启动/停止
							（1）分别启动/停止HDFS组件
								hadoop-daemon.sh  start / stop  namenode / datanode / secondarynamenode
							（2）启动/停止YARN
								yarn-daemon.sh  start / stop  resourcemanager / nodemanager
						2.	各个模块分开启动/停止（配置ssh是前提）常用
							（1）整体启动/停止HDFS
								start-dfs.sh   /  stop-dfs.sh
							（2）整体启动/停止YARN
								start-yarn.sh  /  stop-yarn.sh
					集群时间同步
						
						   
	三、Zookeeper
		简介：
		
	四、Kafka
		简介：
		
				
			
			
					
			
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	