vnote_backup_file_826537664 D:/工作/学习资料/study-notes/笔记/计算机技术/SpringBoot技术.md
# SpringBoot技术
一、基本概念：
	特点：开箱即用，自动配置
	配置文件：YAML 的基本使用-支持文档块
	配置文件值的注入：
	方式一：@ConfigurationProperties
		格式：
		javaBean
		@Component
		@ConfigurationProperties(prefix = "person")
		//@Validated
		public class Person {
			//@Value("${person.last-name}")
			private String lastName;
			//@Value("#{11*2}")
			private Integer age;
			private Boolean boss;
			private Date birth;
			private Map<String,Object> maps;
			private List<Object> lists;
			private Dog dog;
		}
		配置文件：
		person:
			lastName: hello
			age: 18
			boss: false
			birth: 2017/12/12
			maps: {k1: v1,k2: 12}
			lists:
			  - lisi
			  - zhaoliu
			dog:
			  name: 小狗
			  age: 12
		方式二：@Value
		区别：
			|            	| @ConfigurationProperties    | @Value 	      |
 			| 功能         	| 批量注入配置文件中的属性           一个个指定
			| 松散绑定（松散语法）| 支持                        不支持
			| SpEL       	| 不支持                          支持
			| JSR303数据校验| 支持                            不支持
			| 复杂类型封装   | 支持                           不支持
    加载配置文件：@PropertySource
		格式：
			@PropertySource(value = {"classpath:person.properties"})
			@Component
			@ConfigurationProperties(prefix = "person")
			public class Person {
				private Integer age;
				private Boolean boss;
			}
	读取配置文件：@ImportResource
	    格式：
		    java文件
			@ImportResource(locations = {"classpath:beans.xml"})
		    xml文件
    		<?xml version="1.0" encoding="UTF-8"?>
    		<beans xmlns="http://www.springframework.org/schema/beans"
    			   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    			   xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">
    			<bean id="helloService" class="com.atguigu.springboot.service.HelloService"></bean>
    		</beans>
    添加配置文件：
		推荐使用全注解的方式
		1、配置类@Configuration------>Spring配置文件
		2、使用@Bean给容器中添加组件
		```java
		@Configuration
		public class MyAppConfig {
			//将方法的返回值添加到容器中；容器中这个组件默认的id就是方法名
			@Bean
			public HelloService helloService(){
				System.out.println("配置类@Bean给容器中添加组件了...");
				return new HelloService();
			}
		}
    配置文件占位符:
    	如：*.properties 配置文件中
    		person.last-name=张三${random.uuid}
    		person.dog.name=${person.hello:hello}_dog
    配置文件Profile:
			激活指定profile的方式：
			1、配置文件中指定  spring.profiles.active=dev	
			2、命令行方式 java -jar **-0.0.1-SNAPSHOT.jar --spring.profiles.active=dev；
			3、虚拟机参数 -Dspring.profiles.active=dev
			配置文件加载位置：
				springboot启动会扫描以下位置的application.properties或者application.yml文件作为Spring boot的默认配置文件
				–file:./config/
				–file:./
				–classpath:/config/
				–classpath:/    #优先级由高到底，高优先级的配置会覆盖低优先级的配置；SpringBoot会从这四个位置全部加载主配置文件；互补配置；				
				java -jar **-0.0.1-SNAPSHOT.jar --spring.config.location=G:/application.properties #用户指定加载位置：
			外部配置加载顺序：
				SpringBoot也可以从以下位置加载配置； 优先级从高到低；高优先级的配置覆盖低优先级的配置，所有的配置会形成互补配置
				1.命令行参数
					java -jar **-02-0.0.1-SNAPSHOT.jar --server.port=8087  --server.context-path=/abc #多个配置用空格分开；--配置项=值
				2.来自java:comp/env的JNDI属性
				3.Java系统属性（System.getProperties()）
				4.操作系统环境变量
				5.RandomValuePropertySource配置的random.*属性值
				6.由jar包外向jar包内进行寻找，优先加载带profile
					jar包外部的application-{profile}.properties或application.yml(带spring.profile)配置文件
					jar包内部的application-{profile}.properties或application.yml(带spring.profile)配置文件
				10.@Configuration注解类上的@PropertySource
				11.通过SpringApplication.setDefaultProperties指定的默认属性
			自动配置原理：
				xxxxAutoConfigurartion：自动配置类；
				xxxxProperties:封装配置文件中相关属性；
			检测自动配置类是否生效：debug=true
二、日志框架：
	默认：springBoot底层也是使用slf4j+logback的方式进行日志记录；
           | 日志门面  （日志的抽象层）               | 日志实现
        	| ---------------------------------------- | ---------------------------------------- |
        	| JCL（Jakarta  Commons Logging）          | Log4j  JUL（java.util.logging）  Log4j2  Logback
        	| SLF4j（Simple  Logging Facade for Java） jboss-logging|
        	系统统一日志（slf4j）输出：
        		1、将系统中其他日志框架先排除出去
        		2、用中间包来替换原有的日志框架
        		3、我们导入slf4j其他的实现
        	日志级别：
        		由低到高   trace<debug<info<warn<error
        	springBoot修改默认日志配置：
        		1、指定级别：logging.level.XX包名=trace
        		2、logging.path=  #若不指定路径在当前项目下生成springboot.log日志
        		   logging.path=/spring/log #在当前磁盘的根路径下创建spring文件夹和里面的log文件夹；使用 spring.log 作为默认文件
        		3、logging.file=G:/springboot.log
        		输出格式：
        		4、logging.pattern.console=%d{yyyy-MM-dd} [%thread] %-5level %logger{50} - %msg%n #控制台
        		5、logging.pattern.file=%d{yyyy-MM-dd} [%thread] %-5level %logger{50} - %msg%n #指定文件中
        	指定具体的日志实现配置：类路径下（classpath:）放上每个日志框架自己的配置文件即可
        		如：logback.xml：直接就被日志框架识别了；
        			logback-spring.xml：日志框架就不直接加载日志的配置项，由SpringBoot解析日志配置，可以使用SpringBoot的高级Profile功能
        			xml文件：
        			<appender name="stdout" class="ch.qos.logback.core.ConsoleAppender">
        				<!--
        				日志输出格式：
        					%d表示日期时间，
        					%thread表示线程名，
        					%-5level：级别从左显示5个字符宽度
        					%logger{50} 表示logger名字最长50个字符，否则按照句点分割。
        					%msg：日志消息，
        					%n是换行符
        				-->
        				<layout class="ch.qos.logback.classic.PatternLayout">
        					<springProfile name="dev">
        						<pattern>%d{yyyy-MM-dd HH:mm:ss.SSS} ----> [%thread] ---> %-5level %logger{50} - %msg%n</pattern>
        					</springProfile>
        					<springProfile name="!dev">
        						<pattern>%d{yyyy-MM-dd HH:mm:ss.SSS} $$$$$$ [%thread] $$$$$$ %-5level %logger{50} - %msg%n</pattern>
        					</springProfile>
        				</layout>
        			</appender>
三、Web模块：
   静态资源映射：
	1、（以Jar包的方式引入静态资源）/webjars/**，都去 classpath:/META-INF/resources/webjars/找资源；如：localhost:8080/webjars/jquery/3.3.1/jquery.js
		引入如：
			<dependency>
				<groupId>org.webjars</groupId>
				<artifactId>jquery</artifactId>
				<version>3.3.1</version>
			</dependency>
	2、	/**，访问任何资源
		静态资源的文件夹：
		"classpath:/META-INF/resources/",
		"classpath:/resources/",
		"classpath:/static/",
		"classpath:/public/"
		"/"：当前项目的根路径
	3、	欢迎页：静态资源文件夹下的所有index.html页面；被"/**"映射；
	4、 所有的 **/favicon.ico 都是在静态资源文件下找
    模板引擎：JSP、Velocity、Freemarker、Thymeleaf，SpringBoot推荐的Thymeleaf；
	Thymeleaf使用：
	1、引入：POM.xml
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-thymeleaf</artifactId>
			<version>2.1.6</version>
		</dependency>
	<properties>
		<thymeleaf.version>3.0.9.RELEASE</thymeleaf.version>
		<!-- 布局功能的支持程序  thymeleaf3主程序  layout2以上版本 -->
		<!-- thymeleaf2   layout1-->
		<thymeleaf-layout-dialect.version>2.2.2</thymeleaf-layout-dialect.version>
   </properties>
	2、使用：把HTML页面放在classpath:/templates/，thymeleaf就能自动渲染；
    		页面引入：<html lang="en" xmlns:th="http://www.thymeleaf.org">
    		页面使用标签：
    			语法规则：
				包含：th:insert th:replace th:include
				遍历：th:each
				条件判断：th:if th:unless th:switch th:case
				申明变量：th:object th:with
				属性修改：th:attr th:attrprepend th:attrapend
				属性值修改: th:value th:src th:href
				标签体内容：th:text（转义） th:utext（不转义）
				申明片段：th:fragment
				移除：th:remove
    			表达式：
    				${...}：获取变量值，符合OGNL（Object Graphic Navigation Language(对象图导航语言)）标准；
    					1）、获取对象的属性、调用方法
    					2）、使用内置的基本对象：
    						#ctx : the context object.
    						#vars: the context variables.
    						#locale : the context locale.
    						#request : (only in Web Contexts) the HttpServletRequest object.
    						#response : (only in Web Contexts) the HttpServletResponse object.
    						#session : (only in Web Contexts) the HttpSession object.
    						#servletContext : (only in Web Contexts) the ServletContext object.
    					3）、内置的一些工具对象：
    					#execInfo : information about the template being processed.
    					#messages : methods for obtaining externalized messages inside variables expressions, in the same way as they would be obtained using #{}syntax.
    					#uris : methods for escaping parts of URLs/URIs
    					#conversions : methods for executing the configured conversion service (if any).
    					#dates : methods for java.util.Date objects: formatting, component extraction, etc.
    					#calendars : analogous to #dates , but for java.util.Calendar objects.
    					#numbers : methods for formatting numeric objects.
    					#strings : methods for String objects: contains, startsWith, prepending/appending, etc.
    					#objects : methods for objects in general.
    					#bools : methods for boolean evaluation.
    					#arrays : methods for arrays.
    					#lists : methods for lists.
    					#sets : methods for sets.
    					#maps : methods for maps.
    					#aggregates : methods for creating aggregates on arrays or collections.
    					#ids : methods for dealing with id attributes that might be repeated (for example, as a result of an iteration).
    						Selection Variable Expressions: *{...}：选择表达式：和${}在功能上是一样；补充：配合 th:object="${session.user}：
    					    <div th:object="${session.user}">
    						<p>Name: <span th:text="*{firstName}">Sebastian</span>.</p>
    						<p>Surname: <span th:text="*{lastName}">Pepper</span>.</p>
    						<p>Nationality: <span th:text="*{nationality}">Saturn</span>.</p>
    						</div>
    						Message Expressions: #{...}：获取国际化内容
    						Link URL Expressions: @{...}：定义URL；@{/order/process(execId=${execId},execType='FAST')}
    						Fragment Expressions: ~{...}：片段引用表达式;<div th:insert="~{commons :: main}">...</div>
    					Literals（字面量）
    						  Text literals: 'one text' , 'Another one!' ,…
    						  Number literals: 0 , 34 , 3.0 , 12.3 ,…
    						  Boolean literals: true , false
    						  Null literal: null
    						  Literal tokens: one , sometext , main ,…
    					Text operations:（文本操作）
    						String concatenation: +
    						Literal substitutions: |The name is ${name}|
    					Arithmetic operations:（数学运算）
    						Binary operators: + , - , * , / , %
    						Minus sign (unary operator): -
    					Boolean operations:（布尔运算）
    						Binary operators: and , or
    						Boolean negation (unary operator): ! , not
    					Comparisons and equality:（比较运算）
    						Comparators: > , < , >= , <= ( gt , lt , ge , le )
    						Equality operators: == , != ( eq , ne )
    					Conditional operators:条件运算（三元运算符）
    						If-then: (if) ? (then)
    						If-then-else: (if) ? (then) : (else)
    						Default: (value) ?: (defaultvalue)
    					Special tokens:
    						No-Operation: _
        禁用Thymeleaf缓存：spring.thymeleaf.cache=false
        Thymeleaf模板抽取：
					1、抽取公共片段
					<div th:fragment="copy">
						&copy; 2011 The Good Thymes Virtual Grocery
					</div>
					2、引入公共片段
					<div th:insert="~{footer :: copy}"></div> // ~{templatename::selector}：模板名::选择器;~{templatename::fragmentname}:模板名::片段名	
					3、默认效果：
					如果使用th:insert等属性进行引入，可以不用写~{}：行内写法可以加上：[[~{}]];[(~{})]；
					三种引入公共片段的th属性：
					th:insert：将公共片段整个插入到声明引入的元素中
					th:replace：将声明引入的元素替换为公共片段
					th:include：将被引入的片段的内容包含进这个标签中
					如：
					<footer th:fragment="copy">
						&copy; 2011 The Good Thymes Virtual Grocery
					</footer>
					引入方式
					<div th:insert="footer :: copy"></div>
					<div th:replace="footer :: copy"></div>
					<div th:include="footer :: copy"></div>
					效果
					<div>
						<footer>
						&copy; 2011 The Good Thymes Virtual Grocery
						</footer>
					</div>
					<footer>
						&copy; 2011 The Good Thymes Virtual Grocery
					</footer>
					<div>
						&copy; 2011 The Good Thymes Virtual Grocery
					</div>
    SpringMVC自动配置：
    	SpringBoot对SpringMVC的默认配置，WebMvcAutoConfiguration
    	做的主要几件事：
    			1、自动配置了ViewResolver（视图解析器）
    			2、支持静态资源文件夹路径,webjars
    			3、支持静态首页访问
    			4、支持favicon.ico系统图标
    			5、自动注册了Converte转换器Formatter格式化器
       扩展SpringMVC：
					Bean.XML 参考：
						 <mvc:view-controller path="/hello" view-name="success"/>
							<mvc:interceptors>
								<mvc:interceptor>
									<mvc:mapping path="/hello"/>
									<bean></bean>
								</mvc:interceptor>
							</mvc:interceptors>
					编写一个配置类（@Configuration），是WebMvcConfigurerAdapter类型；不能标注@EnableWebMvc（会全面接管），既保留了所有的自动配置，也能用自定义扩展的配置；
					如：@Configuration
						//@EnableWebMvc
						public class MyMvcConfig extends WebMvcConfigurerAdapter {
							@Override
							public void addViewControllers(ViewControllerRegistry registry) {
							   // super.addViewControllers(registry);
								registry.addViewController("/atguigu").setViewName("success");
							}
						}
	   全面接管SpringMVC：需要在自定义的配置类中添加@EnableWebMvc即可；
					原理：底层有@ConditionalOnMissingBean(WebMvcConfigurationSupport.class)，WebMvcConfigurationSupport只是保留SpringMVC最基本的功能；
	国际化i18n：
       使用步骤：	1）、编写国际化配置文件messages_zh_CN.properties、messages_en_US.properties
					2）、使用ResourceBundleMessageSource管理国际化资源文件
					3）、在页面使用fmt:message取出国际化内容
		结论：根据浏览器语言设置的信息切换了国际化
		原理：国际化Locale（区域信息对象）；LocaleResolver（获取区域信息对象解析器）；
				@Bean
				@ConditionalOnMissingBean
				@ConditionalOnProperty(prefix = "spring.mvc", name = "locale")
				public LocaleResolver localeResolver() {
					if (this.mvcProperties
							.getLocaleResolver() == WebMvcProperties.LocaleResolver.FIXED) {
						return new FixedLocaleResolver(this.mvcProperties.getLocale());
					}
					//默认的就是根据请求头带来的区域信息获取Locale进行国际化
					AcceptHeaderLocaleResolver localeResolver = new AcceptHeaderLocaleResolver();
					localeResolver.setDefaultLocale(this.mvcProperties.getLocale());
					return localeResolver;
				}
		点击链接切换国际化: 自定义个类实现LocaleResolver重写resolveLocale方法（对请求参数进行处理）返回区域对象，并注入容器里
				参考：
				public class MyLocaleResolver implements LocaleResolver {
					@Override
					public Locale resolveLocale(HttpServletRequest request) {
						String l = request.getParameter("l");
						Locale locale = Locale.getDefault();
						if(!StringUtils.isEmpty(l)){
							String[] split = l.split("_");
							locale = new Locale(split[0],split[1]);
						}
						return locale;
					}
					@Override
					public void setLocale(HttpServletRequest request, HttpServletResponse response, Locale locale) {
					}
				}
				 @Bean
					public LocaleResolver localeResolver(){
						return new MyLocaleResolver();
					}
				}
	Rest风格:
	    URI：/资源名称/资源标识（主表Id），以HTTP请求方式（GET、POST、PUT、DELETE）区分对资源CRUD操作；
		注意要点：如果添加/修改页面（二合一版），页面创建一个input项，name="_method";值就是我们指定的请求方式，原理：SpringMVC中配置HiddenHttpMethodFilter;（SpringBoot自动配置）
	错误处理：
		效果：1、浏览器：返回一个默认的错误页面；2、其他客户端，默认响应一个json数据
		原理：ErrorMvcAutoConfiguration；错误处理的自动配置类
			一但系统出现4xx或者5xx之类的错误；
			1、ErrorPageCustomizer就会生效（定制错误的响应规则）；就会来到/error请求；
			2、就会来到BasicErrorController处理（针对浏览器与其他客户端分别处理）；
			3、浏览器：调用DefaultErrorViewResolver类，交给它处理（有模板引擎，按模板引擎处理；没有默认处理error/状态码.html）
			4、其他客户端：调用getErrorAttributes方法，返回封装的Json数据；
		定制处理处理：
			基本规则：1、有模板引擎：模板引擎文件夹里面的error文件夹下找状态码.HTML（支持精准匹配与模糊匹配如：5xx.html）
						包含信息：
							timestamp：时间戳
			​				status：状态码
			​				error：错误提示
			​				exception：异常对象
			​				message：异常消息
			​				errors：JSR303数据校验的错误
					  2、没有模板引擎：静态资源文件夹
					  3、默认：来到SpringBoot默认的错误提示页面
		定制错误的JSON返回数据（思路）：
			自定义异常处理&返回定制json数据
			转发到/error进行自适应响应效果处理
			将定制数据携带出去
	配置嵌入式Servlet容器：
	   结论：SpringBoot默认使用Tomcat作为嵌入式的Servlet容器；
	   定制：
		1、ServerProperties方式，在配置文件中配置
		   通用的Servlet容器设置，server.xxx，如：server.port=8081 server.context-path=/crud 
		   Tomcat的设置，server.tomcat.xxx
		   如：server.tomcat.uri-encoding=UTF-8
		2、EmbeddedServletContainerCustomizer方式，在java代码中配置
		如：
		@Bean  //注入到容器中
		public EmbeddedServletContainerCustomizer embeddedServletContainerCustomizer(){
			return new EmbeddedServletContainerCustomizer() {
				//定制嵌入式的Servlet容器相关的规则
				@Override
				public void customize(ConfigurableEmbeddedServletContainer container) {
					container.setPort(8083);
				}
			};
		}
    	注册Servlet三大组件：Servlet、Filter、Listener 替代在web.xml中的配置
    	自动的注册前端控制器：DispatcherServletAutoConfiguration
    	修改配置：server.servletPath修改默认拦截的请求路径
    	修改为其他的servlet容器：
		支持Tomcat Undertow Jetty
		如：
			<!-- 引入web模块 -->
			<dependency>
			   <groupId>org.springframework.boot</groupId>
			   <artifactId>spring-boot-starter-web</artifactId>
			   <exclusions>
				  <exclusion>
					 <artifactId>spring-boot-starter-tomcat</artifactId>
					 <groupId>org.springframework.boot</groupId>
				  </exclusion>
			   </exclusions>
			</dependency>
			<!--引入其他的Servlet容器-->
			<dependency>
			   <artifactId>spring-boot-starter-undertow</artifactId>
			   <groupId>org.springframework.boot</groupId>
			</dependency>
			各自区别：
				Tomcat 是Apache下的一款重量级的基于HTTP协议的服务器
				Undertow 基于NIO（非阻塞式输入输出，相对于BIO（Blocking I/O，阻塞IO））实现的高并发轻量级的服务器，支持JSP
				Jetty 基于NIO（非阻塞式输入输出，相对于BIO（Blocking I/O，阻塞IO））实现的高并发轻量级的服务器，支持长链接
				Netty是一款基于NIO（Nonblocking I/O，非阻塞IO）开发的网络通信框架，客户端服务器框架
			嵌入式Servlet容器自动配置原理：EmbeddedServletContainerAutoConfiguration
				步骤：
				1）、SpringBoot根据导入的依赖情况，给容器中添加相应的EmbeddedServletContainerFactory
				2）、容器中某个组件要创建对象就会惊动后置处理器；EmbeddedServletContainerCustomizerBeanPostProcessor；只要是嵌入式的Servlet容器工厂，后置处理器就工作；
				3）、后置处理器，从容器中获取所有的EmbeddedServletContainerCustomizer，调用定制器的定制方法
				启动原理（步骤）：
				springBoot应用启动运行run方法->refreshContext(context);SpringBoot创建并刷新IOC容器(如果是web应用创建AnnotationConfigEmbeddedWebApplicationContext，否则：AnnotationConfigApplicationContext)
				->refresh(context)刷新IOC容器->onRefresh()->webIoc容器会创建嵌入式的Servlet容器；createEmbeddedServletContainer()
				->获取嵌入式的Servlet容器工厂EmbeddedServletContainerFactory->后置处理器EmbeddedServletContainerCustomizerBeanPostProcessor工作->
				->定制器来先定制Servlet容器的相关配置->嵌入式的Servlet容器创建对象并启动Servlet容器
				结论：IOC容器启动创建嵌入式的Servlet容器并启动
			外置的Servlet容器：
				嵌入式Servlet容器将应用打成可执行的jar，优点：简单、便携；缺点：默认不支持JSP、优化定制比较复杂；
				外置的Servlet容器一般指外面安装Tomcat---应用war包的方式打包；
				使用步骤：
				1）、必须创建一个war项目；（利用idea创建好目录结构）
				2）、将嵌入式的Tomcat指定为provided；
				<dependency>
				   <groupId>org.springframework.boot</groupId>
				   <artifactId>spring-boot-starter-tomcat</artifactId>
				   <scope>provided</scope>
				</dependency>
				3）、必须编写一个SpringBootServletInitializer的子类，并调用configure方法
				public class ServletInitializer extends SpringBootServletInitializer {
				   @Override
				   protected SpringApplicationBuilder configure(SpringApplicationBuilder application) {
					   //传入SpringBoot应用的主程序
					  return application.sources(SpringBoot04WebJspApplication.class);
				   }
				}
				4）、启动服务器就可以使用；
				原理：
				jar包：执行SpringBoot主类的main方法，启动IOC容器，创建嵌入式的Servlet容器；
				war包：启动服务器，服务器启动SpringBoot应用[SpringBootServletInitializer]，启动IOC容器；
四、数据访问：
    连接JDBC:
	1、导入依赖：
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-jdbc</artifactId>
		</dependency>
		<dependency>
			<groupId>mysql</groupId>
			<artifactId>mysql-connector-java</artifactId>
			<scope>runtime</scope>
		</dependency>
	2、添加配置参数：
		spring:
		  datasource:
			username: root
			password: 123456
			url: jdbc:mysql://192.168.15.22:3306/jdbc
			driver-class-name: com.mysql.jdbc.Driver
			schema:
			- classpath:department.sql #指定位置
	3、申明使用
			相关结论：
				默认是用org.apache.tomcat.jdbc.pool.DataSource作为数据源，数据源的相关配置都在DataSourceProperties里面
				DataSourceInitializer：ApplicationListener 可以运行建表与运行数据插入（runSchemaScripts();运行建表语句；runDataScripts();运行插入数据的sql语句；）
				默认只需要将文件重命名为：schema-*.sql、data-*.sql 默认规则：schema.sql，schema-all.sql；
				可以使用
				schema:
					- classpath:department.sql #指定位置
				自动配置了JdbcTemplate操作数据库；
			整合：Druid数据源，参考：https://blog.csdn.net/weixin_41404773/article/details/82592719
				1、导入依赖：
					<dependency>
						<groupId>org.springframework.boot</groupId>
						<artifactId>spring-boot-starter-jdbc</artifactId>
					</dependency>
					<!--引入druid-->
					<!-- https://mvnrepository.com/artifact/com.alibaba/druid -->
					<dependency>
						<groupId>com.alibaba</groupId>
						<artifactId>druid</artifactId>
						<version>1.1.8</version>
					</dependency>
				2、添加配置参数：在aplication.yml或aplication.properties
					spring:
					  datasource:
						username: root
						password: 123456
						url: jdbc:mysql://localhost:3306/testwkn
						driver-class-name: com.mysql.jdbc.Driver
						type: com.alibaba.druid.pool.DruidDataSource
						initialSize: 5
						minIdle: 5
						maxActive: 20
						maxWait: 60000
						timeBetweenEvictionRunsMillis: 60000
						minEvictableIdleTimeMillis: 300000
						validationQuery: SELECT 1 FROM DUAL
						testWhileIdle: true
						testOnBorrow: false
						testOnReturn: false
						poolPreparedStatements: true
					#   配置监控统计拦截的filters，去掉后监控界面sql无法统计，'wall'用于防火墙
						filters: stat,wall,log4j
						maxPoolPreparedStatementPerConnectionSize: 20
						useGlobalDataSourceStat: true
						connectionProperties: druid.stat.mergeSql=true;druid.stat.slowSqlMillis=500
					#   schema:
					#     - classpath:department.sql
				3、	读取配置
					@Configuration
					public class DruidConfig {
						@ConfigurationProperties(prefix = "spring.datasource")
						@Bean
						public DataSource druid(){
						   return  new DruidDataSource();
						}
						//配置Druid的监控
						//1、配置一个管理后台的Servlet
						@Bean
						public ServletRegistrationBean statViewServlet(){
							ServletRegistrationBean bean = new ServletRegistrationBean(new StatViewServlet(), "/druid/*");
							Map<String,String> initParams = new HashMap<>();
							initParams.put("loginUsername","admin");
							initParams.put("loginPassword","123456");
							initParams.put("allow","");//默认就是允许所有访问
							initParams.put("deny","192.168.15.21");
							bean.setInitParameters(initParams);
							return bean;
						}
						//2、配置一个web监控的filter
						@Bean
						public FilterRegistrationBean webStatFilter(){
							FilterRegistrationBean bean = new FilterRegistrationBean();
							bean.setFilter(new WebStatFilter());
							Map<String,String> initParams = new HashMap<>();
							initParams.put("exclusions","*.js,*.css,/druid/*");
							bean.setInitParameters(initParams);
							bean.setUrlPatterns(Arrays.asList("/*"));
							return  bean;
						}
					}
	整合Mybatis:
    	1、导入依赖：
    		<dependency>
    			<groupId>org.mybatis.spring.boot</groupId>
    			<artifactId>mybatis-spring-boot-starter</artifactId>
    			<version>1.3.1</version>
    		</dependency>
    	2、申明使用：
    		1、注解版-写好提供的接口，程序的入口添加@MapperScan
    		2、配置文件版
			mybatis:
			  config-location: classpath:mybatis/mybatis-config.xml #指定全局配置文件的位置
			  mapper-locations: classpath:mybatis/mapper/*.xml  #指定sql映射文件的位置
	整合Jpa（Java Persistence API，通过注解或者XML描述[对象-关系表]之间的映射关系，并将实体对象持久化到数据库中）:
		Jpa特点：ORM映射元数据：JPA支持XML和注解两种元数据的形式，元数据描述对象和表之间的映射关系，框架据此将实体对象持久化到数据库表中；如：@Entity、@Table、@Column、@Transient等注解
				 JPA 提供API：用来操作实体对象，执行CRUD操作，框架在后台替我们完成所有的事情，开发者从繁琐的JDBC和SQL代码中解脱出来；如：entityManager.merge(T t)；
				 JPQL查询语言：通过面向对象而非面向数据库的查询语言查询数据，避免程序的SQL语句紧密耦合；如：from Student s where s.name = ?
				 JPA仅仅是一种规范，也就是说JPA仅仅定义了一些接口，而接口是需要实现才能工作的。Hibernate就是实现了JPA接口的ORM框架。
		Spirng data jpa：是spring提供的一套简化JPA开发的框架，按照约定好的[方法命名规则]写dao层接口，就可以在不写接口实现的情况下，实现对数据库的访问和操作。同时提供了很多除了CRUD之外的功能，如分页、排序、复杂查询等等。Spring Data JPA 可以理解为 JPA 规范的再次封装抽象，底层还是使用了 Hibernate 的 JPA 技术实现。
					接口约定命名规则：如：findByNameAndPwd xxAndxx
					使用：
						1、导入依赖：
						<dependency>
							<groupId>org.springframework.boot/groupId>
							<artifactId>spring-boot-starter-data-jpa</artifactId>
						</dependency>
						2、添加配置：
						spring:
							jpa:
								hibernate:
							# 更新或者创建数据表结构
									ddl-auto: update
							#控制台显示SQL
								show-sql: true
								database: mysql
						3、使用：
						编写一个实体类（bean）和数据表进行映射，并且配置好映射关系；
						编写一个Dao接口来操作实体类对应的数据表（Repository）；
						如：
						//使用JPA注解配置映射关系
						@Entity //实体类（和数据表映射的类）
						@Table(name = "tbl_user") //@Table来指定和哪个数据表对应;如果省略默认表名就是user；
						public class User {
							@Id //主键
							@GeneratedValue(strategy = GenerationType.IDENTITY)//自增主键
							private Integer id;
							@Column(name = "last_name",length = 50) //这是和数据表对应的一个列
							private String lastName;
							@Column //省略默认列名就是属性名
							private String email;
						}
						public interface UserRepository extends JpaRepository<User,Integer> {
						}
	Springboot启动配置：
		构造过程（initialize(sources)）
			ApplicationContextInitializer，应用程序初始化器，做一些初始化的工作，	
			ApplicationListener，应用程序事件(ApplicationEvent)监听器，
			默认情况下，initialize方法从spring.factories文件中找出对应的key为ApplicationContextInitializer的类与ApplicationListener的类；
		SpringApplication执行
			SpringApplication构造完成之后调用run方法，启动SpringApplication，run方法执行的时候会做以下几件事
			构造Spring容器、刷新Spring容器、从Spring容器中找出ApplicationRunner和CommandLineRunner接口的实现类并排序后依次执行！
五、缓存：
    JSR107标准：
       Java Caching定义了5个核心接口，分别是CachingProvider, CacheManager, Cache, Entry和Expiry
		CachingProvider定义了创建、配置、获取、管理和控制多个CacheManager。
		CacheManager定义了创建、配置、获取、管理和控制多个唯一命名的Cache。
		Cache是一个类似Map的数据结构并临时存储以Key为索引的值。
		Entry是一个存储在Cache中的key-value对。Expiry 每一个存储在Cache中的条目有一个定义的有效期。
	使用：
    	<dependency>
    		<groupId>javax.cache</groupId>
    		<artifactId>cache-api</artifactId>
    	</dependency>
	Spring缓存抽象：
		简介：Spring从3.1开始定义了org.springframework.cache.Cache和org.springframework.cache.CacheManager接口来统一不同的缓存技术；并支持使用JCache（JSR-107）注解简化开发；
		特点：
		Cache接口为缓存的组件规范定义，包含缓存的各种操作集合；
		Cache接口下Spring提供了各种xxxCache的实现；如RedisCache，EhCacheCache , ConcurrentMapCache等；
		每次调用需要缓存功能的方法时，Spring会检查检查指定参数的指定的目标方法是否已经被调用过；如果有就直接从缓存中获取方法调用后的结果，如果没有就调用方法并缓存结果后返回给用户。下次调用直接从缓存中获取。
		使用Spring缓存抽象时我们需要关注以下两点；
		确定方法需要被缓存以及他们的缓存策略
		从缓存中读取之前缓存存储的数据
	    注解：
		@Cacheable - 主要针对方法配置，能够根据方法的请求参数对其结果进行缓存
		@CacheEvict - 清空缓存（删除）
		@CachePut - 保证方法被调用，又希望结果被缓存（更新）
		@EnableCaching	- 开启基于注解的缓存
		keyGenerator - 缓存数据时key生成策略
		serialize - 缓存数据时value序列化策略
	    主要参数：
		cacheNames - 缓存的名称 如：@Cacheable(cacheNames={"emp"})
		value - 缓存的名称 如：@Cacheable(value=”cache0”) 或者 @Cacheable(value={”cache1”,”cache2”})
		key - 缓存的key，可以为空，如果指定要按照 SpEL 表达式编写，如果不指定，则缺省按照方法的所有参数进行组合，如：@Cacheable(value=”cache0”,key=”#userName”)
		condition - 缓存的条件，可以为空，使用SpEL编写，返回 true 或者 false，只有为 true 才进行缓存/清除缓存，在调用方法之前之后都能判断，如：@Cacheable(value=”cache0”,condition=”#userName.length()>2”)
		allEntries -是否清空所有缓存内容，缺省为 false，如果指定为 true，则方法调用后将立即清空所有缓存，如：@CachEvict(value=”cache0”,allEntries=true)
		beforeInvocation - 是否在方法执行前就清空，缺省为 false，如果指定为 true，则在方法还没有执行的时候就清空缓存，缺省情况下，如果方法执行抛出异常，则不会清空缓存，如：@CachEvict(value=”cache01”，beforeInvocation=true)
		unless - 用于否决缓存的，条件为true不会缓存，fasle才缓存（与condition恰恰相反），如：@Cacheable(value=”cache01”,unless=”#result == null”)
	Cache SpEL available metadata：
		#root.methodName  #当前被调用的方法名
		#root.method.name #当前被调用的方法
		#root.target	  #当前被调用的目标对象
		#root.targetClass #当前被调用的目标对象类
		#root.args[0]     #当前被调用的方法的参数列表
		#root.caches[0].name #当前方法调用使用的缓存列表（如@Cacheable(value={"cache1", "cache2"})），则有两个cache
		#iban、 #a0、#p0 #方法参数的名字.可以直接#参数名，也可以使用#p0或#a0的形式，0代表参数的索引；
		#result           #方法执行后的返回值
		使用：
		•1、引入spring-boot-starter-cache模块
		•2、开启缓存：@EnableCaching
		•3、使用缓存注解
		Spring-data-redis：参考：https://blog.csdn.net/qq_26545305/article/details/80559902
		使用:
		1、引入依赖（2.0以后的版本）：
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-data-redis</artifactId>
		</dependency>
		2、application.yml配置文件配置redis的相关信息
		spring:
		  redis:
			host: 192.168.1.225
			port: 6379
			password:
		3、配置redis整入spring的缓存框架
		@Configuration
		@EnableCaching  //继承CachingConfigurerSupport并重写方法
		public class RedisConfig extends CachingConfigurerSupport {
			/**载入配置文件配置的连接工厂**/
			@Autowired
			RedisConnectionFactory redisConnectionFactory;
			/*不提示警告信息*/
			@SuppressWarnings("rawtypes")
			@Autowired
			RedisTemplate redisTemplate;
			@Bean
			RedisTemplate<String,Object> objectRedisTemplate(){
				RedisTemplate<String,Object> redisTemplate=new RedisTemplate<>();
				redisTemplate.setConnectionFactory(redisConnectionFactory);
				return redisTemplate;
			}
			@Bean
			@Override
			public CacheManager cacheManager(){
				RedisCacheManager redisCacheManager=new RedisCacheManager(redisTemplate);
				//设置缓存过期时间
		       // redisCacheManager.setDefaultExpiration(60);//秒
				return redisCacheManager;
			}
			/**
			 * 重写缓存key生成策略，可根据自身业务需要进行自己的配置生成条件
			 * @return
			 */
			@Bean
			@Override
			public KeyGenerator keyGenerator() {
				return new KeyGenerator() {
					@Override
					public Object generate(Object target, Method method, Object... params) {
						StringBuilder sb = new StringBuilder();
						sb.append(target.getClass().getName());
						sb.append(method.getName());
						for (Object obj : params) {
							sb.append(obj.toString());
						}
						return sb.toString();
					}
				};
			}
		}
		操作: spring data redis中用来操作redis的一是采用注解的方式，常用两个注解@Cacheable、@CacheEvit，二是采用RedisTemplate的方式；
			  对应于redis的5中结构，RedisTemplate中定义了对应5种数据结构的操作
			  redisTemplate.opsForValue();//操作字符串
			  redisTemplate.opsForHash();//操作hash
			  redisTemplate.opsForList();//操作list
			  redisTemplate.opsForSet();//操作set
			  redisTemplate.opsForZSet();//操作有序Zset
	Ace-Cache：参考：https://gitee.com/geek_qi/ace-cache
				基于spring boot上的注解缓存，自带轻量级缓存管理页面。@Cache比spring cache更轻量的缓存，支持单个缓存设置过期时间，可以根据前缀移除缓存。采用fastjson序列化与反序列化，以json串存于缓存之中。
		使用：
		1、添加依赖：
			<dependency>
				<groupId>com.github.wxiaoqi</groupId>
				<artifactId>ace-cache</artifactId>
				<version>0.0.2</version>
			</dependency>
		2、配置文件中添加配置：
			redis:
				pool:
					 maxActive: 300
					 maxIdle: 100
					 maxWait: 1000
				host: 127.0.0.1
				port: 6379
				password:
				timeout: 2000
				# 服务或应用名
				sysName: ace
				enable: true
				database: 0
		3、程序入口开启：缓存开启@EnableAceCache
		具体使用：在Service上进行@Cache注解或@CacheClear注解；
			配置缓存：@Cache
					注解参数	类型	说明
					key	字符串	缓存表达式，动态运算出key
					expires	整形	缓存时长，单位：分钟
					desc	描述	缓存说明
					parser	Class<? extends ICacheResultParser>	缓存返回结果自定义处理类
					generator	Class<? extends IKeyGenerator>	缓存键值自定义生成类
			清除缓存：@CacheClear
					注解参数	类型	说明
						pre	字符串	清除某些前缀key缓存
						key	字符串	清除某个key缓存
						keys	字符串数组	清除某些前缀key缓存
						generator	Class<? extends IKeyGenerator>	缓存键值自定义生成类
		轻量管理端：访问地址：http://IP:PORT/cache
五、消息：
   作用：异步通信、系统解耦、流量削峰填谷
   消息的使用：利用消息中间件来提升系统异步通信、扩展解耦能力；
   基本概念：
    	消息代理：（message broker）
    	目的地：（destination）
    	消息队列2种形式目的地
    		1. 队列（queue） ：点对点消息通信（point-to-point）
    		2. 主题（topic） ：发布（publish） /订阅（subscribe）消息通信
    	点对点：
    		消息发送者发送消息，消息代理将其放入一个队列中，消息接收者从队列中获取消息内容，消息读取后被移出队列，消息只有唯一的发送者和接受者，但并不是说只能有一个接收者
    	发布订阅式：
    		发送者（发布者）发送消息到主题，多个接收者（订阅者）监听（订阅）这个主题，那么就会在消息到达时同时收到消息
    	JMS（Java Message Service） JAVA消息服务：基于JVM消息代理的规范。 ActiveMQ、 HornetMQ是JMS实现
    	AMQP（Advanced Message Queuing Protocol）：高级消息队列协议，也是一个消息代理的规范，兼容JMS；RabbitMQ是AMQP的实现
		JMS与AMQP区别：
			AMQP网络线级协议，跨语言跨平台，支持5种消息模型；（1）direct exchange（2）、fanout exchange（3）、topic exchange（4）、headers exchange（5）、system exchange
		Springboot的支持：
			– spring-jms提供了对JMS的支持
			– spring-rabbit提供了对AMQP的支持
			– 需要ConnectionFactory的实现来连接消息代理
			– 提供JmsTemplate、 RabbitTemplate来发送消息
			– @JmsListener（JMS）、 @RabbitListener（AMQP）注解在方法上监听消息代理发布的消息
			– @EnableJms、 @EnableRabbit开启支持
			– JmsAutoConfiguration
			– RabbitAutoConfiguration
	RabbitMQ：
		简介：是一个由erlang开发的AMQP(Advanved Message Queue Protocol)的开源实现。
		核心概念：
			Message：消息，它由消息头和消息体组成。消息体是不透明的，而消息头则由一系列的可选属性组
					 成，这些属性包括routing-key（路由键）、 priority（相对于其他消息的优先权）、 delivery-mode（指出
					 该消息可能需要持久性存储）等。
			Publisher：消息的生产者，也是一个向交换器发布消息的客户端应用程序。
			Exchange：交换器，用来接收生产者发送的消息并将这些消息路由给服务器中的队列。
			Exchange有4种类型： direct(默认)，fanout, topic, 和headers，不同类型的Exchange转发消息的策略有所区别。
			Queue：消息队列，用来保存消息直到发送给消费者。它是消息的容器，也是消息的终点。一个消息可投入一个或多个队列。
				   消息一直在队列里面，等待消费者连接到这个队列将其取走。
			Binding：绑定，用于消息队列和交换器之间的关联。一个绑定就是基于路由键将交换器和消息队列连
					 接起来的路由规则，所以可以将交换器理解成一个由绑定构成的路由表。Exchange 和Queue的绑定可以是多对多的关系。
			Connection：网络连接，比如一个TCP连接。
			Channel：信道，多路复用连接中的一条独立的双向数据流通道。信道是建立在真实的TCP连接内的虚
					 拟连接， AMQP 命令都是通过信道发出去的，不管是发布消息、订阅队列还是接收消息，这
					 些动作都是通过信道完成。因为对于操作系统来说建立和销毁 TCP 都是非常昂贵的开销，所
					 以引入了信道的概念，以复用一条 TCP 连接。
			Consumer：消息的消费者，表示一个从消息队列中取得消息的客户端应用程序。
			Virtual Host：虚拟主机，表示一批交换器、消息队列和相关对象。虚拟主机是共享相同的身份认证和加密环境的独立服务器域。
						  每个 vhost 本质上就是一个 mini 版的 RabbitMQ 服务器，拥有
						  自己的队列、交换器、绑定和权限机制。vhost 是 AMQP 概念的基础，必须在连接时指定，RabbitMQ 默认的 vhost 是 / 。
			Broker：表示消息队列服务器实体
		运行机制：
			一句话概括：生产者将消息发送到Exchange（交换机），Exchange根据路由规则（routing-key）将消息Binding绑定到不同的消息队列，消费者
						从消息队列里取出消息
			Exchange的类型：Exchange分发消息时根据类型的不同分发策略有区别，目前共四种类型：
							direct、 fanout、 topic、 headers 。 headers 匹配 AMQP 消息的 header而不是路由键，
							headers 交换器和 direct 交换器完全一致，但性能差很多，目前几乎用不到了，
							所以直接看另外三种类型：
						1、Direct Exchange：完全匹配、单播模式（消息中的routing-key与消息队列中的binding key完全一致）
						2、Fanout（扇出） Exchange：广播模式（与消息中的routing-key无关的，交换器将消息转发到所有的消息队列里）
						3、Topic Exchange：模式匹配分发消息，将路由键与绑定键的字符用.隔开，支持识别通配符：符号“#”和符号 “*” 。
										   #匹配0个或多个单词，*匹配一个单词。
		与Springboot的整合：
			1、添加依赖：
			<dependency>
				<groupId>org.springframework.boot</groupId>
				<artifactId>spring-boot-starter-amqp</artifactId>
			</dependency>
			2、配置文件中添加配置：
			#RabbitMQ相关的配置信息
			spring.rabbitmq.host=127.0.0.1
			spring.rabbitmq.port=5672
			spring.rabbitmq.username=guest
			spring.rabbitmq.password=guest
			3、申明使用：
			AmqpTemplate - 发送消息
			@RabbitListener(queues="") - 监听消息
七、全文检索ElasticSearch
   简介：ElasticSearch是一个分布式搜索服务，提供Restful API，底层基于Apache Lucene，采用多shard（分片）的方式保证数据安全，并且提供自动resharding的功能，github等大型的站点也是采用了ElasticSearch作为其搜索服务。
   特点：1、分布式实时文件存储，并将每一个字段都编入索引
    	  2、实时分析的分布式搜索引擎
    	  3、可以扩展到上百台服务器，处理PB级别的结构化或非结构化数据（1PB=1024TB）
   与Mysql对比：
    	关系数据库     ⇒ 数据库         ⇒ 表          ⇒ 行              ⇒ 列(Columns)
    	Elasticsearch  ⇒ 索引(Index)    ⇒ 类型(type)  ⇒ 文档(Docments)  ⇒ 属性/字段(Fields)
    注意与MongoDB的区别：数据库         ⇒ 集合        ⇒ 文档            ⇒ 属性
   交互：与Elasticsearch的交互，可以使用Java API，也可以直接使用HTTP的Restful API方式
   核心：提供了强大的索引功能；
   与Springboot的整合：
   1、添加依赖：
	<dependency>
		<groupId>org.springframework.boot</groupId>
		<artifactId>spring-boot-starter-data-elasticsearch</artifactId>
		<version>2.0.2.RELEASE</version>
	</dependency>
	2、配置文件中添加配置：
	#elasticsearch集群名称，默认的是elasticsearch
	spring.data.elasticsearch.cluster-name=
	#节点的地址 注意api模式下端口号是9300，千万不要写成9200
	spring.data.elasticsearch.cluster-nodes=192.168.11.24:9300
	#是否开启本地存储
	spring.data.elasticsearch.repositories.enable=true
	3、申明使用：（类似于JPA的模式）
	参考：https://blog.csdn.net/linzhiqiang0316/article/details/80343401
	ElasticsearchRepository、 ElasticsearchTemplate、 JestClient
八、任务：
   异步：与第三方系统交互的时候，往往采用异步任务。在Spring 3.x之后，就已经内置了@Async来完美解决这个问题。使用@EnableAysnc、 @Aysnc即可；
   定时：Spring为我们提供了异步执行任务调度的方式，提供TaskExecutor、TaskScheduler接口。@EnableScheduling（开启）、@Scheduled（定时）
   如：@Scheduled(fixedRate = 1000)//fixedRate函数每隔1S执行一次，也可以使用@Scheduled(cron="...")
	  public void method1(){}
	  @EnableScheduling
	  public class DemoApplication {}
   cron表达式：
	秒（0-59） 分（0-59） 小时（0-23） 日期或天（1-31） 月份（1-12） 星期（0-7或SUN-SAT 0,7是SUN）
	特殊字符的含义：,（枚举）-（区间）*（任意）/（步长）？（日/星期冲突匹配）L（最后）W（工作日）C（和calendar联系后计算过的值）#（星期，4#2，第2个星期四）
	举例："0 0 12 * * ?" 每天中午12点触发
九、邮件：
   参考：https://www.cnblogs.com/zhangyinhua/p/9277684.html，自动装配类JavaMailSender.send();//发送邮件 
十、安全：
   简介： Security是针对Spring项目的安全框架，也是Spring Boot底层安全模块默认的技术选型。
					   它可以实现强大的web安全控制。对于安全控制，仅需引入spring-boot-starter-security模块，进行少量的配置，即可实现强大的安全管理。
   使用：参考：https://www.cnblogs.com/ealenxie/p/9293768.html
        重要的类：
    	   WebSecurityConfigurerAdapter：自定义Security策略
    	   AuthenticationManagerBuilder：自定义认证策略
    	   @EnableWebSecurity：开启WebSecurity模式
    	核心概念：
    	   “认证”（Authentication）和“授权”（Authorization或者访问控制）两大目标
    	web/http与安全：
    		1. 登陆/注销，– HttpSecurity配置登陆、注销功能
    		2. Thymeleaf提供的SpringSecurity标签支持，需要引入thymeleaf-extras-springsecurity4
    		– sec:authentication=“” 获得当前用户的用户名
    		– sec:authorize=“hasRole(‘ADMIN’)” 当前用户必须拥有ADMIN权限时才会显示标签内容
    		3. remember me
    		– 表单添加remember-me的checkbox
    		– 配置启用remember-me功能
    		4. CSRF（Cross-site request forgery）跨站请求伪造
    		– HttpSecurity启用csrf功能，会为表单添加_csrf的值，提交携带来预防CSRF；参考：https://www.cnblogs.com/qmfsun/p/5779469.html
    	与shiro的区别：
		Shiro是Apache 的Java的一个安全框架。
		Shiro的特点 易于理解的 Java Security API；
					简单的身份认证（登录），支持多种数据源；
					对角色的简单的签权（访问控制），支持细粒度的签权；
					支持一级缓存，以提升应用程序的性能；（一级缓存：作用域是SqlSession范围的,当在同一个sqlSession中执行两次相同的sql语句时,第一次执行完毕会将数据库中查询的数据写到缓存(内存),第二次查询时会从缓存中获取数据,不再去底层数据库查询,从而提高查询效率。需要注意的是,如果SqlSession执行了DML操作（增删改），并且提交到数据库，MyBatis则会清空SqlSession中的一级缓存，这样做的目的是为了保证缓存中存储的是最新的信息，避免出现脏读现象。二级缓存的作用域是mapper的同一个namespace。不同的sqlSession两次执行相同的namespace下的sql语句，且向sql中传递的参数也相同，即最终执行相同的sql语句，则第一次执行完毕会将数据库中查询的数据写到缓存，第二次查询会从缓存中获取数据，不再去底层数据库查询，从而提高效率。）
					内置的基于POJO企业会话管理，适用于Web以及Web的环境；
					非常简单的加密 API；
					异构客户端会话访问；
					不跟任何的框架或者容器捆绑，可以独立运行；
					Authentication：身份认证/登录；
					Authorization：授权，即权限验证，验证某个已认证的用户是否拥有某个权限；即判断用户是否能做事情，常见的如：验证某个用户是否拥有某个角色。或者细粒度的验证某个用户对某个资源是否具有某个权限；
					Session Manager：会话管理，即用户登录后就是一次会话，在没有退出之前，它的所有信息都在会话中；会话可以是普通JavaSE环境的，也可以是如Web环境的；
					Cryptography：加密，保护数据的安全性，如密码加密存储到数据库，而不是明文存储；
					Web Support：Web支持，可以非常容易的集成到Web环境；
					Caching：缓存，比如用户登录后，其用户信息、拥有的角色/权限不必每次去查，这样可以提高效率；
					Concurrency：shiro支持多线程应用的并发验证，即如在一个线程中开启另一个线程，能把权限自动传播过去；
					Testing：提供测试支持；
					Run As：允许一个用户假装为另一个用户（如果他们允许）的身份进行访问；
					Remember Me：记住我，即一次登录后，下次再来的话不用登录了
					Shiro四大核心功能：Authentication,Authorization,Cryptography,Session Management
					Shiro三个核心组件：Subject, SecurityManager 和 Realms.
					Subject：主体，代表了当前“用户”，这个用户不一定是一个具体的人，与当前应用交互的任何东西都是Subject，如网络爬虫，机器人等；
								 即一个抽象概念；所有Subject都绑定到SecurityManager，与Subject的所有交互都会委托给SecurityManager；可以把Subject认为是一个门面；SecurityManager才是实际的执行者；
					SecurityManager：安全管理器；即所有与安全有关的操作都会与SecurityManager交互；且它管理着所有Subject；
									 可以看出它是Shiro的核心，它负责与后边介绍的其他组件进行交互，如果学习过SpringMVC，你可以把它看成DispatcherServlet前端控制器；
					Realms：域，Shiro从从Realm获取安全数据（如用户、角色、权限），就是说SecurityManager要验证用户身份，那么它需要从Realm获取相应的用户进行比较以确定用户身份是否合法；
							也需要从Realm得到用户相应的角色/权限进行验证用户是否能进行操作；可以把Realm看成DataSource，即安全数据源。
					Security：基于Spring的企业应用系统提供声明式的安全访问控制解决方案的安全框架。
							      在Spring应用上下文中配置的Bean，充分利用了Spring IoC，DI（IoC：Inversion of Control控制反转,DI:Dependency Injection依赖注入）和AOP（面向切面编程）功能，
								  为应用系统提供声明式的安全访问控制功能，减少了为企业系统安全控制编写大量重复代码的工作。
								  Web/Http 安全：通过建立 filter 和相关的 service bean 来实现框架的认证机制。
								  AuthenticationManager：处理来自于框架其他部分的认证请求。
								  AccessDecisionManager：为 Web 或方法的安全提供访问决策。
								  AuthenticationProvider：AuthenticationManager 是通过它来认证用户的。
								  UserDetailsService：跟 AuthenticationProvider 关系密切，用来获取用户信息的。
		授权含义：OAuth2.0（三方授权登录）授权协议
								OAuth2.0 内部回调先获取token，再用token（令牌，权限范围
								和有效期）授权登录，获取用户信息
			客户端（豆瓣）  ----------------------------------------------------->   授权层、服务提供商（QQ认证服务器）
							<----------------------------------------------------
							     向客户端开放用户储存的信息，提供信息
			OpenID ：身份认证，即如何通过 URI 来认证用户身份。如果使用OpenID，你的网站地址（URI）就是你的用户名，而你的密码安全的存储在一个 OpenID 服务网站上。
			         主要原理：
					 主要原理是
						1. 首先得拥有一个合法的OpenID帐号，也就是说需要在一个验证服务器申请了一个帐号。
						2. 你有了这个帐号之后，就可以在任何一个其他支持OpenID验证的网站，并且用你上面申请的OpenID进行登录
						3. 因为这个网站并不知道你的身份是否正确，所以它会请求你的验证服务器对你的身份进行验证。
						4. 验证服务器告诉网站说，你是合法用户
						5. 网站接受你的身份，让你进入。
			区别：OAuth关注的是authorization；而OpenID侧重的是authentication
十一、分布式：
    常见的分布式：zookeeper+dubbo组合，springCloud全栈技术以及spring Cloud Alibaba分布式解决方案
	架构演变：
		单一应用架构（all in one）：流量1~10，用于简化增删改查工作量的数据访问框架(ORM)是关键
		垂直应用架构：流量10~1000，将应用拆成互不相干的几个应用，以提升效率。此时，出现用于加速前端页面开发的Web框架(MVC)是关键
		分布式服务架构：流量1000~10000 ，当垂直应用越来越多，应用之间交互不可避免，将核心业务抽取出来，作为独立的服务，逐渐形成稳定的服务中心。此时，用于提高业务复用及整合的分布式服务框架(RPC)是关键；
		流动计算架构：流量10000+，当服务越来越多，容量的评估，此时需增加一个调度中心基于访问压力实时管理集群容量，提高集群利用率。此时，用于提高机器利用率的资源调度和治理中心(SOA)是关键；
	zookeeper：（服务的注册中心）ZooKeeper 是一个分布式的，开放源码的分布式应用程序协调服务。它是
			   一个为分布式应用提供一致性服务的软件，提供的功能包括：配置维护、域名服务、分布式同步、组服务等
			   压力较小，zk 将全量数据存储在内存，高性能，而且支持集群。
	dubbo：（服务的治理）Dubbo是Alibaba开源的分布式服务框架，特点分层架构解耦，从服务的模型分为服务的提供者与消费者。- DubboX当当网
	使用参考：https://blog.csdn.net/zhengzhaoyang122/article/details/81877595
	架构图：![dubbo架构图](images/20191127171500197_21647.png)
	SpringCloud：是一个分布式的整体解决方案。Spring Cloud为开发者提供了在分布式系统（配置管理，服务发现，熔断，路由，微代理，控制总线，
				 一次性token，全局琐，leader选举，分布式session，集群状态）中快速构建的工具，使用Spring Cloud的开发者可以快速的启动服务
				 或构建应用、同时能够快速和云平台资源进行对接。（详情参考SpringCloud技术栈）
十二、热部署：
    1、禁用模板引擎的cache，使用ctrl+F9重新编译页面
	2、官方提供的Spring Loaded
	    方式一：添加依赖
		<dependency>
			<groupId>org.springframework</groupId>
			<artifactId>springloaded</artifactId>
			<version>1.2.8.RELEASE</version>
		</dependency>
		方式二：maven仓库下载，下载地址：http://mvnrepository.com/artifact/org.springframework/springloaded
	    运行（VM arguments）时参数；-javaagent:C:/springloaded-1.2.5.RELEASE.jar –noverify
	3、devtools
	   添加依赖：
	   <dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-devtools</artifactId>
			<optional>true</optional>
		</dependency>
		配置设置：
		#热部署生效
		spring.devtools.restart.enabled: true
		#设置重启的目录
		#spring.devtools.restart.additional-paths: src/main/java
		#classpath目录下的WEB-INF文件夹内容修改不重启
		spring.devtools.restart.exclude: WEB-INF/**
		IDEA配置，修改了Java类后，IDEA默认是不自动编译的。自动编译：（1）File-Settings-Compiler-Build Project automatically																	（2）ctrl + shift + alt + /,选择Registry,勾上 Compiler autoMake allow when app running
	4、JRebel热部署插件
	    安装：
		点击File -> Settings -> Plugins,如下图：搜索JRebel安装，重启IDEA工具即可
十三、监控：
	使用：
	添加依赖
	<dependency>
		<groupId>org.springframework.boot</groupId>
		<artifactId>spring-boot-starter-actuator</artifactId>
	</dependency>
	监控端点分类：
	应用配置类：/autoconfig /configprops /beans /env /mappings /info
	度量指标类：/metrics /health /dump /trace /auditevents
	操作控制类：/shutdown（关闭应用，默认关闭的） 可以在application.properties中配置开启：endpoints.shutdown.enabled=true
	通过http方式访问监控端点
	定制端点信息：endpoints+端点名+属性名进行设置，如：
		修改端点id（endpoints.beans.id=mybeans）
		– 开启远程应用关闭功能（endpoints.shutdown.enabled=true）
		– 关闭端点（endpoints.beans.enabled=false）
		– 开启所需端点
		• endpoints.enabled=false
		• endpoints.beans.enabled=true
		– 定制端点访问根路径
		• management.context-path=/manage
		• management.port=20001
		– 关闭http端点
		• management.port=-1