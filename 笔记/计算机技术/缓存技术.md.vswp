vnote_backup_file_826537664 D:/工作/学习资料/study-notes/笔记/计算机技术/缓存技术.md
# 缓存技术
* NoSQL入门
    + 时代背景[架构演变]：
    1、单机MySQL:APP->DAL（数据访问层）->MySQL Instance （读写混合）；
    2、Memcached(缓存)+MySQL：（原因：数据量上升，复杂的数据结构[B+Tree]），引入了Memcached分布式缓存技术，为web服务提供缓存（弊端：hash的一致性引发缓存失效），APP->DAL（数据访问层）->cache；
    3、Mysql主从复制读写分离：（原因：Memcached(缓存)解决了数据库读的问题，而写的问题依然严重），出现了Mysql的master-slave模式；APP->DAL（数据访问层）->cache -> M（Write）/S（Read）/S（Read）；
    4、分表分库+水平拆分+MySQL集群：（原因：流量数据，Mysql主从复制读写分离写的问题日趋严重），出现了MySQL Cluster集群；
    5、Mysql扩展瓶颈：大文本字段效率低，NOSQL处理大数据运用而生！
    6、当今架构流程：
    客户请求  --------（企业级防火墙/负载均衡Nginx设备）-------->  APP服务器（多台） ------------（DAL）-------------> Mysql Cluster集群数据库 ------------>缓存服务器/文件（图片）服务器/实时通讯/流媒体/移动信息/电子邮件等服务器（中间件）等；
    + 思考题：高性能架构思路，对于高性能网站，请求量大，如何支撑?
    1、必要减少请求；对于开发人员，提高开发质量（合并css，处理背景图片，优化mysql查询等），对于运维人员善用缓存，如：nginx的expires，利用浏览器缓存等,减少查询；
    2、利用cdn技术来响应请求，CDN加速技术；CDN（Content Delivery Network），即内容分发网络。CDN是构建在网络之上的内容分发网络，依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。CDN的关键技术主要有内容存储和分发技术。
    3、对请求的处理：服务器集群+负载均衡来支撑，这一步思考如何更好的响应高并发请求，既然请求是不可避免的，我们要做的是把工作内容”平均”分给每台服务器，最理想的状态每台服务器的性能都被充分利用。
    + 含义：NoSQL(NoSQL = Not Only SQL )，意即“不仅仅是SQL”，泛指非关系型的数据库。
    + 特点：易扩展、大数据量高性能、多样灵活的数据模型（适合于查询、增删字段是一件非常麻烦的事情）。
    + 比较：

    |           RDBMS           |                                                              NoSQL                                                              |
    | ------------------------- | ------------------------------------------------------------------------------------------------------------------------------- |
    | 高度组织化结构化数据        | 代表着不仅仅是SQL                                                                                                                |
    | 结构化查询语言（SQL）       | 没有声明性查询语言                                                                                                                |
    | 数据和关系都存储在单独的表中 | 没有预定义的模式                                                                                                                 |
    | 数据操纵语言，数据定义语言   | 键值对存储，列存储，文档存储，图形数据库                                                                                            |
    | 严格的一致性               | 最终一致性，而非ACID属性（数据库事务四个基本要素，原子性[Atomicity]、一致性[Consistency]、隔离性/独立性[Isolation]、持久性[Durability]） |
    | 基础事务                   | 非结构化和不可预知的数据                                                                                                          |
    |                           | CAP定理（指的是在一个分布式系统中，Consistency（一致性）、 Availability（可用性）、Partition tolerance（分区容错性），三者不可兼得）     |
    |                           | 高性能，高可用性和可伸缩性                                                                                                         |

    + 基础产品：Redis、memcache、Mongdb等
    + 大数据时代的特点：3V + 3高；3V：海量Volume、多样Variety、实时Velocity；3高：高并发、高可扩、高性能；
    + 大数据下的经典案例：以阿里巴巴的商品信息存放为例；
    架构演变：Orcale -> Java Servlet -> EJB（将编写的软件中那些需要执行制定的任务的类，不放到客户端软件上了，而是给他打成包放到一个服务器上了） -> 去EJB重构（Ibatis）-> 海量数据：Memcached 集群，分布式存储，Mysql数据拆分 -> 安全、镜像（敏捷、开放[网站开放，允许第三方接入]、体验）；
    数据源数据类型存储问题（数据层）：关系数据库MySQL、搜索引擎、缓存Memcached、KV、文档数据库、外部数据接口（银行）、列数据库...
    商品信息存放：
		1、基础信息：存储关系型数据库（MySQL，去Oracle），如：商品价格、名称；
		2、描述性、评价详情信息（多文字类）：文档数据库MongDB中，多文字信息，关系型数据库IO读写性能变差；
		3、图片：分布式的文件存储系统，如：TFS（淘宝）、GFS（Google）、HDFS（Hadoop）；
		4、商品关键字：搜索引擎；
		5、商品的波段性的热点高频信息：缓存数据库；
		6、计算类：外部系统，外部第3方支付接口。
	+ 大数据时代数据DAL的解决方案：UDSL（统一数据服务层）
	  统一数据服务层的特征：
		1、映射：传统的ORM框架是不能实现跨多数据源与类型的映射，UDSL提供了解决方案；
		2、API：UDSL提供了统一的查询与更新API，类似JPA；
		3、热点缓存：二级缓存，实现流程：网站 ->UDSL ->缓存（设置规则） ->查询/更新（根据索引、Key）。
	+ NoSQL的数据模型：
	  对比关系型与非关系型数据库设计：RDBMS使用ER图，NoSQL常用的BSON（是一种类似json的一种二进制形式的存储格式，简称Binary JSON，支持内嵌的文档对象和数组对象）结构。
	+ 聚合模型：KV键值、bson、列族（方便数据压缩）、图形。
    + NoSQL分类：
	1、KV键值对：阿里、百度：memcache+redis，美团：redis+tair，新浪：BerkeleyDB+redis；
    2、文档型数据库(bson格式比较多)：MongoDB（基于分布式文件存储的数据库）、CouchDB；
	3、列存储数据库：分布式文件系统（Cassandra, HBase）；
	4、图关系数据库：它不是放图形的，放的是关系比如:朋友圈社交网络、广告推荐系统，如：Neo4J, InfoGrid。
	+ 分布式数据库中CAP原理CAP+BASE：
	ACID：数据库事务四个基本要素，原子性[Atomicity]、一致性[Consistency]、隔离性/独立性[Isolation]、持久性[Durability]；
	原子性：说的是事务里的所有操作要么全部做完，要么都不做，事务成功的条件是事务里的所有操作都成功，只要有一个操作失败，整个事务就失败，需要回滚；
	一致性：数据库要一直处于一致的状态，事务的运行不会改变数据库原本的一致性约束，也即在事务开始之前和事务结束以后，数据库的完整性没有被破坏；
	独立性：指并发的事务之间不会互相影响，如果一个事务要访问的数据正在被另外一个事务修改，只要另外一个事务未提交，它所访问的数据就不受未提交事务的影响；
	持久性：一旦事务提交后，它所做的修改将会永久的保存在数据库上，即使出现宕机也不会丢失。
	CAP：指的是在一个分布式系统中，Consistency（一致性）、 Availability（可用性）、Partition tolerance（分区容错性），三者不可兼得（三选二），说明：由于当前的网络硬件肯定会出现延迟丢包等问题，所以分区容忍性是我们必须需要实现的，所以只能在一致性和可用性之间进行权衡。

	|         产品          | 原则 |                          特点                          |
	| --------------------- | --- | ----------------------------------------------------- |
	| 传统关系型数据库RDBMS  | AC   | 单点集群，满足一致性，可用性的系统，通常在可扩展性上不太强大 |
	| 大多数网站架构         | AP   | 满足可用性，分区容忍性的系统，通常可能对一致性要求低一些     |
	| Redis、Mongodb、HBase | CP   | 满足一致性，分区容忍性的系统，通常性能不是特别高            |

    结论：强一致性和可用性之间取一个平衡。大多数web应用，其实并不需要强一致性（尤其是读的一致性）。因此牺牲C换取A，这是目前分布式数据库产品的方向。
    BASE：为了解决关系数据库强一致性引起的问题而引起的可用性降低而提出的解决方案，BASE其实是下面三个术语的缩写：基本可用（Basically Available），软状态（Soft state），最终一致（Eventually consistent）；它的思想是通过让系统放松对某一时刻数据一致性的要求（实时性）来换取系统整体伸缩性和性能上改观。因为在于大型系统往往由于地域分布和极高性能的要求，不可能采用分布式事务来完成这些指标，要想获得这些指标，我们必须采用另外一种方式来完成，这里BASE就是解决这个问题的办法。
   + 分布式与集群：
   分布式系统：由多台计算机和通信的软件组件通过计算机网络连接组成，具有高度的内聚性和透明性。
   分布式：不同的多台服务器上面部署不同的服务模块（工程），他们之间通过Rpc/Rmi（Remote Method Invocation,远程方法调用，仅支持Java语言）之间通信和调用，对外提供服务和组内协作。
   集群：不同的多台服务器上面部署相同的服务模块，通过分布式调度软件进行统一的调度，对外提供服务和访问。
* Redis
   + 含义：REmote DIctionary Server(远程字典服务器)，是完全开源免费的，用C语言编写的，遵守BSD开源协议，是一个高性能的(key/value)分布式内存数据库，基于内存运行，并支持持久化的NoSQL数据库，是当前最热门的NoSql数据库之一，也称为数据结构服务器。
   + 与其他的KV缓存产品对比优势：
	1、Redis支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用；
	2、Redis不仅仅支持简单的Key-Value类型的数据，同时还提供string，list，set，zset，hash等数据结构的存储；
	3、Redis支持数据的备份，即Master-Slave模式的数据备份。
   + 作用：
    1、内存存储和持久化RDB/AOF：Redis支持异步将内存中的数据写到硬盘上，同时不影响继续服务；
	2、发布、订阅消息系统；
	3、取最新N个数据的操作，如：可以将最新的10条评论的ID放在Redis的List集合里面；模拟类似于HttpSession这种需要设定过期时间的功能；定时器、计数器。
   + 官网：[redis][http://redis.io/]或[http://www.redis.cn/]
   + 安装使用：
   Windows: 安装路径下执行：redis-server.exe redis.conf；
   Linux：企业级开发；
   主要步骤：
   1、下载压缩包，下载获得redis-3.0.4.tar.gz后将它放入Linux目录/opt；
   2、解压进入，/opt目录下，解压命令:tar -zxvf redis-3.0.4.tar.gz，得到redis-3.0.4文件；
   3、安装，cd redis-3.0.4，在redis-3.0.4目录下执行make命令，注意：可能报错，可能原因：缺少gcc库（一款支持c语言的编译工具）的支持，下载yum install gcc-c++；再次安装，若报“jemalloc/jemalloc.h：没有那个文件或目录”错误，运行make distclean之后再make，测试环境：macke test（需要TCL环境支持，http://www.linuxfromscratch.org/blfs/view/cvs/general/tcl.html）；
   4、make完成后继续执行make install安装，默认安装目录：/usr/local/bin/目录下。
   + 目录结构或文件：
   redis-benchmark：性能测试工具；
   redis-check-aof：修复有问题的AOF文件；
   redis-check-dump：修复有问题的dump.rdb文件；
   redis-cli：客户端，操作入口；
   redis-sentinel：redis集群使用[哨兵]；
   redis-server：Redis服务器启动命令。
   + 启动/关闭：
   1、前提准备：回到解压目录redis-3.0.4/下，主要目录或文件：redis.conf、sentinel.conf、src；修改redis.conf文件将里面的daemonize no 改成 yes，让服务在后台启动；备份配置文件redis.conf，如：redis.conf.bak；
   2、启动：安装路径下执行：redis-server [解压路径下]/redis-3.0.4/redis.conf；客户端测试：redis-cli（测试是否连通：ping 出现PONG说明服务通的）或 redis-cli -h 127.0.0.1 -p 6379；
   3、关闭：单实例关闭：redis-cli shutdown；多实例关闭，指定端口关闭:redis-cli -p 6379 shutdown；
   + 基础知识:
   单进程模型：单进程模型来处理客户端的请求。对读写RW等事件的响应是通过对epoll函数的包装来做到的。Redis的实际处理速度完全依靠主进程的执行效率。epoll是Linux内核为处理大批量文件描述符而作了改进的epoll，是Linux下多路复用IO接口select/poll的增强版本，它能显著提高程序在大量并发连接中的系统CPU利用率。
   数据库：
   1、默认16个数据库，类似数组下标从零开始，初始默认使用零号库，切换库：select 数据库Id；
   2、dbsize：查看当前数据库的key的数量，查看所有key： Keys *；keys 支持ANT风格，如：keys k？；
   3、flushdb：清空当前库；
   4、Flushall；通杀全部库。
   数据类型：
   string：是redis最基本的类型，可以理解成与Memcached一模一样的类型，一个key对应一个value。string类型是二进制安全的。意思是redis的string可以包含任何数据。比如jpg图片或者序列化的对象。一个redis中字符串value最多可以是512M。
   hash：哈希无序，类似java里的Map；Redis hash 是一个键值对集合。hash是一个string类型的field和value的映射表，hash特别适合用于存储对象。
   list：列表，是简单的字符串列表，按照插入顺序排序元素可以重复。你可以添加一个元素导列表的头部（左边）或者尾部（右边）。它的底层实际是个链表。
   set：集合，Redis的Set是string类型的无序不可重复集合，它是通过HashSet实现实现的。
   zset：sorted set有序集合，Redis zset 和 set 一样也是string类型元素的集合,且不允许重复的成员。不同的zset是每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。zset的成员是唯一的,但分数(score)却可以重复。参考：http://redisdoc.com/
   基本操作：
   **Key：**
   查看所有key： keys *；判断某个key是否存在：exists key的名字，1表示存在，-1表示不存在；移除key：move key db，当前库就没有了，被移除了；给key设置过期时间：expire key 秒钟；查看还剩多少秒过期：ttl key ，-1表示永不过期，-2表示已过期；查看key的类型：type key；
   **String[单值单value]：**
   set/get/del/append/strlen：#设值/取值/删除/添加/长度；
   incr/decr/incrby/decrby：#只有数字才能进行加减；
   getrange/setrange：getrange：获取指定区间范围内的值，类似between......and的关系，从零到负一表示全部,如：getrange key 0 -1； setrange：设置指定区间范围内的值，格式是setrange key值 具体值，如：setrange key 1 xxx，1索引；
   setex(set with expire) 键 秒 值/setnx(set if not exist) 键 值；setex：设置带过期时间的key，动态设置。setex 键 秒 真实值，如：setex k1 15 v1；setnx：setnx:只有在key不存在时设置 key 的值，如：setnx k1 v1；
   **List[单值多value]**：
   lpush/rpush/lrange key：如：lrange list1 0 -1；lpop/rpop key：取元素[出栈]；lindex：通过索引获取列表中的元素，语法：lindex key index，如：lindex k1 5； llen key；
   lrem key 删N个value：从left往right删除2个值等于v1的元素，返回的值为实际删除的数量，如：LREM list1 2 v1；LREM list1 0 value1，表示删除全部给定的值，零个就是全部值；
   ltrim key 开始索引 结束索引，截取指定范围的值后再赋值给key，如：ltrim key1 0 3；
   rpoplpush 源列表 目的列表：移除列表的最后一个元素，并将该元素添加到另一个列表并返回，如：rpoplpush l1 l2；
   lset key index value：指定索引位置添加元素；
   linsert key  before/after 值1 值2：插入元素，如：linsert k1 after 3 5；
   总结：List是一个字符串链表，left、right都可以插入添加，如果键不存在，创建新的链表；如果键已存在，新增内容；如果值全移除，对应的键也就消失了。链表的操作无论是头和尾效率都极高，但假如是对中间元素进行操作，效率就很惨淡了。
   **Set[单值多value，底层是hashSet]：**
   sadd/smembers/sismember：如：sadd set1 v1 v2 v3；scard：获取集合里面的元素个数，如：scard set1；srem key value：删除集合中元素，如：srem set1 v1；srandmember key 某个整数：随机出几个指定个数的元数，如：srandmember set1 2；spop key ：随机出栈，如：spop set1；smove key1 key2 在key1里某个值：作用是将key1里的某个值赋给key2，如：smove set1 set2 v1；
   数学集合类：差集：sdiff，在第一个set里面而不在后面任何一个set里面的项；交集：sinter；并集：sunion；
   **Hash[KV模式不变，但V是一个键值对，类似Java中的Map<String,Object>]：**
   hset/hget/hmset/hmget/hgetall/hdel/hlen：如：hmset hash1 id 1 name lisi age 20；
   hexists key 在key里面的某个值的key：如：hexists hash1 id；hkeys/hvals key：如：hkeys hash1，结果：id name age；hincrby/hincrbyfloat：给key里面的某个key的值增加整数/浮点数；
   hsetnx：给key里面的某个key不存在才赋值，如：hsetnx hash1 k1 44；
   **Zset[sorted set有序集合]：**
   在set基础上，加一个score值。之前set是k1 v1 v2 v3，现在zset是k1 score1 v1 score2 v2；
   zadd/zrange：如：zadd z1 70 v1 80 v2 90 v3，zrange z1 0 -1 withscores；
   zrangebyscore key 开始score 结束score [withscores] [limit]：如：zrangebyscore z1 (60 90 withscores #(不包含，limit 开始下标步 多少步
   zrem key 某score下对应的value值，如：zrem z1 v1 #删除元素
   zcard：获取集合中元素个数，如：zcard z1；
   zcount：获取分数区间内元素个数，zcount key 开始分数区间 结束分数区间，如：zcount z1 60 80；
   zrank：获取下标位置，如：zrank z1 v1；
   zscore：按照key获得对应的分数，如：zscore z1 v1；
   zrevrank key values值，作用是逆序获得下标，如：zrerank z1 v1；
   zrevrange：与zrange相反；
   zrevrangebyscore  key 结束score 开始score：与zrangebyscore相反。
   + 配置文件解析[redis.conf]：
   **units[单位]：**
   ```conf
    #如：
	1k => 1000 bytes
	1kb => 1024 bytes
	1m => 1000000 bytes
	1mb => 1024*1024 bytes
	1g => 1000000000 bytes
	1gb => 1024*1024*1024 bytes
	#配置大小单位,开头定义了一些基本的度量单位，只支持bytes，不支持bit
	#对大小写不敏感
   ```
	**INCLUDES[包含]：**
	通过includes包含，redis.conf可以作为总闸，包含其他的配置信息。
	
	```conf
	#如：
	# include /path/to/local.conf
	# include /path/to/other.conf
	```
   **GENERAL[通用]:**

   ```conf
   daemonize：no, #是否开启守护进程模式，默认没有开启
   pidfile：/var/run/redis.pid, #进程ID所在文件
   port：6379, #监听端口，默认6379，如果设为0，禁用监听TCP socket
   tcp-backlog：511 #设置tcp的backlog，backlog其实是一个连接队列，backlog队列总和=未完成三次握手队列 + 已经完成三次握手队列。在高并发环境下你需要一个高backlog值来避免慢客户端连接问题。注意Linux内核会将这个值减小到/proc/sys/net/core/somaxconn的值，所以需要确认增大somaxconn和tcp_max_syn_backlog两个值来达到想要的效果。
   timeout：0, #超时断开连接，默认0，表示关闭
   #bind：绑定IP/域名，非必配项
   tcp-keepalive：60, #单位为秒，如果设置为0，则不会进行Keepalive检测，建议设置60，长链接保持心跳，超出设置的数值，会断开socket连接
   loglevel：verbose, #日志级别，默认有4种，默认是：verbose
		# debug (a lot of information, useful for development/testing)
		# verbose (many rarely useful info, but not a mess like the debug level)
		# notice (moderately verbose, what you want in production probably)
		# warning (only very important / critical messages are logged)
   logfile：stdout, #日志文件名，默认：stdout# output for logging but daemonize, logs will be sent to /dev/null
   syslog-enabled：no, #是否把日志输出到syslog中，默认NO
   syslog-ident：redis, #指定syslog里的日志标志，默认redis
		# Specify the syslog identity.
		# syslog-ident redis
   syslog-facility：local0, #指定syslog设备，值可以是USER或LOCAL0-LOCAL7，默认为local0
   databases：16, #数据库，默认16个库，切换库：select dbid # dbid is a number between 0 and 'databases'-1
	```

   **SNAPSHOTTING[快照]：**
   RDB是整个内存的压缩过的Snapshot，RDB的数据结构，可以配置复合的快照触发条件！

   ```conf
   Save：900 1,# Save the DB on disk 将数据保存到磁盘，语法：save <秒钟> <写操作次数> 或 save <seconds> <changes>
		#   after 900 sec (15 min) if at least 1 key changed #save 900 1，即15分钟内改了1次
		#   after 300 sec (5 min) if at least 10 keys changed #save 300 10，即5分钟内改了10次
		#   after 60 sec if at least 10000 keys changed #save 60 10000，即1分钟内改了1万次
		# 注意：如果想禁用RDB持久化的策略，只要不设置任何save指令，或者给save传入一个空字符串参数也可以，如：save ""
   stop-writes-on-bgsave-error：yes, #默认yes，快照关闭了导致不能持久化的问题，即当bgsave快照操作出错时停止写数据到磁盘，这样后面写错做均会失败，为了不影响后续写操作，故需将该项值改为no。
   rdbcompression：yes, #默认开启yes，对于存储到磁盘中的快照，可以设置是否进行压缩存储。如果是的话，redis会采用LZF算法进行压缩。如果你不想消耗CPU来进行压缩的话，可以设置为关闭此功能。
   rdbchecksum：yes, #在存储快照后，还可以让redis使用CRC64算法来进行数据校验，但是这样做会增加大约10%的性能消耗，如果希望获取到最大的性能提升，可以关闭此功能。
   dbfilename：dump.rdb, #默认：dump.rdb # The filename where to dump the DB
   dir：./, #本地数据库存放的路径，redis的路径目录，默认./
   ```

   **REPLICATION[复制]:**
   #Master-Slave replication 主从复制，默认关闭该功能，主从复制含义：主机数据更新之后，根据配置和策略，自动同步到备机的机制。Master以写为主，Slave以读为主。实现了读写分离与容灾恢复。Redis 支持简单易用的主从复制（master-slave replication）功能， 该功能可以让从服务器(slave server)成为主服务器(master server)的精确复制品。
   语法：
   方式一：配置从服务器，只需在配置文件中增加一行：slaveof <masterip> <masterport>，如果主机有密码，需要配置访问密码：masterauth <master-password>
   方式二：通过redis客户端工具连接到从（slave）服务器，输入主服务器的IP和端口，然后同步就会开始：SLAVEOF [masterip] [masterport]
   参数：
   ```conf
   slave-serve-stale-data：yes, #默认yes，表示主从复制中，从服务器可以响应客户端请求；
   ```

   **SECURITY[安全]:**
   访问密码的查看、设置和取消；

   ```conf
   # Require clients to issue AUTH <PASSWORD> before processing any other commands.This might be useful in environments in which you do not trust
   # others with access to the host running redis-server.
   # requirepass foobared
   # 使用[客户端连接工具设置]：
   # config get requirepass				#获取
   # config set requirepass "123456"	#设置，设置成功后，下次操作需要Auth
   # auth 123456
   ```

   **LIMITS[限制]:**

   ```conf
   maxclients：10000, #客户端最大连接数限制，设置redis允许同时可以与多少个客户端进行连接，默认情况下为10000个客户端。如果达到了此限制，redis则会拒绝新的连接请求，并且向这些连接请求方发出“max number of clients reached”以作回应。
   maxmemory：<bytes> #设置redis可以使用的最大内存量。一旦到达内存使用上限，redis将会试图移除内部数据，移除规则可以通过maxmemory-policy来指定。如果redis无法根据移除规则来移除内存中的数据，或者设置了“不允许移除”，那么redis则会针对那些需要申请内存的指令返回错误信息，比如SET、LPUSH等。但是对于无内存申请的指令，仍然会正常响应，比如GET等。如果你的redis是主redis（说明你的redis有从redis），那么在设置内存使用上限时，需要在系统中留出一些内存空间给同步队列缓存，只有在你设置的是“不移除”的情况下，才不用考虑这个因素。
   # maxmemory can be a good idea mainly if you want to use Redis as a 'state' server or cache, not as a real DB.
   maxmemory-policy：volatile-lru, #设置内存使用上限策略
     # volatile-lru：使用LRU算法移除key，只对设置了过期时间的键；
     # allkeys-lru：使用LRU算法移除key；
     # volatile-random：在过期集合中移除随机的key，只对设置了过期时间的键；
     # allkeys-random：移除随机的key；
     # volatile-ttl：移除那些TTL值最小的key，即那些最近要过期的key；
     # noeviction：不进行移除。针对写操作，只是返回错误信息。
   maxmemory-samples：3, #设置样本数量，LRU算法和最小TTL算法都并非是精确的算法，而是估算值，所以你可以设置样本的大小，	redis默认会检查这么多个key并选择其中LRU的那个。
   ```

   **APPEND ONLY MODE[追加]：**
   
