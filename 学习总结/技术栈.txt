----------------------------------------------容器虚拟化技术Docker------------------------------------------------------- 
一、容器虚拟化技术Docker
	定义：解决了运行环境和配置问题软件容器，方便做持续集成并有助于整体发布的容器虚拟化技术。
	特点:一次构建、随处运行，DevOps，内核虚拟化，依赖与宿主机内核（不同于传统的虚拟机技术）
	基本组成：镜像、容器、仓库
	docker安装：
	docker启动：centos 6+ 命令：service docker start
				centos 7+ 命令：systemctl start docker 
	docker关闭重启：centos 7+ 命令：systemctl restart docker  systemctl stop docker systemctl enable docker //开机自启
二、常用命令：
	帮助命令：docker version/docker info/docker --help
	镜像命令：docker images 
			  docker search XXX镜像名，可选参数：
			  docker pull XXX镜像名
			  docker rmi -f XXX镜像名ID
			  移除所有镜像：docker rmi -f $(docker images -qa)
	容器命令：docker run [OPTIONS] IMAGE [COMMAND] [ARG...]
			   OPTIONS说明（常用）：有些是一个减号，有些是两个减号
				--name="容器新名字": 为容器指定一个名称；
				-d: 后台运行容器，并返回容器ID，也即启动守护式容器；
				-i：以交互模式运行容器，通常与 -t 同时使用；
				-t：为容器重新分配一个伪输入终端，通常与 -i 同时使用；
				-P: 随机端口映射；
				-p: 指定端口映射，有以下四种格式
					  ip:hostPort:containerPort
					  ip::containerPort
					  hostPort:containerPort
					  containerPort 
			当前所有正在运行的容器：docker ps [OPTIONS] 
									OPTIONS说明（常用）：
									-a :列出当前所有正在运行的容器+历史上运行过的
									-l :显示最近创建的容器。
									-n：显示最近n个创建的容器。
									-q :静默模式，只显示容器编号。
									--no-trunc :不截断输出。
			退出容器：容器停止退出exit
					  容器不停止退出ctrl+P+Q
			启动/停止/重启/强制停止容器：docker start/stop/restart/kill 容器ID或者容器名
			删除已停止的容器：docker rm -f 容器ID 
			删除所有容器：docker rm -f $(docker ps -a -q) 或docker ps -a -q | xargs docker rm
			启动守护式容器：docker run -d 容器名
			查看容器日志：docker logs -f -t --tail n 容器ID
			查看容器内运行的进程：docker top 容器ID
			查看容器内部细节：docker inspect 容器ID
			进入正在运行的容器并以命令行交互：docker exec -it 容器ID bashShell
											  重新进入docker attach 容器ID
			从容器内拷贝文件到主机上：docker cp 容器ID:容器内路径 目的主机路径
三、Docker镜像
	镜像加速原理：bootfs(加载kernel) / rootfs(不同的操作系统发行版)			
	分层的联合文件系统：最大的一个好处就是 - 共享资源
	Docker镜像commit操作补充：docker commit -m=“提交的描述信息” -a=“作者” 容器ID 要创建的目标镜像名:[标签名]
四、Docker容器数据卷
	作用：容器间继承+共享数据、容器的持久化
	卷的设计目的就是数据的持久化，完全独立于容器的生存周期，因此Docker不会在容器删除时删除其挂载的数据卷
	特点：
		1：数据卷可在容器之间共享或重用数据
		2：卷中的更改可以直接生效
		3：数据卷中的更改不会包含在镜像的更新中
		4：数据卷的生命周期一直持续到没有容器使用它为止
	直接命令添加：
		docker run -it -v /宿主机绝对路径目录:/容器内目录[:ro] [--privileged=true] 镜像名
	查看数据卷是否挂载成功
		docker inspect 容器ID
	容器和宿主机之间数据共享				  
	容器停止退出后，宿主机修改后数据是否同步-同步				  
	DockerFile添加-生成镜像：
		使用方式：在Dockerfile中使用VOLUME指令来给镜像添加一个或多个数据卷，格式：VOLUME["/dataVolumeContainer1","/dataVolumeContainer2","/dataVolumeContainer3"]
		构建：docker build -f Dockerfile路径 -t 新的镜像名
	数据卷容器(容器间继承+传递共享数据)：
		语法：--volumes-from，例如：docker run -it --name doc2 --volumes-from doc01 zzyy/centos
五、DockerFile解析
	定义：Dockerfile是用来构建Docker镜像的构建文件，是由一系列命令和参数构成的脚本。
	构建三步骤：编写Dockerfile文件、docker build、docker run
	关系：
		Dockerfile面向开发，Docker镜像成为交付标准，Docker容器则涉及部署与运维，三者缺一不可，合力充当Docker体系的基石
	保留字:
六、Docker发布
	aliyun镜像的使用：
	登录阿里云Docker Registry：$ sudo docker login --username=ali域逸诚 registry.cn-hangzhou.aliyuncs.com
	从Registry中拉取镜像：$ sudo docker pull registry.cn-hangzhou.aliyuncs.com/ali_yuyicheng/redis_test:[镜像版本号]				  
	将镜像推送到Registry：				  
					$ sudo docker login --username=ali域逸诚 registry.cn-hangzhou.aliyuncs.com
					$ sudo docker tag [ImageId] registry.cn-hangzhou.aliyuncs.com/ali_yuyicheng/redis_test:[镜像版本号]
					$ sudo docker push registry.cn-hangzhou.aliyuncs.com/ali_yuyicheng/redis_test:[镜像版本号]  
					
----------------------------------------------文档数据结构MongoDB的使用-------------------------------------------------------					  
一、npm（Node Package Manager 包管理器）工具的使用
	- 通过npm可以对node中的包进行上传、下载、搜索等操作
		- npm会在安装完node以后，自动安装
		- npm的常用指令
			npm -v 查看npm的版本
			npm version 查看所有模块的版本
			npm init 初始化项目-创建package.json
			npm i/install 包名 安装指定的包
			npm i/install 包名 --save 安装指定的包并添加依赖
			npm i/install 包名 -g 全局安装（一般都是一些工具）
			npm i/install 安装当前项目所依赖的包
			npm s/search 包名 搜索包	
			npm r/remove 包名 删除一个包
二、MongoDB	
	定义：为快速开发WEB应用而设计的数据库，面向文档，类似JSON数据(BSON),注意：MongoDB数据库使用的是JavaScript进行操作的，在MongoDB含有一个对ES标准实现的引擎，
		在MongoDB中所有ES中的语法中都可以使用
	启动：
		- 打开cmd命令行窗口
			- 输入 mongod 启动mongodb服务器
			- 32位注意：
				启动服务器时，需要输入如下内容
					mongod --storageEngine=mmapv1
					mongod --dbpath 数据库路径 --port 端口
			
		- 再打开一个cmd窗口
			- 输入 mongo 连接mongodb ，出现 >				  
					  
	- 基本概念
		数据库（database）- 类比SQL数据库、集合（collection）- 类比SQL表、文档（document）- 类比SQL表记录
		- 在MongoDB中，数据库和集合都不需要手动创建，当我们创建文档时，如果文档所在的集合或数据库不存在会自动创建数据库和集合		
		
	- 基本指令
		show dbs/databases 
			- 显示当前的所有数据库
		use 数据库名
			- 进入到指定的数据库中
		db
			- db表示的是当前所处的数据库
		show collections
			- 显示数据库中所有的集合
			
	- 数据库的CRUD（增删改查）的操作
		  
		- 向数据库中插入文档
		- db.collection.insert()
			- insert()可以向集合中插入一个或多个文档
		- db.collection.insertOne()
			- 向集合中插入一个文档
		- db.collection.insertMany()
			- 向集合中插入多个文档
		如：db.stus.insert([
				{name:"沙和尚",age:38,gender:"男"},
				{name:"白骨精",age:16,gender:"女"},
				{name:"蜘蛛精",age:14,gender:"女"}
			]);
			db.stus.find({}); //查询所有文档
				
		- 查询数据库中的文档
			- db.collection.find()
				- 可以根据指定条件从集合中查询所有符合条件的文档
				- 返回的是一个数组
			- db.collection.findOne()
				- 查询第一个符合条件的文档
				- 返回的是一个对象
			- db.collection.find().count()
				- 查询符合条件的文档的数量
			查询条件：
				-$gt $eq $lt $lte limit() $or
				如：db.emp.find({sal:{$lt:2000 , $gt:1000}}).limit(5);
					db.emp.find({$or:[{sal:{$lt:1000}} , {sal:{$gt:2500}}]});
			分页：
			skip()用于跳过指定数量的数据，MongoDB会自动调整skip和limit的位置
			如：db.numbers.find().skip(10).limit(10); -第11条到20条数据	
			如：db.stus.find({age:16 , name:"白骨精"});
				
		- 修改数据库中的文档
			- db.collection.update()
				- 可以修改、替换集合中的一个或多个文档（默认修改一个）
				注意：  - update()默认情况下会使用新对象来替换旧的对象
						- 如果需要修改指定的属性，而不是替换需要使用“修改操作符”来完成修改
							$set 可以用来修改文档中的指定属性
							$unset 可以用来删除文档的指定属性
							内嵌文档中：
							$push 用于向数组中添加一个新的元素
							$addToSet 向数组中添加一个新元素 ，如果数组中已经存在了该元素，则不会添加
							$inc 增加到	，如:db.emp.updateMany({sal:{$lte:1000}} , {$inc:{sal:400}});						
						- update()默认只会修改一个
			- db.collection.updateOne()
				- 修改集合中的一个文档
			- db.collection.updateMany()
				- 修改集合中的多个文档
			- db.collection.replaceOne()
				- 替换集合中的一个文档
			如：db.stus.update(
				{"_id" : ObjectId("59c219689410bc1dbecc0709")},
				{$set:{
					gender:"男",
					address:"流沙河"
				}}    
			)
			又如：db.stus.update(
					{"name" : "猪八戒"},
					
					{
						$set:{
						address:"呵呵呵"
						}
					}  ,
					{
						multi:true
					}    
				)
				
		- 删除集合中的文档
			- db.collection.remove()
				- 删除集合中的一个或多个文档（默认删除多个），可以第二个参数传递一个true，则只会删除一个
			- db.collection.deleteOne()
				- 删除集合中的一个文档
			- db.collection.deleteMany()
				- 删除集合中的多个文档
			- 清空一个集合
				db.collection.remove({})
			- 删除一个集合
				db.collection.drop()
			- 删除一个数据库
				db.dropDatabase()	
			注意：一般数据库数据中添加一个字段，来表示数据是否被删除
				如：db.stus.insert([
					{
						name:"zbj",
						isDel:0
						},
						{
						name:"shs",
						isDel:0
						},
					{
					name:"ts",
						isDel:0
					}

				]);
				db.stus.updateOne({name:"ts"},{$set:{isDel:1}});	
				db.stus.find({isDel:0});
	文档关系：一对一（one to one），内嵌文档的形式
			  如：db.wifeAndHusband.insert([
					{
						name:"黄蓉",
						husband:{
							name:"郭靖"
						}
					},{
						name:"潘金莲",
						husband:{
							name:"武大郎"
						}
					}

				]);
			  一对多（one to many）/多对一(many to one)，也可以用内嵌文档的形式
			  多对多(many to many) 用两个集合表示
	排序与投影：
			查询文档时，默认情况是按照_id的值进行排列（升序）
			sort()可以用来指定文档的排序的规则,sort()需要传递一个对象来指定排序规则 1表示升序 -1表示降序
			limit skip sort 可以以任意的顺序进行调用
			如：db.emp.find({}).sort({sal:1,empno:-1});
			在查询时，可以在第二个参数的位置来设置查询结果的投影，0不显示；1：显示
			如：db.emp.find({},{ename:1 , _id:0 , sal:1});
	分组查询：
		分组分片查询，aggregate的使用
		//源数据
		db.items.insert( [
		  {
		   "quantity" : 2,
		   "price" : 5.0,
		   "pnumber" : "p003",
		  }...,{
		   "quantity" : 5,
		   "price" : 10.0,
		   "pnumber" : "p002"
		  }
		])    
		//$group语法:{ $group: { _id: <expression>, <field1>: { <accumulator1> : <expression1> }, ... } }
		/*
		 *_id 分组的key,expression分组的字段，如果_id为null 相当于SQL:select count(*) from table
		 *field1 分组后展示的字段
		 *accumulator1 分组管道函数，如：$sum\$avg\$min\$max\$push\$addToSet\$first\$last
		 *expression1  分组显示数据相关
		 */	
		//查询总数,相当于SQL:select count(1) as count from items
		db.items.count();
		db.items.aggregate([{$group:{_id:null,count:{$sum:1}}}])
		//统计数量，相当于SQL:select sum(quantity) as total  from  items
		db.items.aggregate([{$group:{_id:null,total:{$sum:"$quantity"}}}]);
		//按产品类型来进行分组，然后在统计卖出的数量是多少，相当于SQL：select sum(quantity) as total from  items  group by pnumber
		db.items.aggregate([{$group:{_id:"$pnumber",total:{$sum:"$quantity"}}}])
		//通过相同的产品类型来进行分组，然后查询相同产品类型卖出最多的订单详情，相当于SQL:select max(quantity) as quantity from  items  group by pnumber
		db.items.aggregate([{$group:{_id:"$pnumber",max:{$max:"$quantity"}}}])
		db.items.aggregate([{$group:{_id:"$pnumber",min:{$min:"$quantity"}}}])
		//通过相同的产品类型来进行分组，统计各个产品数量，然后获取最大的数量，相当于SQL:select max(t.total) from (select sum(quantity) as total from  items  group by pnumber) t
		db.items.aggregate([{$group:{_id:"$pnumber",total:{$sum:"$quantity"}}}])
		db.items.aggregate([{$group:{_id:"$pnumber",total:{$sum:"$quantity"}}},{$group:{_id:null,max:{$max:"$total"}}}])
		//通过相同的产品类型来进行分组，然后查询每个订单详情相同产品类型卖出的平均价格，相当于SQL:select avg(price) as price from  items  group by pnumber
		db.items.aggregate([{$group:{_id:"$pnumber",price:{$avg:"$price"}}}])
		//通过相同的产品类型来进行分组，然后查询每个相同产品卖出的数量放在数组里面,，注意值数组中的值不要超过16M
		db.items.aggregate([{$group:{_id:"$pnumber",quantitys:{$push:"$quantity"}}}])
		db.items.aggregate([{$group:{_id:"$pnumber",quantitys:{$push:{quantity:"$quantity",price:"$price"}}}}])
		//表达式的值添加到一个数组中（无重复值），这个值不要超过16M
		db.items.aggregate([{$group:{_id:"$pnumber",quantitys:{$addToSet:"$quantity"}}}])
		//$first：返回每组第一个文档，如果有排序，按照排序，如果没有按照默认的存储的顺序的第一个文档。
		//$last：返回每组最后一个文档，如果有排序，按照排序，如果没有按照默认的存储的顺序的最后个文档。
		db.items.aggregate([{$group:{_id:"$pnumber",quantityFrist:{$first:"$quantity"}}}])
		//$project显示或不显示字段，相当于SQL:select
		db.items.aggregate([{$group:{_id:null,count:{$sum:1}}},{$project:{"_id":0,"count":1}}])
		//通过滤订单中，想知道卖出的数量大于8的产品有哪些产品，相当于SQL:select sum(quantity) as total from  items  group by pnumber having total>8   
		db.items.aggregate([{$group:{_id:"$pnumber",total:{$sum:"$quantity"}}},{$match:{total:{$gt:8}}}])
		//$match如果是放在$group之前就是当做where来使用，我们只统计pnumber =p001 产品卖出了多少个  select sum(quantity) as total from  items where pnumber='p001'
		db.items.aggregate([{$match:{"pnumber":"p001"}},{$group:{_id:null,total:{$sum:"$quantity"}}}])
		//$skip、$limit使用顺序不同，结果也不同，注意：$limit、$skip、$sort、$match可以使用在阶段管道，如果使用在$group之前可以过滤掉一些数据，提高性能
		db.items.aggregate([{ $skip: 2 },{ $limit: 4 },{ $sort: { quantity : -1 }}])
		db.items.aggregate([{ $limit: 4 },{ $skip: 2 }])
		//将文档中的某一个数组类型字段拆分成多条，每条包含数组中的一个值
		db.items.aggregate([{$group:{_id:"$pnumber",quantitys:{$push:"$quantity"}}}])
		db.items.aggregate([{$group:{_id:"$pnumber",quantitys:{$push:"$quantity"}}},{$unwind:"$quantitys"}])
		//$out必须为pipeline最后一个阶段管道，因为是将最后计算结果写入到指定的collection中
		db.items.aggregate([{$group:{_id:"$pnumber",quantitys:{$push:"$quantity"}}},{$unwind:"$quantitys"},{$project:{"_id":0,"quantitys":1}},{$out:"result"}])
		db.result.find()
	模糊查询：$options - 可选参数				  
		如：db.students.find({"user_name": {$regex: /尚/, $options:'i'}}); 
			db.students.find({"user_name": {$regex:/尚.*/i}}); 
			db.students.find({user_name:{$in:[/^孙尚香/i,/^胡歌/]}});
			db.students.find({user_name:{$regex:/^孙尚香/i,$nin:['孙尚香II']}});
			db.students.find({user_name:{$regex:/香/,$options:"si"}});
	
			
----------------------------------------------SpringCloud技术栈的使用---------------------------------------------------------						  
	基础概念：
	    微服务：强调的是服务的大小，它关注的是某一个点，是具体解决某一个问题/提供落地对应服务的一个服务应用
		-最早提出：马丁福勒
				微服务化的核心是将传统的一站式应用，根据业务拆分成一个一个的服务，彻底
		地去耦合,每一个微服务提供单个业务功能的服务，一个服务做一件事，
		从技术角度看就是一种小而独立的处理过程，类似进程概念，能够自行单独启动
		或销毁，拥有自己独立的数据库。
		微服务架构：架构模式，微服务之间互相协调、互相配合，每个服务运行在其独立的进程中，
			服务与服务间采用轻量级的通信机制互相协作（通常是基于HTTP协议的RESTful API），包括一些环境，有机构成的整体。
		优点缺点：
		-优点：内聚小，松耦合，拥有独立的进程，开发简单；
			   易于与第三方集成，如：与持续自动化构建部署（Jenkins, Hudson）
			   微服务只是业务逻辑的代码，不会和HTML,CSS 或其他界面组件混合（前后端分离思想）。
		-缺点：开发人员要处理分布式系统的复杂性
			   多服务运维难度，随着服务的增加，运维的压力也在增大
			   系统部署依赖
			   服务间通信成本、数据一致性、系统集成测试、性能监控……
		微服务技术栈：
			微服务条目			落地技术											备注			               
			
			服务开发			Springboot、Spring、SpringMVC
			服务配置与管理		Netflix公司的Archaius、阿里Diamond等
			服务注册与发现		Eureka、Consul、Zookeeper、AliBabaNacos等
			服务调用			Rest、RPC、gRPC
			服务熔断器			Hystrix、Envoy等
			负载均衡			Ribbon、Feign Nginx等
			服务接口调用(客户端调用服务的简化工具)
								Feign等
			消息队列			Kafka、RabbitMQ、ActiveMQ等
			服务配置中心管理  	SpringCloudConfig、Chef等
			服务路由（API网关） Zuul、Spring Cloud Gateway等
			服务监控			Zabbix、Nagios、Metrics、Spectator等
			全链路追踪			Zipkin，Brave、Dapper、Sleuth等
			服务部署			Docker、OpenStack、Kubernetes等
			数据流操作开发包	SpringCloud Stream（封装与Redis,Rabbit、Kafka等发送接收消息）
			事件消息总线    	Spring Cloud Bus
			......
    SpringCloud入门介绍：
		含义：SpringCloud=分布式微服务架构下的一站式解决方案，是各个微服务架构落地技术的集合体，俗称微服务全家桶
		与springboot之间关系：SpringBoot可以离开SpringCloud独立使用开发项目，
							  但是SpringCloud离不开SpringBoot，属于依赖的关系.
							  SpringBoot专注于快速、方便的开发单个微服务个体，SpringCloud关注全局的服务治理框架。
		与Dubbo的比较： 最大区别：SpringCloud抛弃了Dubbo的RPC通信，采用的是基于HTTP的REST方式。
						REST相比RPC更为灵活，服务提供方和调用方的依赖只依靠一纸契约，这在强调快速演化的微服务环境下，显得更加合适。
						品牌机与组装机的区别
						Spring Cloud的功能比DUBBO更加强大，涵盖面更广，而且作为Spring的拳头项目，它也能够与Spring Framework、Spring Boot、Spring Data、Spring Batch等其他Spring项目完美融合，这些对于微服务而言是至关重要的。
						使用Dubbo构建的微服务架构就像组装电脑，各环节我们的选择自由度很高；
						而Spring Cloud就像品牌机，在Spring Source的整合下，做了大量的兼容性测试，保证了机器拥有更高的稳定性。
						社区支持与更新力度
						最为重要的是，DUBBO停止了5年左右的更新，虽然2017.7重启了(刘军)。对于技术发展的新需求，需要由开发者自行拓展升级（比如当当网弄出了DubboX），这对于很多想要采用微服务架构的中小软件组织，显然是不太合适的，中小公司没有这么强大的技术能力去修改Dubbo源码+周边的一整套解决方案，并不是每一个公司都有阿里的大牛+真实的线上生产环境测试过。
	简单服务调用：
			-RestTemplate + API 使用方式： 
			 RestTemplate提供了多种便捷访问远程Http服务的方法，是一种简单便捷的访问restful服务模板类，是Spring提供的用于访问Rest服务的客户端模板工具集 
			使用步骤：
			1，注入Bean：
			如：@Configuration
				public class ConfigBean
				{
				 @Bean
				public RestTemplate getRestTemplate()
					{
				return new RestTemplate();
					}
				}
			2，声明使用：
			@Autowired
			private RestTemplate restTemplate;
			
			方法中：
			restTemplate.postForObject(REST_URL_PREFIX+"/dept/add", dept, Boolean.class); - 参数：REST请求地址、请求参数、HTTP响应转换被转换成的对象类型

	服务注册与发现：
			-Eureka(C/S)：
				简介：Netflix公司的子模块，是一个基于REST的服务，用于定位服务，以实现云端中间层服务发现和故障转移。Netflix在设计Eureka时遵守的就是AP原则
				CAP原则：CAP原则又称CAP定理，指的是在一个分布式系统中，Consistency（一致性）、 Availability（可用性）、Partition tolerance（分区容错性），三者不可兼得
				三大角色：1、Eureka Server 提供服务注册和发现；2、Service Provider服务提供方将自身服务注册到Eureka，从而使服务消费方能够找到；3、Service Consumer服务消费方从Eureka获取注册服务列表，从而能够消费服务
			使用注册：
				服务端：
				1,引用模块：POM.XML
					<dependency>
					<groupId>org.springframework.cloud<groupId>
					<artifactId>spring-cloud-starter-eureka-server<artifactId>
					</dependency>
				2,配置参数：application.properties或YML文件的配置
				格式：eureka.instance.hostname=localhost
					  #不要向注册中心注册自己
					  eureka.client.register-with-eureka=false
					  #禁止检索服务
					  eureka.client.fetch-registry=false
					  eureka.client.service-url.defaultZone=http://${eureka.instance.hostname}:${server.port}/eureka	
				3,申明使用：程序main入口，添加@EnableEurekaServer注解，来开启服务注册中心
				客户端：
				1,引用模块：POM.XML
					 <dependency>
						<groupId>org.springframework.cloud</groupId>
						<artifactId>spring-cloud-starter-eureka</artifactId>
					</dependency>
				2,配置参数：application.properties或YML文件的配置
				格式：
					#设置服务名
					spring:
					  application:
						name: 服务名
					eureka:
						  client: #客户端注册进eureka服务列表内
							service-url: 
							  defaultZone: http://localhost:7001/eureka
							  instance:
								instance-id: 服务实例名（设置后可以隐藏主机名）
							  prefer-ip-address: true #访问路径可以显示IP地址
							  #点击显示
							  info:
								  app.name: 服务程序名
								  company.name: 公司名
								  build.artifactId: $project.artifactId$
								  build.version: $project.version$
							  
				3,申明使用：主类上添加@EnableEurekaClient注解以实现Eureka中的DiscoveryClient实现，可以使用@EnableDiscoveryClient代替
			使用发现：
				申明使用，主启动类添加@EnableDiscoveryClient
			    使用时注入， @Autowired
							 private DiscoveryClient client;即可使用，注：DiscoveryClient是spring clould 对治理体系的一个抽象
			自我保护机制：某时刻某一个微服务不可用了，eureka不会立刻清理，依旧会对该微服务的信息进行保存
			集群处理：
				在Eureka服务器中添加配置：
				eureka: 
					instance:
						hostname: eureka1.com #eureka服务端的实例名称
					client: 
						register-with-eureka: false #false表示不向注册中心注册自己。
						fetch-registry: false #false表示自己端就是注册中心，我的职责就是维护服务实例，并不需要去检索服务
					service-url: 
					#单机 defaultZone: http://${eureka.instance.hostname}:${server.port}/eureka/       #设置与Eureka Server交互的地址查询服务和注册服务都需要依赖这个地址（单机）。
					defaultZone: http://eureka1.com:7002/eureka/,http://eureka3.com:7003/eureka/
			与Dubbo的Zookeeper的比较：
				著名的CAP理论指出，一个分布式系统不可能同时满足C(一致性)、A(可用性)和P(分区容错性)。由于分区容错性P在是分布式系统中必须要保证的，因此我们只能在A和C之间进行权衡。
				因此,Zookeeper保证的是CP,Eureka则是AP。因此，Eureka可以很好的应对因网络故障导致部分节点失去联系的情况，而不会像zookeeper那样使整个注册服务瘫痪。

			-Consul：
				简介：Spring Cloud Consul是分布式的、高可用、横向扩展(AP原则)，它包含多个组件，但是作为一个整体，在微服务架构中为我们的基础设施提供服务发现和服务配置的工具。它包含了下面几个特性：
					  服务发现（service discovery）
					  健康检查（health checking）
					  Key/Value存储（一个用来存储动态配置的系统）
					  多数据中心（multi-datacenter）
				使用-客户端：
				1,引用模块：POM.XML
					<dependency>
					  <groupId>org.springframework.cloud</groupId>
					  <artifactId>spring-cloud-starter-consul-discovery</artifactId>
					</dependency>
				2,配置参数：application.properties或YML文件的配置
				格式：
					  spring.cloud.consul.host=localhost #域名
					  spring.cloud.consul.port=8500 #端口
	
				3,申明使用：程序main入口，添加@EnableDiscoveryClient注解，开启服务治理
				注意：consul不需要创建类似eureka-server的服务端吗？由于Consul自身提供了服务端，所以我们不需要像之前实现Eureka的时候创建服务注册中心，直接通过下载consul的服务端程序就可以使用。
				启动consul服务：$consul agent -dev
				
			-Nocas：
				参考Spring Cloud Alibaba 技术站的Nocas相关内容；
				
				详情参考：https://blog.csdn.net/qq_38765404/article/details/89521124

	负载均衡：
			-Ribbon（结合Eureka使用）：
			 简介：基于Netflix实现的一套客户端负载均衡的工具，主要功能是提供客户端的软件负载均衡算法。
			 负载均衡：将用户的请求基于某种规则平摊的分配到多个服务上，从而达到系统的HA，常见的负载均衡有软件Nginx，LVS，硬件F5等
				分类：集中式LB-即在服务的消费方和提供方之间使用独立的LB设施(可以是硬件，如F5, 也可以是软件，如nginx), 由该设施负责把访问请求通过某种策略转发至服务的提供方；
					  进程内LB-将LB逻辑集成到消费方，消费方从服务注册中心获知有哪些地址可用，然后自己再从这些地址中选择出一个合适的服务器。Ribbon就属于进程内LB。
			 使用：
				1,引用模块：POM.XML
					 <dependency>
						<groupId>org.springframework.cloud</groupId>
						<artifactId>spring-cloud-starter-ribbon</artifactId>
					</dependency>
					<dependency>
						<groupId>org.springframework.cloud</groupId>
						<artifactId>spring-cloud-starter-eureka</artifactId>
					</dependency>
				2,配置参数：application.properties或YML文件的配置
				格式：（eureka配置）
					server:
						port: 80
						eureka:
							client:
							register-with-eureka: false
							service-url: 
							defaultZone: http://eureka1.com:7001/eureka/,http://eureka2.com:7002/eureka/,http://eureka3.com:7003/eureka/
	
				3,申明使用：1、程序main入口，添加@EnableDiscoveryClient注解，开启服务治理；2、在配置文件ConfigBean 中添加@LoadBalanced注解
				  -》结论：Ribbon和Eureka整合后服务消费方可以直接调用服务而不用再关心地址和端口号
			    4,策略IRule：简单轮询负载均衡RoundRobinRule，区别于RetryRule，随机负载均衡，加权响应时间负载均衡 ，区域感知轮询负载均衡
			 自定义Ribbon：	
				主启动类添加@RibbonClient注解，格式：@RibbonClient(name="MICROSERVICECLOUD",configuration=MySelfRule.class)，注意：这个自定义配置类不能放在@ComponentScan所扫描的当前包下以及子包下，
					否则我们自定义的这个配置类就会被所有的Ribbon客户端所共享，也就是说我们达不到特殊化定制的目的了。
				在配置文件ConfigBean中添加@LoadBalanced注解
			
			-Feign（声明式服务调用，WebService客户端）：它的使用方法是定义一个接口，然后在上面添加注解，同时也支持JAX-RS（Java API for RESTful Web Services）标准的注解。
			 特性：
				可插拔式的注解支持，包括Feign注解和JAX-RS注解;
				支持可插拔的HTTP编码器和解码器;
				支持Hystrix和它的Fallback;
				支持Ribbon的负载均衡;
				支持HTTP请求和响应的压缩
			 使用：
				1,引用模块：POM.XML
					 <dependency>
						<groupId>org.springframework.cloud</groupId>
						<artifactId>spring-cloud-starter-feign</artifactId>
					</dependency>
					　<dependency>
						<groupId>org.springframework.cloud</groupId>
						<artifactId>spring-cloud-starter-eureka</artifactId>
						<version>1.3.5.RELEASE</version>
					</dependency>
				2,配置参数：application.properties或YML文件的配置
				格式：（整合eureka配置）
					server:
						port: 80
						eureka:
							client:
							register-with-eureka: false
							service-url: 
							defaultZone: http://eureka1.com:7001/eureka/,http://eureka2.com:7002/eureka/,http://eureka3.com:7003/eureka/
	
				3,申明使用：1、程序main入口，添加@EnableDiscoveryClient注解，开启服务治理；同时添加@EnableFeignClients 来开启feign
			                2, 定义接口：
							   格式：value=“服务名称”,configuration = xxx.class 这个类配置Hystrix的一些精确属性
			                   @FeignClient(value = "serviceName",fallback = FeignFallBack.class)
							    public interface FeignService {
									@RequestMapping(value = "/ml", method= RequestMethod.GET)
									String method1(@RequestParam("name") String name) ;
								}
								@Component
								public class FeignFallBack implements FeignService{
							　　//实现的方法是服务调用的降级方法
								@Override
								public String method1() {
									return "error";
								}
								
	服务熔断器（断路器）：		 
			-Hystrix：
			 概念来源：服务雪崩：
				服务扇出：多个微服务之间调用的时候，假设微服务A调用微服务B和微服务C，微服务B和微服务C又调用其它的微服务，这就是所谓的“扇出”效应。
				解决方案：熔断模式（容错处理机制）、隔离模式（容错处理机制）、限流模式（预防模式）
			 简介：Hystrix是一个用于处理分布式系统的延迟和容错的开源库，在分布式系统（SOA面向服务架构）里，许多依赖不可避免的会调用失败，比如超时、异常等，Hystrix能够保证在一个依赖出问题的情况下，不会导致整体服务失败，避免级联故障，以提高分布式系统的弹性。
				   “断路器”本身是一种开关装置，当某个服务单元发生故障之后，通过断路器的故障监控（类似熔断保险丝），
				   向调用方返回一个符合预期的、可处理的备选响应（FallBack），而不是长时间的等待或者抛出调用方无法处理的异常，这样就保证了服务调用方的线程不会被长时间、不必要地占用，从而避免了故障在分布式系统中的蔓延，乃至雪崩。
			 服务熔断
				使用：
					概念：当扇出链路的某个微服务不可用或者响应时间太长时，会进行服务的降级，进而熔断该节点微服务的调用，快速返回"错误"的响应信息。 
						  SpringCloud框架里熔断机制通过Hystrix实现。Hystrix会监控微服务间调用的状况，当失败的调用到一定阈值，缺省是5秒内20次调用失败就会启动熔断机制。熔断机制的注解是@HystrixCommand。
					1,引用模块：POM.XML
						 <dependency>
							<groupId>org.springframework.cloud</groupId>
							<artifactId>spring-cloud-starter-hystrix</artifactId>
						</dependency>
					2,配置参数：application.properties或YML文件的配置
					格式：（配合eureka配置）
						server:
							port: 80
							eureka:
								client:
								register-with-eureka: false
								service-url: 
								defaultZone: http://eureka1.com:7001/eureka/,http://eureka2.com:7002/eureka/,http://eureka3.com:7003/eureka/
		
					3,申明使用：1、程序main入口，添加@EnableCircuitBreaker注解，开启熔断支持；
								2、在控制层申明使用
									格式示例：fallbackMethod 快速应急的处理方法，进行服务降级处理
									@RequestMapping(value="/dept/get/{id}",method=RequestMethod.GET)
									@HystrixCommand(fallbackMethod = "processHystrix_Get")
									public Dept get(@PathVariable("id") Long id){
									    Dept dept =  this.service.get(id);
										if(null == dept){
										throw new RuntimeException("该ID："+id+"没有没有对应的信息");
									    }
										return dept;	
									}
									public Dept processHystrix_Get(@PathVariable("id") Long id){ 
										return new Dept().setDeptno(id)
											   .setDname("该ID："+id+"没有没有对应的信息,null--@HystrixCommand")
											   .setDb_source("no this database in MySQL");
									}
			 
			 服务降级Fallback
				使用： 
					概念：整体资源快不够了，忍痛将某些服务先关掉，待渡过难关，再开启回来。
						  服务降级处理是在客户端实现完成的，与服务端没有关系。
				    申明使用（与Feign结合使用）：	
						格式示例：
						@FeignClient(value = "MICROSERVICECLOUD",fallbackFactory=DeptClientServiceFallbackFactory.class)
						public interface DeptClientService{
							@RequestMapping(value = "/dept/get/{id}",method = RequestMethod.GET)
							public Dept get(@PathVariable("id") long id);
			            }
						
						@Component
						public class DeptClientServiceFallbackFactory implements FallbackFactory{
						
							@Override
							public Dept get(@PathVariable("id") long id){
								...
							}  
						}
						
						注意：在application.properties或YML文件的配置添加一行配置
						      feign: 
								hystrix: 
									enabled: true //开启   
			 
			 服务监控HystrixDashboard
			    使用：
				    概念：Hystrix还提供了准实时的监控（Hystrix Dashboard），Spring Cloud也提供了Hystrix Dashboard的整合，对监控内容转化成可视化界面。
					1,引用模块：POM.XML
						 <dependency>
							<groupId>org.springframework.cloud</groupId>
							<artifactId>spring-cloud-starter-hystrix</artifactId>
						</dependency>
						<dependency>
							<groupId>org.springframework.cloud</groupId>
							<artifactId>spring-boot-starter-actuator</artifactId>
						</dependency>
						
						在服务的监控一方添加如下配置
						<dependency>
							<groupId>org.springframework.cloud</groupId>
							<artifactId>spring-cloud-starter-hystrix-dashboard</artifactId>
						</dependency>
					2,配置参数：application.properties或YML文件的配置
					格式：
						server:
							port: 9901
		
					3,申明使用：1、程序main入口，添加@EnableHystrixDashboard注解，开启熔断监控的支持；
	
	路由网关：
			-Zuul：
			 概念：代理+路由+过滤三大功能，可以与Eureka整合并注册到注册中心里面
			 使用：
				1,引用模块：POM.XML
					<dependency>
						<groupId>org.springframework.cloud</groupId>
						<artifactId>spring-cloud-starter-eureka</artifactId>
					</dependency>
					<dependency>
						<groupId>org.springframework.cloud</groupId>
						<artifactId>spring-cloud-starter-zuul</artifactId>
					</dependency>
				2,配置参数：application.properties或YML文件的配置
				格式：
					zuul: 
					    prefix: /pre //前缀
						ignored-services: 服务名  //多个指定微服务以半角逗号分隔，所有可以用"*"通配符代替
						routes: 
							serverName.path: /serverName/**
							serverName.serviceId: 服务名 //给微服务起别名
							//或使用：serverName.url: http://${IP}:${PORT}/  //这种基于未使用服务注册中心的
						

				3,申明使用：1、程序main入口，添加@EnableZuulProxy注解，开启Zuul的支持；
				
	
	分布式配置中心：
				 -SpringCloud Config（与Git整合使用）
				 概念来源：分布式系统面临的---配置问题
				 概念：为微服务架构中的微服务提供集中化的外部配置支持，配置服务器为各个不同微服务应用的所有环境提供了一个中心化的外部配置
				    分类：服务端和客户端
						  服务端也称为分布式配置中心，它是一个独立的微服务应用，用来连接配置服务器并为客户端提供获取配置信息，加密/解密信息等访问接口
						  客户端则是通过指定的配置中心来管理应用资源，以及与业务相关的配置内容，并在启动的时候从配置中心获取和加载配置信息配置服务器默认采用git来存储配置信息，这样就有助于对环境配置进行版本管理，并且可以通过git客户端工具来方便的管理和访问配置内容。
					规则：1、不同环境不同配置，动态化的配置更新
						  2、运行期间动态调整配置，不再需要在每个服务部署的机器上编写配置文件，服务会向配置中心统一拉取配置自己的信息
						  3、当配置发生变动时，服务不需要重启即可感知到配置的变化并应用新的配置
						  4、将配置信息以REST接口的形式暴露
				 使用：
					 1、用自己的Github账户建一个统一配置中心仓库，并克隆到本地；
					 2、新建配置文件application.yml（保存格式必须为UTF-8）
					    格式参考示例：
						spring:
						  profiles:
							active:
							- dev
						---
						spring:
						  profiles: dev     #开发环境
						  application: 
							name: microservicecloud-config-dev
						---
						spring:
						  profiles: test   #测试环境
						  application: 
							name: microservicecloud-config-test
						#  请保存为UTF-8格式
					 3、push到git仓库
					 服务端配置使用：
						1,引用模块：POM.XML
							<dependency>
								<groupId>org.springframework.cloud</groupId>
								<artifactId>spring-cloud-config-server</artifactId>
							</dependency>
						2,配置参数：application.properties或YML文件的配置
									格式：	
									spring:
										application:
											name: microservicecloud-config
										cloud:
											config:
												server:
													git:
														uri: git@github.com***.git #GitHub上面的git仓库名字
						3,申明使用：1、程序main入口，添加@EnableConfigServer注解，开启Config的支持；		
						配置读取规则：
						  1、/{application}-{profile}.yml 如：http://config-3344.com:3344/application-dev.yml
						  2、/{application}/{profile}[/{label}] 如：http://config-3344.com:3344/application/dev/master
						  3、/{label}/{application}-{profile}.yml 如：http://config-3344.com:3344/master/application-dev.yml
					 客户端配置使用：
					      前提准备：
							本地仓库新建配置文件yml并提交到git仓库里，如：microservicecloud-config-client.yml
								参考示例：
									spring:
										profiles:
											active:
												- dev
									---
									server: 
										port: 8201 
									spring:
										profiles: dev
										application: 
											name: microservicecloud-config-client
									eureka: 
										client: 
											service-url: 
												defaultZone: http://eureka-dev.com:7001/eureka/   
									---
									server: 
										ort: 8202 
									spring:
										profiles: test
										application: 
											name: microservicecloud-config-client
									eureka: 
										client: 
											service-url: 
												defaultZone: http://eureka-test.com:7001/eureka/

						  1,引用模块：POM.XML
							<dependency>
								<groupId>org.springframework.cloud</groupId>
								<artifactId>spring-cloud-starter-config</artifactId>
							</dependency>
						  2,配置参数：bootstrap.yml配置文件的配置（系统级），而application.yml是用户级
									格式：	
									spring:
										cloud:
											config:
												name: microservicecloud-config-client #需要从github上读取的资源名称，注意没有yml后缀名
												profile: dev #本次访问的配置项
												label: master   
												uri: http://config-3344.com:3344  #本微服务启动后先去找3344号服务（链接Config服务端），通过SpringCloudConfig获取GitHub的服务地址
						  3,申明使用：
									测试：在控制层使用，如：@Value("${spring.application.name}")
															 private String applicationName;
						  
----------------------------------------------Spring Cloud Alibaba 技术栈的使用---------------------------------------------------------						  
					 
	基本介绍：Spring Cloud Alibaba 致力于提供微服务开发的一站式解决方案，依托 Spring Cloud Alibaba，只需要添加一些注解和少量配置，就可以将 Spring Cloud 应用接入阿里微服务解决方案，
			  通过阿里中间件来迅速搭建分布式应用系统。
    基本技术栈：
			  1、服务限流降级：默认支持 Servlet、Feign、RestTemplate、Dubbo 和 RocketMQ 限流降级功能的接入，可以在运行时通过控制台实时修改限流降级规则，还支持查看限流降级 Metrics 监控
			  2、服务注册与发现：适配 Spring Cloud 服务注册与发现标准，默认集成了 Ribbon 的支持
			  3、分布式配置管理：支持分布式系统中的外部化配置，配置更改时自动刷新
			  4、消息驱动能力：基于 Spring Cloud Stream 为微服务应用构建消息驱动能力
			  5、分布式事务：使用 @GlobalTransactional 注解， 高效并且对业务零侵入地解决分布式事务问题
			  6、阿里云对象存储：阿里云提供的海量、安全、低成本、高可靠的云存储服务。支持在任何应用、任何时间、任何地点存储和访问任意类型的数据
			  7、分布式任务调度：提供秒级、精准、高可靠、高可用的定时（基于 Cron 表达式）任务调度服务
			  8、阿里云短信服务：覆盖全球的短信服务，友好、高效、智能的互联化通讯能力，帮助企业迅速搭建客户触达通道
					  
	1、服务注册与发现
		-Nocas（= Spring Cloud Eureka + Spring Cloud Config）：
				简介：Spring Cloud Alibaba 项目中开发分布式应用微服务的子组件，致力于服务发现、配置和管理微服务，基于 DNS 和基于 RPC 的服务发现。
				关键特性：
					1、服务发现和服务健康监测；
					2、动态配置服务（通过 Nacos Server 和 spring-cloud-starter-alibaba-nacos-config 实现配置的动态变更）；
					3、动态DNS服务与服务及其元数据管理（通过 Nacos Server 和 spring-cloud-starter-alibaba-nacos-discovery 实现服务的注册与发现）
				使用-客户端（服务注册与发现）：
				1,引用模块：POM.XML
					<!--Nacos的服务注册与发现模块-->
					<dependency>
						<groupId>org.springframework.cloud</groupId>
						<artifactId>spring-cloud-starter-alibaba-nacos-discovery</artifactId>
					</dependency>
					<!--统一管理-->
					<dependencyManagement>
						<dependencies>
							<dependency>
								<groupId>org.springframework.cloud</groupId>
								<artifactId>spring-cloud-dependencies</artifactId>
								<version>Greenwich.RELEASE</version>
								<type>pom</type>
								<scope>import</scope>
							</dependency>
							<dependency>
								<groupId>org.springframework.cloud</groupId>
								<artifactId>spring-cloud-alibaba-dependencies</artifactId>
								<version>0.2.2.RELEASE</version>
								<type>pom</type>
								<scope>import</scope>
							</dependency>
						</dependencies>
				</dependencyManagement>
				2,配置参数：application.properties或YML文件的配置
				格式：
					 spring:
						  application:
							name: 程序名
						  cloud:
							nacos:
							  discovery:
								server-addr: 192.168.43.142:8848 # 服务IP与端口
									metadata: # 元数据管理
									  name1: healthy1 
									  name2: healthy2

				3,申明使用：程序main入口，添加@EnableDiscoveryClient注解，开启服务治理与发现
				
				使用-客户端（动态配置，相当于SpringCloud Config）：
				1,引用模块：POM.XML	
				<!--Nacos分布式配置模块-->
				<dependency>
					<groupId>org.springframework.cloud</groupId>
					  <artifactId>spring-cloud-starter-alibaba-nacos-config</artifactId>
				</dependency>
				<!--统一管理-->
				<dependencyManagement>
					<dependencies>
							<dependency>
								<groupId>org.springframework.cloud</groupId>
								<artifactId>spring-cloud-dependencies</artifactId>
								<version>Greenwich.RELEASE</version>
								<type>pom</type>
								<scope>import</scope>
							</dependency>
							<dependency>
								<groupId>org.springframework.cloud</groupId>
								<artifactId>spring-cloud-alibaba-dependencies</artifactId>
								<version>0.2.2.RELEASE</version>
								<type>pom</type>
								<scope>import</scope>
							</dependency>
					</dependencies>
				</dependencyManagement>

				2,配置参数：创建bootstrap.yml或创建bootstrap.properties文件
				格式：
					spring:
					  application:
						name: nacos-config-client # 统一配置中心客户端
					  cloud:
						nacos:
						  config:
							server-addr: 192.168.43.142:8848 # nacos服务端
							file-extension: yml
					server:
					  port: 9094 
				3、准备外部的统一配置文件：
							本地仓库新建配置文件yml（properties）并提交到git仓库里，如：nacos-config-client.properties或nacos-config-client.yml								
							# nacos默认加载的是nacos-config-client.properties文件，如果需要加载yml，需要在yml增加一行配置：file-extension: yml
				3,申明使用：程序main入口，添加@EnableDiscoveryClient注解，开启服务治理与发现	  
					  ACM （应用配置管理）配置加载规则说明：
						参考文档：https://www.alibabacloud.com/help/zh/doc-detail/94708.htm?spm=a2c63.p38356.b99.56.547b66ae7aDsVW
							# Nacos Spring Cloud 中，dataId 的完整格式如下：
							${prefix}-${spring.profile.active}.${file-extension}
							prefix 默认为 spring.application.name 的值，也可以通过配置项 spring.cloud.nacos.config.prefix来配置。
							spring.profile.active 即为当前环境对应的 profile，详情可以参考 Spring Boot文档。
							注意：当 spring.profile.active 为空时，对应的连接符 - 也将不存在，dataId 的拼接格式变成 ${prefix}.${file-extension}
							file-exetension 为配置内容的数据格式，可以通过配置项 spring.cloud.nacos.config.file-extension 来配置。目前只支持 properties 和 yaml 类型。
							# @RefreshScope 实现配置自动更新
							
							采用默认值的应用要加载的配置规则就是：
							Data ID=${spring.application.name}.properties，Group=DEFAULT_GROUP。
	2、服务调用：
		 -Feign：声明式服务调用，与Netflix Feign 功能相似
				使用-客户端：
				1,引用模块：POM.XML	
				<!--openfeign依赖-->
				<dependency>
					<groupId>org.springframework.cloud</groupId>
					  <artifactId>spring-cloud-starter-openfeign</artifactId>
				</dependency>
				<!--Nacos的服务注册与发现模块-->
				<dependency>
					<groupId>org.springframework.cloud</groupId>
					<artifactId>spring-cloud-starter-alibaba-nacos-discovery</artifactId>
				</dependency>
				<!--统一管理-->
				<dependencyManagement>
					<dependencies>
							<dependency>
								<groupId>org.springframework.cloud</groupId>
								<artifactId>spring-cloud-dependencies</artifactId>
								<version>Greenwich.RELEASE</version>
								<type>pom</type>
								<scope>import</scope>
							</dependency>
							<dependency>
								<groupId>org.springframework.cloud</groupId>
								<artifactId>spring-cloud-alibaba-dependencies</artifactId>
								<version>0.2.2.RELEASE</version>
								<type>pom</type>
								<scope>import</scope>
							</dependency>
					</dependencies>
				</dependencyManagement>

				2,配置参数：创建bootstrap.yml或创建bootstrap.properties文件
				格式：
					spring:
					  application:
						name: nacos-discovery-consumer-feign # 客户端名称
					  cloud:
						nacos:
						  config:
							server-addr: 192.168.43.142:8848 # nacos服务端
					server:
					  port: 9091
				3、申明使用：程序main入口，添加@EnableFeignClients注解，开启服务调用
						具体使用：定义一个接口
						@FeignClient("nacos-discovery-provider") //调用的服务名称
						public interface TestService {
							@GetMapping("/m1")
							String m1(@RequestParam(name = "name") String name);
						}

	3、其他：
		 -Webflux：替换了旧的Servlet线程模型。
		 - Spring Cloud Gateway ：网关配置，目标是替代Netflix ZUUL，其不仅提供统一的路由方式，并且基于Filter链的方式提供了网关基本的功能，例如：安全，监控/埋点，和限流等。
				使用-客户端：
				1,引用模块：POM.XML	
				<!--gateway依赖-->
				<dependency>
					<groupId>org.springframework.cloud</groupId>
					  <artifactId>spring-cloud-starter-gateway</artifactId>
				</dependency>
				<!--Nacos的服务注册与发现模块-->
				<dependency>
					<groupId>org.springframework.cloud</groupId>
					<artifactId>spring-cloud-starter-alibaba-nacos-discovery</artifactId>
				</dependency>
				<!--统一管理-->
				<dependencyManagement>
					<dependencies>
							<dependency>
								<groupId>org.springframework.cloud</groupId>
								<artifactId>spring-cloud-dependencies</artifactId>
								<version>Greenwich.RELEASE</version>
								<type>pom</type>
								<scope>import</scope>
							</dependency>
							<dependency>
								<groupId>org.springframework.cloud</groupId>
								<artifactId>spring-cloud-alibaba-dependencies</artifactId>
								<version>0.2.2.RELEASE</version>
								<type>pom</type>
								<scope>import</scope>
							</dependency>
					</dependencies>
				</dependencyManagement>

				2,配置参数：创建bootstrap.yml或创建bootstrap.properties文件
				格式：
					spring:
						  application:
							name: nacos-discovery-gateway-server
						  cloud:
							nacos:
							  discovery:
								server-addr: 192.168.43.142:8848
								metadata:
								  name: healthy
							gateway:
							  routes:
								- id: nacos-discovery-provider
								  uri: lb://nacos-discovery-provider
								  predicates:
									- Path=/provider/**
								  filters:
									- StripPrefix=1
							  
							  discovery:
								locator:
								  enabled: true  #表明gateway开启服务注册和发现的功能，并且spring cloud gateway自动根据服务发现为每一个服务创建了一个router，这个router将以服务名开头的请求路径转发到对应的服务。
								  lowerCaseServiceId: true   #是将请求路径上的服务名配置为小写（因为服务注册的时候，向注册中心注册时将服务名转成大写的了），比如以/service-hi/*的请求路径被路由转发到服务名为service-hi的服务上。
								  filters:
									- StripPrefix=1
									
						server:
						  port: 9093

				3、申明使用：程序main入口，添加@EnableDiscoveryClient注解，开启服务调用
						使用示例：http://localhost:9093/provider/hello?name=zhansan
		 -Sentinel：
				介绍：随着微服务的流行，服务和服务之间的稳定性变得越来越重要。Sentinel 作为流量防卫组件，以流量为切入点，从流量控制、熔断降级、系统负载保护等多个维度保护服务的稳定性。
				特征：
					 1、丰富的应用场景：Sentinel 承接了阿里巴巴近 10 年的双十一大促流量的核心场景，例如秒杀（即突发流量控制在系统容量可以承受的范围）、消息削峰填谷、集群流量控制、实时熔断下游不可用应用等
					 2、完备的实时监控
					 3、广泛的开源生态：Sentinel 提供开箱即用的与其它开源框架/库的整合模块，例如与 Spring Cloud、Dubbo、gRPC 的整合
					 4、完善的 SPI（串行外设接口） 扩展点：Sentinel 提供简单易用、完善的 SPI 扩展接口。可以通过实现扩展接口来快速地定制逻辑。例如定制规则管理、适配动态数据源等。
				组成：
					 核心库（Java 客户端）
					 控制台（Dashboard）		
					 使用：		
					 	 1、部署Sentinel Dashboard	
							下载地址：https://github.com/alibaba/Sentinel/releases
							启动(默认端口：8080)：
							java -jar sentinel-dashboard-1.6.0.jar
							java -jar -Dserver.port=8888 sentinel-dashboard-1.6.0.jar
							默认用户名密码：sentinel
							
						 2、核心库的配置使用：
							1,引用模块：POM.XML	
							<!--gateway依赖-->
							<dependency>
								<groupId>org.springframework.cloud</groupId>
								  <artifactId>spring-cloud-starter-alibaba-sentinel</artifactId>
							</dependency>
							<!--Nacos存储扩展-->
							<dependency>
								<groupId>org.springframework.cloud</groupId>
								<artifactId>sentinel-datasource-nacos</artifactId>
							</dependency>
							<!--统一管理-->
							<dependencyManagement>
								<dependencies>
										<dependency>
											<groupId>org.springframework.cloud</groupId>
											<artifactId>spring-cloud-dependencies</artifactId>
											<version>Greenwich.RELEASE</version>
											<type>pom</type>
											<scope>import</scope>
										</dependency>
										<dependency>
											<groupId>org.springframework.cloud</groupId>
											<artifactId>spring-cloud-alibaba-dependencies</artifactId>
											<version>0.2.2.RELEASE</version>
											<type>pom</type>
											<scope>import</scope>
										</dependency>
								</dependencies>
							</dependencyManagement>

							2,配置参数：创建bootstrap.yml或创建bootstrap.properties文件
							格式：
								spring:
								  application:
									name: nacos-discovery-sentinel
								  cloud:
									sentinel:
									  transport:
										dashboard: localhost:8888 #Sentinel Dashboard服务端地址 
									  datasource:
										ds:
										  nacos:
											server-addr: localhost:8848 #nacos服务地址
											dataId: ${spring.application.name}
											groupId: DEFAULT_GROUP
											ruleType: flow
								server:
								  port: 9095

							3、申明使用：访问sentinel服务列表并限流；通过nacos配置流控规则；
							   # 注意
								 Sentinel控制台中修改规则：仅存在于服务的内存中，不会修改Nacos中的配置值，重启后恢复原来的值。
								 Nacos控制台中修改规则：服务的内存中规则会更新，Nacos中持久化规则也会更新，重启后依然保持。
							4、优点:
									1、sentinel配置变动后通知非常的迅速, 秒杀springcloud原来的config几条街,
									   毕竟原来的config是基于git, 不提供可视化界面, 动态变更还需要依赖bus来通过所有的客户端变化
									2、与hystrix相比，sentinel更加的轻量级,并且支持动态的限流调整,更加友好的界面ui
									
----------------------------------------------Spring boot 技术的使用---------------------------------------------------------	

	一、基本概念：
			特点：开箱即用，自动配置
			配置文件：YAML 的基本使用-支持文档块
			配置文件值的注入：
				方式一：@ConfigurationProperties
					格式：
				javaBean 
					@Component
					@ConfigurationProperties(prefix = "person")
					//@Validated
					public class Person {
						//@Value("${person.last-name}")
						private String lastName;
						//@Value("#{11*2}")
						private Integer age;
						private Boolean boss;
						private Date birth;

						private Map<String,Object> maps;
						private List<Object> lists;
						private Dog dog;
						...
					}
				配置文件：
					person:
						lastName: hello
						age: 18
						boss: false
						birth: 2017/12/12
						maps: {k1: v1,k2: 12}
						lists:
						  - lisi
						  - zhaoliu
						dog:
						  name: 小狗
						  age: 12
						  
				方式二：@Value
				区别：
					|            	| @ConfigurationProperties | @Value 	 |
					| 功能         	| 批量注入配置文件中的属性 | 一个个指定  |
					| 松散绑定（松散语法）| 支持               | 不支持    	 |
					| SpEL       	| 不支持                      | 支持     |
					| JSR303数据校验| 支持                       | 不支持    |
					| 复杂类型封装  | 支持                       | 不支持    |
			配置文件加载：@PropertySource
				格式：
					@PropertySource(value = {"classpath:person.properties"})
					@Component
					@ConfigurationProperties(prefix = "person")
					public class Person {
						//@Value("#{11*2}")
						private Integer age;
						//@Value("true")
						private Boolean boss;

					```
					}
			配置文件读取：@ImportResource
				格式：
					java文件
						@ImportResource(locations = {"classpath:beans.xml"})
					xml文件
					<?xml version="1.0" encoding="UTF-8"?>
					<beans xmlns="http://www.springframework.org/schema/beans"
						   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
						   xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">


						<bean id="helloService" class="com.atguigu.springboot.service.HelloService"></bean>
					</beans>	
			配置文件添加：	
				推荐使用全注解的方式
				1、配置类@Configuration------>Spring配置文件
				2、使用@Bean给容器中添加组件

				```java
				@Configuration
				public class MyAppConfig {

					//将方法的返回值添加到容器中；容器中这个组件默认的id就是方法名
					@Bean
					public HelloService helloService(){
						System.out.println("配置类@Bean给容器中添加组件了...");
						return new HelloService();
					}
				}
			配置文件占位符:
				如：*.properties 配置文件中
					person.last-name=张三${random.uuid}
					person.dog.name=${person.hello:hello}_dog
					
			配置文件Profile:		
				激活指定profile的方式：
				1、配置文件中指定  spring.profiles.active=dev	
				2、命令行方式 java -jar **-0.0.1-SNAPSHOT.jar --spring.profiles.active=dev；
				3、虚拟机参数 -Dspring.profiles.active=dev
			配置文件加载位置：
				springboot 启动会扫描以下位置的application.properties或者application.yml文件作为Spring boot的默认配置文件
				–file:./config/
				–file:./
				–classpath:/config/
				–classpath:/
				优先级由高到底，高优先级的配置会覆盖低优先级的配置；
				SpringBoot会从这四个位置全部加载主配置文件；互补配置；
				-指定加载位置：java -jar **-0.0.1-SNAPSHOT.jar --spring.config.location=G:/application.properties
			外部配置加载顺序：
				SpringBoot也可以从以下位置加载配置； 优先级从高到低；高优先级的配置覆盖低优先级的配置，所有的配置会形成互补配置
				1.命令行参数
					java -jar **-02-0.0.1-SNAPSHOT.jar --server.port=8087  --server.context-path=/abc
				多个配置用空格分开； --配置项=值
				2.来自java:comp/env的JNDI属性
				3.Java系统属性（System.getProperties()）
				4.操作系统环境变量
				5.RandomValuePropertySource配置的random.*属性值
				6.由jar包外向jar包内进行寻找，优先加载带profile
					jar包外部的application-{profile}.properties或application.yml(带spring.profile)配置文件
					jar包内部的application-{profile}.properties或application.yml(带spring.profile)配置文件
				10.@Configuration注解类上的@PropertySource
				11.通过SpringApplication.setDefaultProperties指定的默认属性
			自动配置原理：
				xxxxAutoConfigurartion：自动配置类；
				xxxxProperties:封装配置文件中相关属性；
			检测自动配置类是否生效：debug=true
	二、日志框架：
			默认：springBoot底层也是使用slf4j+logback的方式进行日志记录
			| 日志门面  （日志的抽象层）               | 日志实现                                     
			| ---------------------------------------- | ---------------------------------------- |
			| JCL（Jakarta  Commons Logging）          | Log4j  JUL（java.util.logging）  Log4j2  Logback	
			| SLF4j（Simple  Logging Facade for Java） jboss-logging|	
			系统统一日志（slf4j）输出：
				1、将系统中其他日志框架先排除出去
				2、用中间包来替换原有的日志框架
				3、我们导入slf4j其他的实现
	
			日志级别：
				由低到高   trace<debug<info<warn<error
			springBoot修改默认日志配置：
				1、指定级别：logging.level.XX包名=trace
				2、logging.path=  #不指定路径在当前项目下生成springboot.log日志
				   logging.path=/spring/log #在当前磁盘的根路径下创建spring文件夹和里面的log文件夹；使用 spring.log 作为默认文件
				3、logging.file=G:/springboot.log
				输出格式：
				4、logging.pattern.console=%d{yyyy-MM-dd} [%thread] %-5level %logger{50} - %msg%n #控制台
				5、logging.pattern.file=%d{yyyy-MM-dd} [%thread] %-5level %logger{50} - %msg%n #指定文件中
			指定具体的日志实现配置：类路径下放上每个日志框架自己的配置文件即可
				如：logback.xml：直接就被日志框架识别了；
					logback-spring.xml：日志框架就不直接加载日志的配置项，由SpringBoot解析日志配置，可以使用SpringBoot的高级Profile功能
					
					xml文件：
					<appender name="stdout" class="ch.qos.logback.core.ConsoleAppender">
							<!--
							日志输出格式：
								%d表示日期时间，
								%thread表示线程名，
								%-5level：级别从左显示5个字符宽度
								%logger{50} 表示logger名字最长50个字符，否则按照句点分割。 
								%msg：日志消息，
								%n是换行符
							-->
							<layout class="ch.qos.logback.classic.PatternLayout">
								<springProfile name="dev">
									<pattern>%d{yyyy-MM-dd HH:mm:ss.SSS} ----> [%thread] ---> %-5level %logger{50} - %msg%n</pattern>
								</springProfile>
								<springProfile name="!dev">
									<pattern>%d{yyyy-MM-dd HH:mm:ss.SSS} $$$$$$ [%thread] $$$$$$ %-5level %logger{50} - %msg%n</pattern>
								</springProfile>
							</layout>
						</appender>	
	二、Web模块：				
			静态资源映射：
				1、（以Jar包的方式引入静态资源）/webjars/**，都去 classpath:/META-INF/resources/webjars/找资源；如：localhost:8080/webjars/jquery/3.3.1/jquery.js
					引入如：
						<dependency>
							<groupId>org.webjars</groupId>
							<artifactId>jquery</artifactId>
							<version>3.3.1</version>
						</dependency>
				2、	/**，访问任何资源
					静态资源的文件夹：
					"classpath:/META-INF/resources/", 
					"classpath:/resources/",
					"classpath:/static/", 
					"classpath:/public/" 
					"/"：当前项目的根路径	
				3、	欢迎页：静态资源文件夹下的所有index.html页面；被"/**"映射；
				4、 所有的 **/favicon.ico  都是在静态资源文件下找	
			模板引擎：JSP、Velocity、Freemarker、Thymeleaf，SpringBoot推荐的Thymeleaf
				Thymeleaf使用：
					1、引入：POM.xml
						<dependency>
							<groupId>org.springframework.boot</groupId>
							<artifactId>spring-boot-starter-thymeleaf</artifactId>
							2.1.6
						</dependency>
				<properties>
						<thymeleaf.version>3.0.9.RELEASE</thymeleaf.version>
						<!-- 布局功能的支持程序  thymeleaf3主程序  layout2以上版本 -->
						<!-- thymeleaf2   layout1-->
						<thymeleaf-layout-dialect.version>2.2.2</thymeleaf-layout-dialect.version>
				  </properties>
					2、使用：把HTML页面放在classpath:/templates/，thymeleaf就能自动渲染；
						页面引入：<html lang="en" xmlns:th="http://www.thymeleaf.org">
						页面使用标签：
							语法规则：
								包含：th:insert th:replace th:include
								遍历：th:each
								条件判断：th:if th:unless th:switch th:case
								申明变量：th:object th:with
								属性修改：th:attr th:attrprepend th:attrapend
								属性值修改: th:value th:src th:href
								标签体内容：th:text（转义） th:utext（不转义）
								申明片段：th:fragment 
								移除：th:remove
							表达式：
								${...}：获取变量值，符合OGNL（Object Graphic Navigation Language(对象图导航语言)）标准；
									1）、获取对象的属性、调用方法
									2）、使用内置的基本对象：
										#ctx : the context object.
										#vars: the context variables.
										#locale : the context locale.
										#request : (only in Web Contexts) the HttpServletRequest object.
										#response : (only in Web Contexts) the HttpServletResponse object.
										#session : (only in Web Contexts) the HttpSession object.
										#servletContext : (only in Web Contexts) the ServletContext object.
									3）、内置的一些工具对象：
									#execInfo : information about the template being processed.
									#messages : methods for obtaining externalized messages inside variables expressions, in the same way as they would be obtained using #{…} syntax.
									#uris : methods for escaping parts of URLs/URIs
									#conversions : methods for executing the configured conversion service (if any).
									#dates : methods for java.util.Date objects: formatting, component extraction, etc.
									#calendars : analogous to #dates , but for java.util.Calendar objects.
									#numbers : methods for formatting numeric objects.
									#strings : methods for String objects: contains, startsWith, prepending/appending, etc.
									#objects : methods for objects in general.
									#bools : methods for boolean evaluation.
									#arrays : methods for arrays.
									#lists : methods for lists.
									#sets : methods for sets.
									#maps : methods for maps.
									#aggregates : methods for creating aggregates on arrays or collections.
									#ids : methods for dealing with id attributes that might be repeated (for example, as a result of an iteration).
										Selection Variable Expressions: *{...}：选择表达式：和${}在功能上是一样；补充：配合 th:object="${session.user}：	
									    <div th:object="${session.user}">
										<p>Name: <span th:text="*{firstName}">Sebastian</span>.</p>
										<p>Surname: <span th:text="*{lastName}">Pepper</span>.</p>
										<p>Nationality: <span th:text="*{nationality}">Saturn</span>.</p>
										</div>
										Message Expressions: #{...}：获取国际化内容
										Link URL Expressions: @{...}：定义URL；@{/order/process(execId=${execId},execType='FAST')}		
										Fragment Expressions: ~{...}：片段引用表达式;<div th:insert="~{commons :: main}">...</div>				
									Literals（字面量）
										  Text literals: 'one text' , 'Another one!' ,…
										  Number literals: 0 , 34 , 3.0 , 12.3 ,…
										  Boolean literals: true , false
										  Null literal: null
										  Literal tokens: one , sometext , main ,…
									Text operations:（文本操作）
										String concatenation: +
										Literal substitutions: |The name is ${name}|
									Arithmetic operations:（数学运算）
										Binary operators: + , - , * , / , %
										Minus sign (unary operator): -
									Boolean operations:（布尔运算）
										Binary operators: and , or
										Boolean negation (unary operator): ! , not
									Comparisons and equality:（比较运算）
										Comparators: > , < , >= , <= ( gt , lt , ge , le )
										Equality operators: == , != ( eq , ne )
									Conditional operators:条件运算（三元运算符）
										If-then: (if) ? (then)
										If-then-else: (if) ? (then) : (else)
										Default: (value) ?: (defaultvalue)
									Special tokens:
										No-Operation: _ 
				禁用Thymeleaf缓存：spring.thymeleaf.cache=false 
			SpringMVC自动配置：
					SpringBoot对SpringMVC的默认配置，WebMvcAutoConfiguration
					做的主要几件事：
							1、自动配置了ViewResolver（视图解析器）
							2、支持静态资源文件夹路径,webjars
							3、支持静态首页访问
							4、支持favicon.ico系统图标
							5、自动注册了Converte转换器Formatter格式化器
			扩展SpringMVC：
					Bean.XML 参考：
						 <mvc:view-controller path="/hello" view-name="success"/>
							<mvc:interceptors>
								<mvc:interceptor>
									<mvc:mapping path="/hello"/>
									<bean></bean>
								</mvc:interceptor>
							</mvc:interceptors>
					编写一个配置类（@Configuration），是WebMvcConfigurerAdapter类型；不能标注@EnableWebMvc（会全面接管），既保留了所有的自动配置，也能用自定义扩展的配置；
					如：@Configuration
						//@EnableWebMvc
						public class MyMvcConfig extends WebMvcConfigurerAdapter {
							@Override
							public void addViewControllers(ViewControllerRegistry registry) {
							   // super.addViewControllers(registry);
								registry.addViewController("/atguigu").setViewName("success");
							}
						}
			全面接管SpringMVC：需要在自定义的配置类中添加@EnableWebMvc即可		
					原理：底层有@ConditionalOnMissingBean(WebMvcConfigurationSupport.class)
						WebMvcConfigurationSupport只是保留SpringMVC最基本的功能
			国际化：
				使用步骤：	1）、编写国际化配置文件
							2）、使用ResourceBundleMessageSource管理国际化资源文件
							3）、在页面使用fmt:message取出国际化内容
				结论：根据浏览器语言设置的信息切换了国际化
				原理：国际化Locale（区域信息对象）；LocaleResolver（获取区域信息对象）；	
						@Bean
						@ConditionalOnMissingBean
						@ConditionalOnProperty(prefix = "spring.mvc", name = "locale")
						public LocaleResolver localeResolver() {
							if (this.mvcProperties
									.getLocaleResolver() == WebMvcProperties.LocaleResolver.FIXED) {
								return new FixedLocaleResolver(this.mvcProperties.getLocale());
							}
							//默认的就是根据请求头带来的区域信息获取Locale进行国际化
							AcceptHeaderLocaleResolver localeResolver = new AcceptHeaderLocaleResolver();
							localeResolver.setDefaultLocale(this.mvcProperties.getLocale());
							return localeResolver;
						}
				点击链接切换国际化: 自定义个类实现LocaleResolver重写resolveLocale方法（对请求参数进行处理）返回区域对象，并注入容器里
						参考：
						public class MyLocaleResolver implements LocaleResolver {
							@Override
							public Locale resolveLocale(HttpServletRequest request) {
								String l = request.getParameter("l");
								Locale locale = Locale.getDefault();
								if(!StringUtils.isEmpty(l)){
									String[] split = l.split("_");
									locale = new Locale(split[0],split[1]);
								}
								return locale;
							}

							@Override
							public void setLocale(HttpServletRequest request, HttpServletResponse response, Locale locale) {

							}
						}
						 @Bean
							public LocaleResolver localeResolver(){
								return new MyLocaleResolver();
							}
						}
			Rest风格:
					URI：/资源名称/资源标识（主表Id），以HTTP请求方式（GET、POST、PUT、DELETE）区分对资源CRUD操作；
					注意要点：如果添加/修改页面（二合一版），页面创建一个input项，name="_method";值就是我们指定的请求方式，原理：SpringMVC中配置HiddenHttpMethodFilter;（SpringBoot自动配置好的）
			模板抽取：
					1、抽取公共片段
					<div th:fragment="copy">
						&copy; 2011 The Good Thymes Virtual Grocery
					</div>
					2、引入公共片段
					<div th:insert="~{footer :: copy}"></div> // ~{templatename::selector}：模板名::选择器;~{templatename::fragmentname}:模板名::片段名									
					3、默认效果：
					如果使用th:insert等属性进行引入，可以不用写~{}：行内写法可以加上：[[~{}]];[(~{})]；
					三种引入公共片段的th属性：
					th:insert：将公共片段整个插入到声明引入的元素中
					th:replace：将声明引入的元素替换为公共片段
					th:include：将被引入的片段的内容包含进这个标签中
					如：
						<footer th:fragment="copy">
							&copy; 2011 The Good Thymes Virtual Grocery
						</footer>
						引入方式
						<div th:insert="footer :: copy"></div>
						<div th:replace="footer :: copy"></div>
						<div th:include="footer :: copy"></div>
						效果
						<div>
							<footer>
							&copy; 2011 The Good Thymes Virtual Grocery
							</footer>
						</div>
						
						<footer>
							&copy; 2011 The Good Thymes Virtual Grocery
						</footer>
						
						<div>
							&copy; 2011 The Good Thymes Virtual Grocery
						</div>
			错误处理：
				效果：1、浏览器：返回一个默认的错误页面；2、其他客户端，默认响应一个json数据
				原理：ErrorMvcAutoConfiguration；错误处理的自动配置类
					一但系统出现4xx或者5xx之类的错误；
					1、ErrorPageCustomizer就会生效（定制错误的响应规则）；就会来到/error请求；
					2、就会来到BasicErrorController处理（针对浏览器与其他客户端分别处理）；
					3、浏览器：调用DefaultErrorViewResolver类，交给它处理（有模板引擎，按模板引擎处理；没有默认处理error/状态码.html）
					4、其他客户端：调用getErrorAttributes方法，返回封装的Json数据；
				定制处理处理：
					基本规则：1、有模板引擎：模板引擎文件夹里面的error文件夹下找状态码.HTML（支持精准匹配与模糊匹配如：5xx.html）
								包含信息：
									timestamp：时间戳
					​				status：状态码
					​				error：错误提示
					​				exception：异常对象
					​				message：异常消息
					​				errors：JSR303数据校验的错误
							  2、没有模板引擎：静态资源文件夹
							  3、默认：来到SpringBoot默认的错误提示页面
				定制错误的JSON返回数据（思路）：
					自定义异常处理&返回定制json数据	
					转发到/error进行自适应响应效果处理
					将定制数据携带出去
			配置嵌入式Servlet容器：
				结论：SpringBoot默认使用Tomcat作为嵌入式的Servlet容器
				定制：
					1、ServerProperties方式，在配置文件中配置
					//通用的Servlet容器设置，server.xxx
					  如：server.port=8081 server.context-path=/crud
					//Tomcat的设置，server.tomcat.xxx
					  如：server.tomcat.uri-encoding=UTF-8
					2、EmbeddedServletContainerCustomizer方式，在java代码中配置
					  如：
						@Bean  //一定要将这个定制器加入到容器中
						public EmbeddedServletContainerCustomizer embeddedServletContainerCustomizer(){
							return new EmbeddedServletContainerCustomizer() {
								//定制嵌入式的Servlet容器相关的规则
								@Override
								public void customize(ConfigurableEmbeddedServletContainer container) {
									container.setPort(8083);
								}
							};
						}
				注册Servlet三大组件：Servlet、Filter、Listener 替代在web.xml中的配置	
				自动的注册前端控制器：DispatcherServletAutoConfiguration	
				修改配置：server.servletPath修改默认拦截的请求路径		
				修改为其他的servlet容器：
					支持Tomcat Undertow Jetty
					如：
						<!-- 引入web模块 -->
						<dependency>
						   <groupId>org.springframework.boot</groupId>
						   <artifactId>spring-boot-starter-web</artifactId>
						   <exclusions>
							  <exclusion>
								 <artifactId>spring-boot-starter-tomcat</artifactId>
								 <groupId>org.springframework.boot</groupId>
							  </exclusion>
						   </exclusions>
						</dependency>
						<!--引入其他的Servlet容器-->
						<dependency>
						   <artifactId>spring-boot-starter-undertow</artifactId>
						   <groupId>org.springframework.boot</groupId>
						</dependency>
				各自区别：
					Tomcat 是Apache下的一款重量级的基于HTTP协议的服务器
					Undertow 基于NIO（非阻塞式输入输出，相对于BIO（Blocking I/O，阻塞IO））实现的高并发轻量级的服务器 支持JSP
					Jetty 基于NIO（非阻塞式输入输出，相对于BIO（Blocking I/O，阻塞IO））实现的高并发轻量级的服务器 支持长链接
					Netty是一款基于NIO（Nonblocking I/O，非阻塞IO）开发的网络通信框架，客户端服务器框架
				嵌入式Servlet容器自动配置原理：EmbeddedServletContainerAutoConfiguration
					步骤：
					1）、SpringBoot根据导入的依赖情况，给容器中添加相应的EmbeddedServletContainerFactory
					2）、容器中某个组件要创建对象就会惊动后置处理器；EmbeddedServletContainerCustomizerBeanPostProcessor；只要是嵌入式的Servlet容器工厂，后置处理器就工作；
					3）、后置处理器，从容器中获取所有的EmbeddedServletContainerCustomizer，调用定制器的定制方法
				启动原理（步骤）：
					springBoot应用启动运行run方法->refreshContext(context);SpringBoot创建并刷新IOC容器(如果是web应用创建AnnotationConfigEmbeddedWebApplicationContext，否则：AnnotationConfigApplicationContext)
					->refresh(context)刷新IOC容器->onRefresh()->webIoc容器会创建嵌入式的Servlet容器；createEmbeddedServletContainer()
					->获取嵌入式的Servlet容器工厂EmbeddedServletContainerFactory->后置处理器EmbeddedServletContainerCustomizerBeanPostProcessor工作->
					->定制器来先定制Servlet容器的相关配置->嵌入式的Servlet容器创建对象并启动Servlet容器
				结论：IOC容器启动创建嵌入式的Servlet容器并启动
			外置的Servlet容器：
				嵌入式Servlet容器将应用打成可执行的jar，优点：简单、便携；缺点：默认不支持JSP、优化定制比较复杂；
				外置的Servlet容器一般指外面安装Tomcat---应用war包的方式打包；
				使用步骤：
					1）、必须创建一个war项目；（利用idea创建好目录结构）
					2）、将嵌入式的Tomcat指定为provided；
					<dependency>
					   <groupId>org.springframework.boot</groupId>
					   <artifactId>spring-boot-starter-tomcat</artifactId>
					   <scope>provided</scope>
					</dependency>
					3）、必须编写一个SpringBootServletInitializer的子类，并调用configure方法
					public class ServletInitializer extends SpringBootServletInitializer {
					   @Override
					   protected SpringApplicationBuilder configure(SpringApplicationBuilder application) {
						   //传入SpringBoot应用的主程序
						  return application.sources(SpringBoot04WebJspApplication.class);
					   }

					}
					4）、启动服务器就可以使用；
				原理：
					jar包：执行SpringBoot主类的main方法，启动ioc容器，创建嵌入式的Servlet容器；
					war包：启动服务器，服务器启动SpringBoot应用【SpringBootServletInitializer】，启动ioc容器；
	三、springboot与docker：
			详情参考docker技术；
			Docker是一个开源的应用容器引擎；是一个轻量级容器技术；
				
	四、springboot与数据访问：
			链接JDBC:
				1、导入依赖：
					<dependency>
						<groupId>org.springframework.boot</groupId>
						<artifactId>spring-boot-starter-jdbc</artifactId>
					</dependency>
					<dependency>
						<groupId>mysql</groupId>
						<artifactId>mysql-connector-java</artifactId>
						<scope>runtime</scope>
					</dependency>
				2、添加配置参数：
					spring:
					  datasource:
						username: root
						password: 123456
						url: jdbc:mysql://192.168.15.22:3306/jdbc
						driver-class-name: com.mysql.jdbc.Driver
						schema:
						- classpath:department.sql #指定位置
				3、申明使用
			相关结论：
				默认是用org.apache.tomcat.jdbc.pool.DataSource作为数据源，数据源的相关配置都在DataSourceProperties里面
				DataSourceInitializer：ApplicationListener 可以运行建表与运行数据插入（runSchemaScripts();运行建表语句；runDataScripts();运行插入数据的sql语句；）
				默认只需要将文件重命名为：schema-*.sql、data-*.sql 默认规则：schema.sql，schema-all.sql；
					可以使用   
					schema:
						- classpath:department.sql #指定位置
				自动配置了JdbcTemplate操作数据库；
			整合：Druid数据源，参考：https://blog.csdn.net/weixin_41404773/article/details/82592719
				1、导入依赖：
					<dependency>
						<groupId>org.springframework.boot</groupId>
						<artifactId>spring-boot-starter-jdbc</artifactId>
					</dependency>
					<!--引入druid-->
					<!-- https://mvnrepository.com/artifact/com.alibaba/druid -->
					<dependency>
						<groupId>com.alibaba</groupId>
						<artifactId>druid</artifactId>
						<version>1.1.8</version>
					</dependency>
				2、添加配置参数：在aplication.yml或aplication.properties
					spring:
					  datasource:
						username: root
						password: 123456
						url: jdbc:mysql://localhost:3306/testwkn
						driver-class-name: com.mysql.jdbc.Driver
						type: com.alibaba.druid.pool.DruidDataSource
					 
						initialSize: 5
						minIdle: 5
						maxActive: 20
						maxWait: 60000
						timeBetweenEvictionRunsMillis: 60000
						minEvictableIdleTimeMillis: 300000
						validationQuery: SELECT 1 FROM DUAL
						testWhileIdle: true
						testOnBorrow: false
						testOnReturn: false
						poolPreparedStatements: true
					#   配置监控统计拦截的filters，去掉后监控界面sql无法统计，'wall'用于防火墙
						filters: stat,wall,log4j
						maxPoolPreparedStatementPerConnectionSize: 20
						useGlobalDataSourceStat: true
						connectionProperties: druid.stat.mergeSql=true;druid.stat.slowSqlMillis=500
					#    schema:
					#      - classpath:department.sql

				3、	读取配置
					@Configuration
					public class DruidConfig {
					 
						@ConfigurationProperties(prefix = "spring.datasource")
						@Bean
						public DataSource druid(){
						   return  new DruidDataSource();
						}
					 
						//配置Druid的监控
						//1、配置一个管理后台的Servlet
						@Bean
						public ServletRegistrationBean statViewServlet(){
							ServletRegistrationBean bean = new ServletRegistrationBean(new StatViewServlet(), "/druid/*");
							Map<String,String> initParams = new HashMap<>();
					 
							initParams.put("loginUsername","admin");
							initParams.put("loginPassword","123456");
							initParams.put("allow","");//默认就是允许所有访问
							initParams.put("deny","192.168.15.21");
					 
							bean.setInitParameters(initParams);
							return bean;
						}
					 
					 
						//2、配置一个web监控的filter
						@Bean
						public FilterRegistrationBean webStatFilter(){
							FilterRegistrationBean bean = new FilterRegistrationBean();
							bean.setFilter(new WebStatFilter());
					 
							Map<String,String> initParams = new HashMap<>();
							initParams.put("exclusions","*.js,*.css,/druid/*");
					 
							bean.setInitParameters(initParams);
					 
							bean.setUrlPatterns(Arrays.asList("/*"));
					 
							return  bean;
						}
					}
			整合Mybatis:
				1、导入依赖：
					<dependency>
						<groupId>org.mybatis.spring.boot</groupId>
						<artifactId>mybatis-spring-boot-starter</artifactId>
						<version>1.3.1</version>
					</dependency>
				2、申明使用：
					1、注解版-写好提供的接口，程序的入口添加@MapperScan
					2、配置文件版
						mybatis:
						  config-location: classpath:mybatis/mybatis-config.xml 指定全局配置文件的位置
						  mapper-locations: classpath:mybatis/mapper/*.xml  指定sql映射文件的位置
			整合Jpa（Java Persistence API，通过注解或者XML描述【对象-关系表】之间的映射关系，并将实体对象持久化到数据库中）:
				Jpa特点：ORM映射元数据：JPA支持XML和注解两种元数据的形式，元数据描述对象和表之间的映射关系，框架据此将实体对象持久化到数据库表中；如：@Entity、@Table、@Column、@Transient等注解
						 JPA 提供API：用来操作实体对象，执行CRUD操作，框架在后台替我们完成所有的事情，开发者从繁琐的JDBC和SQL代码中解脱出来；如：entityManager.merge(T t)；
						 JPQL查询语言：通过面向对象而非面向数据库的查询语言查询数据，避免程序的SQL语句紧密耦合；如：from Student s where s.name = ?
						 JPA仅仅是一种规范，也就是说JPA仅仅定义了一些接口，而接口是需要实现才能工作的。Hibernate就是实现了JPA接口的ORM框架。
				spirng data jpa：
					是spring提供的一套简化JPA开发的框架，按照约定好的【方法命名规则】写dao层接口，就可以在不写接口实现的情况下，实现对数据库的访问和操作。同时提供了很多除了CRUD之外的功能，如分页、排序、复杂查询等等。		 
					Spring Data JPA 可以理解为 JPA 规范的再次封装抽象，底层还是使用了 Hibernate 的 JPA 技术实现。
					接口约定命名规则：如：findByNameAndPwd xxAndxx
					使用：
						1、导入依赖：
							<dependency>
								<groupId>org.springframework.boot/groupId>
								<artifactId>spring-boot-starter-data-jpa</artifactId>
							</dependency>
						2、添加配置：
							spring:  
								jpa:
									hibernate:
								# 更新或者创建数据表结构
										ddl-auto: update
								#控制台显示SQL
									show-sql: true
									database: mysql
						3、使用：
							编写一个实体类（bean）和数据表进行映射，并且配置好映射关系；
							编写一个Dao接口来操作实体类对应的数据表（Repository）；
							如：
								//使用JPA注解配置映射关系
								@Entity //告诉JPA这是一个实体类（和数据表映射的类）
								@Table(name = "tbl_user") //@Table来指定和哪个数据表对应;如果省略默认表名就是user；
								public class User {

									@Id //这是一个主键
									@GeneratedValue(strategy = GenerationType.IDENTITY)//自增主键
									private Integer id;

									@Column(name = "last_name",length = 50) //这是和数据表对应的一个列
									private String lastName;
									@Column //省略默认列名就是属性名
									private String email;
									...
								}
								
								public interface UserRepository extends JpaRepository<User,Integer> {
								}
			Springboot启动配置：
				构造过程（initialize(sources)）
					ApplicationContextInitializer，应用程序初始化器，做一些初始化的工作，	
					ApplicationListener，应用程序事件(ApplicationEvent)监听器，
					默认情况下，initialize方法从spring.factories文件中找出对应的key为ApplicationContextInitializer的类与ApplicationListener的类；
				SpringApplication执行
					SpringApplication构造完成之后调用run方法，启动SpringApplication，run方法执行的时候会做以下几件事
					构造Spring容器、刷新Spring容器、从Spring容器中找出ApplicationRunner和CommandLineRunner接口的实现类并排序后依次执行！
					
	五、Springboot与缓存：
			JSR107标准：
				Java Caching定义了5个核心接口，分别是CachingProvider, CacheManager, Cache, Entry和Expiry
					CachingProvider定义了创建、配置、获取、管理和控制多个CacheManager。
					CacheManager定义了创建、配置、获取、管理和控制多个唯一命名的Cache。
					Cache是一个类似Map的数据结构并临时存储以Key为索引的值。
					Entry是一个存储在Cache中的key-value对。Expiry 每一个存储在Cache中的条目有一个定义的有效期。
			使用：
				<dependency>
					<groupId>javax.cache</groupId>
					<artifactId>cache-api</artifactId>
				</dependency>
			Spring缓存抽象：
				简介：Spring从3.1开始定义了org.springframework.cache.Cache和org.springframework.cache.CacheManager接口来统一不同的缓存技术；
					并支持使用JCache（JSR-107）注解简化开发；
				特点：
					Cache接口为缓存的组件规范定义，包含缓存的各种操作集合；
					Cache接口下Spring提供了各种xxxCache的实现；如RedisCache，EhCacheCache , ConcurrentMapCache等；
					每次调用需要缓存功能的方法时，Spring会检查检查指定参数的指定的目标方法是否已经被调用过；如果有就直接从缓存中获取方法调用后的结果，如果没有就调用方法并缓存结果后返回给用户。下次调用直接从缓存中获取。
					使用Spring缓存抽象时我们需要关注以下两点； 
						确定方法需要被缓存以及他们的缓存策略
						从缓存中读取之前缓存存储的数据
				注解：
					@Cacheable - 主要针对方法配置，能够根据方法的请求参数对其结果进行缓存
					@CacheEvict - 清空缓存（删除）
					@CachePut - 保证方法被调用，又希望结果被缓存（更新）
					@EnableCaching	- 开启基于注解的缓存
					keyGenerator - 缓存数据时key生成策略
					serialize - 缓存数据时value序列化策略
				主要参数：
					cacheNames - 缓存的名称 如：@Cacheable(cacheNames={"emp"})
					value - 缓存的名称 如：@Cacheable(value=”cache0”) 或者 @Cacheable(value={”cache1”,”cache2”}
					key - 缓存的key，可以为空，如果指定要按照 SpEL 表达式编写，如果不指定，则缺省按照方法的所有参数进行组合，如：@Cacheable(value=”cache0”,key=”#userName”)
					condition - 缓存的条件，可以为空，使用 SpEL 编写，返回 true 或者 false，只有为 true 才进行缓存/清除缓存，在调用方法之前之后都能判断，如：@Cacheable(value=”cache0”,condition=”#userName.length()>2”)
					allEntries -是否清空所有缓存内容，缺省为 false，如果指定为 true，则方法调用后将立即清空所有缓存，如：@CachEvict(value=”cache0”,allEntries=true)
					beforeInvocation - 是否在方法执行前就清空，缺省为 false，如果指定为 true，则在方法还没有执行的时候就清空缓存，缺省情况下，如果方法执行抛出异常，则不会清空缓存，如：@CachEvict(value=”cache01”，beforeInvocation=true)
					unless - 用于否决缓存的，条件为true不会缓存，fasle才缓存（与condition恰恰相反），如：@Cacheable(value=”cache01”,unless=”#result == null”)
				Cache SpEL available metadata：
					#root.methodName  #当前被调用的方法名
					#root.method.name #当前被调用的方法
					#root.target	  #当前被调用的目标对象
					#root.targetClass #当前被调用的目标对象类
					#root.args[0]     #当前被调用的方法的参数列表
					#root.caches[0].name #当前方法调用使用的缓存列表（如@Cacheable(value={"cache1", "cache2"})），则有两个cache
					#iban、 #a0、#p0 #方法参数的名字.可以直接#参数名，也可以使用#p0或#a0的形式，0代表参数的索引；
					#result           #方法执行后的返回值
				使用：
					•1、引入spring-boot-starter-cache模块
					•2、开启缓存：@EnableCaching
					•3、使用缓存注解
				
			Spring-data-redis：参考：https://blog.csdn.net/qq_26545305/article/details/80559902
				使用:
					1、引入依赖（2.0以后的版本）：
					<dependency>
						<groupId>org.springframework.boot</groupId>
						<artifactId>spring-boot-starter-data-redis</artifactId>
					</dependency>
					2、application.yml配置文件配置redis的相关信息
					spring:
					  redis:
						host: 192.168.224.225
						port: 6379
						password:
					3、配置redis整入spring的缓存框架
						@Configuration
						@EnableCaching  //继承CachingConfigurerSupport并重写方法，配合该注解实现spring缓存框架的使用
						public class RedisConfig extends CachingConfigurerSupport {
							/**载入配置文件配置的连接工厂**/
							@Autowired
							RedisConnectionFactory redisConnectionFactory;
							/*不提示警告信息*/
							@SuppressWarnings("rawtypes")
							@Autowired
							RedisTemplate redisTemplate;
						 
							@Bean
							RedisTemplate<String,Object> objectRedisTemplate(){
								RedisTemplate<String,Object> redisTemplate=new RedisTemplate<>();
								redisTemplate.setConnectionFactory(redisConnectionFactory);
								return redisTemplate;
							}
						 
							@Bean 
							@Override
							public CacheManager cacheManager(){
								RedisCacheManager redisCacheManager=new RedisCacheManager(redisTemplate);
								//设置缓存过期时间
						       // redisCacheManager.setDefaultExpiration(60);//秒
								return redisCacheManager;
							}
						 
							/**
							 * 重写缓存key生成策略，可根据自身业务需要进行自己的配置生成条件
							 * @return
							 */
							@Bean 
							@Override
							public KeyGenerator keyGenerator() {
								return new KeyGenerator() {
									@Override
									public Object generate(Object target, Method method, Object... params) {
										StringBuilder sb = new StringBuilder();
										sb.append(target.getClass().getName());
										sb.append(method.getName());
										for (Object obj : params) {
											sb.append(obj.toString());
										}
										return sb.toString();
									}
								};
							}
						 
						}
					
				操作: spring data redis中用来操作redis的一是采用注解的方式，常用两个注解@Cacheable、@CacheEvit，二是采用RedisTemplate的方式；
					  对应于redis的5中结构，RedisTemplate中定义了对应5种数据结构的操作
					  redisTemplate.opsForValue();//操作字符串
					  redisTemplate.opsForHash();//操作hash
					  redisTemplate.opsForList();//操作list
					  redisTemplate.opsForSet();//操作set
					  redisTemplate.opsForZSet();//操作有序set
			
			Ace-Cache：参考：https://gitee.com/geek_qi/ace-cache
				基于spring boot上的注解缓存，自带轻量级缓存管理页面。@Cache比spring cache更轻量的缓存，支持单个缓存设置过期时间，可以根据前缀移除缓存。采用fastjson序列化与反序列化，以json串存于缓存之中。
				使用：
					1、添加依赖：
						<dependency>
							<groupId>com.github.wxiaoqi</groupId>
							<artifactId>ace-cache</artifactId>
							<version>0.0.2</version>
						</dependency>
					2、配置文件中添加配置：
						redis:
							pool:
								 maxActive: 300
								 maxIdle: 100
								 maxWait: 1000
							host: 127.0.0.1
							port: 6379
							password:
							timeout: 2000
							# 服务或应用名
							sysName: ace
							enable: true
							database: 0
					3、程序入口开启：缓存开启@EnableAceCache
					具体使用：在Service上进行@Cache注解或@CacheClear注解；
						配置缓存：@Cache
								注解参数	类型	说明
								key	字符串	缓存表达式，动态运算出key
								expires	整形	缓存时长，单位：分钟
								desc	描述	缓存说明
								parser	Class<? extends ICacheResultParser>	缓存返回结果自定义处理类
								generator	Class<? extends IKeyGenerator>	缓存键值自定义生成类
						清除缓存：@CacheClear
								注解参数	类型	说明
									pre	字符串	清除某些前缀key缓存
									key	字符串	清除某个key缓存
									keys	字符串数组	清除某些前缀key缓存
									generator	Class<? extends IKeyGenerator>	缓存键值自定义生成类
					轻量管理端：访问地址：http://IP:PORT/cache					
						
	六、Springboot与消息：（异步通信、系统解耦、流量削峰填谷）
				消息的使用：利用消息中间件来提升系统异步通信、扩展解耦能力；
				基本概念：
					消息代理：（message broker）
					目的地：（destination）
					消息队列2种形式目的地
						1. 队列（queue） ：点对点消息通信（point-to-point）
						2. 主题（topic） ：发布（publish） /订阅（subscribe）消息通信
					点对点：
						消息发送者发送消息，消息代理将其放入一个队列中，消息接收者从队列中获取消息内容，消息读取后被移出队列，消息只有唯一的发送者和接受者，但并不是说只能有一个接收者
					发布订阅式：
						发送者（发布者）发送消息到主题，多个接收者（订阅者）监听（订阅）这个主题，那么就会在消息到达时同时收到消息
					JMS（Java Message Service） JAVA消息服务：基于JVM消息代理的规范。 ActiveMQ、 HornetMQ是JMS实现
					AMQP（Advanced Message Queuing Protocol）：高级消息队列协议，也是一个消息代理的规范，兼容JMS；RabbitMQ是AMQP的实现
				JMS与AMQP区别：
					AMQP网络线级协议，跨语言跨平台，支持5种消息模型；（1）direct exchange（2）、fanout exchange（3）、topic change（4）、headers exchange（5）、system exchange
				Springboot的支持：
					– spring-jms提供了对JMS的支持
					– spring-rabbit提供了对AMQP的支持
					– 需要ConnectionFactory的实现来连接消息代理
					– 提供JmsTemplate、 RabbitTemplate来发送消息
					– @JmsListener（JMS）、 @RabbitListener（AMQP）注解在方法上监听消息代理发布的消息
					– @EnableJms、 @EnableRabbit开启支持
					– JmsAutoConfiguration
					– RabbitAutoConfiguration
				RabbitMQ：
					简介：是一个由erlang开发的AMQP(Advanved Message Queue Protocol)的开源实现。
					核心概念：
						Message：消息，它由消息头和消息体组成。消息体是不透明的，而消息头则由一系列的可选属性组
								 成，这些属性包括routing-key（路由键）、 priority（相对于其他消息的优先权）、 delivery-mode（指出
								 该消息可能需要持久性存储）等。
						Publisher：消息的生产者，也是一个向交换器发布消息的客户端应用程序。
						Exchange：交换器，用来接收生产者发送的消息并将这些消息路由给服务器中的队列。
						Exchange有4种类型： direct(默认)，fanout, topic, 和headers，不同类型的Exchange转发消息的策略有所区别。							
						Queue：消息队列，用来保存消息直到发送给消费者。它是消息的容器，也是消息的终点。一个消息可投入一个或多个队列。
							   消息一直在队列里面，等待消费者连接到这个队列将其取走。
						Binding：绑定，用于消息队列和交换器之间的关联。一个绑定就是基于路由键将交换器和消息队列连
								 接起来的路由规则，所以可以将交换器理解成一个由绑定构成的路由表。Exchange 和Queue的绑定可以是多对多的关系。
						Connection：网络连接，比如一个TCP连接。
						Channel：信道，多路复用连接中的一条独立的双向数据流通道。信道是建立在真实的TCP连接内的虚
								 拟连接， AMQP 命令都是通过信道发出去的，不管是发布消息、订阅队列还是接收消息，这
								 些动作都是通过信道完成。因为对于操作系统来说建立和销毁 TCP 都是非常昂贵的开销，所
								 以引入了信道的概念，以复用一条 TCP 连接。
						Consumer：消息的消费者，表示一个从消息队列中取得消息的客户端应用程序。 
						Virtual Host：虚拟主机，表示一批交换器、消息队列和相关对象。虚拟主机是共享相同的身份认证和加密环境的独立服务器域。
									  每个 vhost 本质上就是一个 mini 版的 RabbitMQ 服务器，拥有									  
									  自己的队列、交换器、绑定和权限机制。vhost 是 AMQP 概念的基础，必须在连接时指定，RabbitMQ 默认的 vhost 是 / 。
						Broker：表示消息队列服务器实体   
					运行机制：
						一句话概括：生产者将消息发送到Exchange（交换机），Exchange根据路由规则（routing-key）将消息Binding绑定到不同的消息队列，消费者
									从消息队列里取出消息
						Exchange的类型：Exchange分发消息时根据类型的不同分发策略有区别，目前共四种类型：
										direct、 fanout、 topic、 headers 。 headers 匹配 AMQP 消息的 header而不是路由键，
										headers 交换器和 direct 交换器完全一致，但性能差很多，目前几乎用不到了，
										所以直接看另外三种类型：
									1、Direct Exchange：完全匹配、单播模式（消息中的routing-key与消息队列中的binding key完全一致）
									2、Fanout（扇出） Exchange：广播模式（与消息中的routing-key无关的，交换器将消息转发到所有的消息队列里）
									3、Topic Exchange：模式匹配分发消息，将路由键与绑定键的字符用.隔开，支持识别通配符：符号“#”和符号 “*” 。
													   #匹配0个或多个单词，*匹配一个单词。
				与Springboot的整合：
					1、添加依赖：
						 <dependency>
							<groupId>org.springframework.boot</groupId>
							<artifactId>spring-boot-starter-amqp</artifactId>
						</dependency>
					2、配置文件中添加配置：
							#RabbitMQ相关的配置信息
							spring.rabbitmq.host=127.0.0.1
							spring.rabbitmq.port=5672
							spring.rabbitmq.username=guest
							spring.rabbitmq.password=guest
					3、申明使用：
						AmqpTemplate - 发送消息
						@RabbitListener(queues="") - 监听消息
						
		七、Springboot与检索ElasticSearch：
				简介：ElasticSearch是一个分布式搜索服务，提供Restful API，底层基于Apache Lucene，采用多shard（分片）的方式保证数据安全，并且提供自动resharding的功能，
					  github等大型的站点也是采用了ElasticSearch作为其搜索服务。
				特点：1、分布式实时文件存储，并将每一个字段都编入索引
					  2、实时分析的分布式搜索引擎
					  3、可以扩展到上百台服务器，处理PB级别的结构化或非结构化数据（1PB=1024TB）
				与Mysql对比：
					关系数据库     ⇒ 数据库         ⇒ 表          ⇒ 行              ⇒ 列(Columns)
					Elasticsearch  ⇒ 索引(Index)    ⇒ 类型(type)  ⇒ 文档(Docments)  ⇒ 属性/字段(Fields)
				注意与MongoDB的区别：数据库         ⇒ 集合        ⇒ 文档            ⇒ 属性
				交互：与Elasticsearch的交互，可以使用Java API，也可以直接使用HTTP的Restful API方式
				核心：提供了强大的索引功能；
				与Springboot的整合：
					1、添加依赖：
						 <dependency>
							<groupId>org.springframework.boot</groupId>
							<artifactId>spring-boot-starter-data-elasticsearch</artifactId>
							<version>2.0.2.RELEASE</version>
						</dependency>
					2、配置文件中添加配置：	
						#elasticsearch集群名称，默认的是elasticsearch
						spring.data.elasticsearch.cluster-name=
						#节点的地址 注意api模式下端口号是9300，千万不要写成9200
						spring.data.elasticsearch.cluster-nodes=192.168.11.24:9300
						#是否开启本地存储
						spring.data.elasticsearch.repositories.enable=true
					3、申明使用：
						参考：https://blog.csdn.net/linzhiqiang0316/article/details/80343401	
						ElasticsearchRepository、 ElasticsearchTemplate、 JestClient
						
		八、Springboot与任务：
				异步：与第三方系统交互的时候，往往采用异步任务。在Spring 3.x之后，就已经内置了@Async来完美解决这个问题。使用@EnableAysnc、 @Aysnc即可；
				定时：
					
					
----------------------------------------------NoSQL缓存技术Redis的使用-------------------------------------------------------------								
	一、NoSQL入门：
			
							
----------------------------------------------Linux运维相关知识---------------------------------------------------------------------									
							
							
							
							
							
							
							
							
							
							
							
							
							
							
							
							
							
							
							
							
							
							
							
							
							

					  
					  
					  
					  
		    
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	