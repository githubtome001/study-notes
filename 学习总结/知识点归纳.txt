----------------------------------------------容器虚拟化技术Docker------------------------------------------------------- 
一、容器虚拟化技术Docker
	定义：解决了运行环境和配置问题软件容器，方便做持续集成并有助于整体发布的容器虚拟化技术。
	特点:一次构建、随处运行，DevOps，内核虚拟化，依赖与宿主机内核（不同于传统的虚拟机技术）
	基本组成：镜像、容器、仓库
	docker安装：
	docker启动：centos 6+ 命令：service docker start
				centos 7+ 命令：systemctl start docker 
	docker关闭重启：centos 7+ 命令：systemctl restart docker  systemctl stop docker
二、常用命令：
	帮助命令：docker version/docker info/docker --help
	镜像命令：docker images 
			  docker search XXX镜像名，可选参数：
			  docker pull XXX镜像名
			  docker rmi -f XXX镜像名ID
			  移除所有镜像：docker rmi -f $(docker images -qa)
	容器命令：docker run [OPTIONS] IMAGE [COMMAND] [ARG...]
			   OPTIONS说明（常用）：有些是一个减号，有些是两个减号
				--name="容器新名字": 为容器指定一个名称；
				-d: 后台运行容器，并返回容器ID，也即启动守护式容器；
				-i：以交互模式运行容器，通常与 -t 同时使用；
				-t：为容器重新分配一个伪输入终端，通常与 -i 同时使用；
				-P: 随机端口映射；
				-p: 指定端口映射，有以下四种格式
					  ip:hostPort:containerPort
					  ip::containerPort
					  hostPort:containerPort
					  containerPort 
			当前所有正在运行的容器：docker ps [OPTIONS] 
									OPTIONS说明（常用）：
									-a :列出当前所有正在运行的容器+历史上运行过的
									-l :显示最近创建的容器。
									-n：显示最近n个创建的容器。
									-q :静默模式，只显示容器编号。
									--no-trunc :不截断输出。
			退出容器：容器停止退出exit
					  容器不停止退出ctrl+P+Q
			启动/停止/重启/强制停止容器：docker start/stop/restart/kill 容器ID或者容器名
			删除已停止的容器：docker rm -f 容器ID 
			删除所有容器：docker rm -f $(docker ps -a -q) 或docker ps -a -q | xargs docker rm
			启动守护式容器：docker run -d 容器名
			查看容器日志：docker logs -f -t --tail n 容器ID
			查看容器内运行的进程：docker top 容器ID
			查看容器内部细节：docker inspect 容器ID
			进入正在运行的容器并以命令行交互：docker exec -it 容器ID bashShell
											  重新进入docker attach 容器ID
			从容器内拷贝文件到主机上：docker cp 容器ID:容器内路径 目的主机路径
三、Docker镜像
	镜像加速原理：bootfs(加载kernel) / rootfs(不同的操作系统发行版)			
	分层的联合文件系统：最大的一个好处就是 - 共享资源
	Docker镜像commit操作补充：docker commit -m=“提交的描述信息” -a=“作者” 容器ID 要创建的目标镜像名:[标签名]
四、Docker容器数据卷
	作用：容器间继承+共享数据、容器的持久化
	卷的设计目的就是数据的持久化，完全独立于容器的生存周期，因此Docker不会在容器删除时删除其挂载的数据卷
	特点：
		1：数据卷可在容器之间共享或重用数据
		2：卷中的更改可以直接生效
		3：数据卷中的更改不会包含在镜像的更新中
		4：数据卷的生命周期一直持续到没有容器使用它为止
	直接命令添加：
		docker run -it -v /宿主机绝对路径目录:/容器内目录[:ro] [--privileged=true] 镜像名
	查看数据卷是否挂载成功
		docker inspect 容器ID
	容器和宿主机之间数据共享				  
	容器停止退出后，宿主机修改后数据是否同步-同步				  
	DockerFile添加-生成镜像：
		使用方式：在Dockerfile中使用VOLUME指令来给镜像添加一个或多个数据卷，格式：VOLUME["/dataVolumeContainer1","/dataVolumeContainer2","/dataVolumeContainer3"]
		构建：docker build -f Dockerfile路径 -t 新的镜像名
	数据卷容器(容器间继承+传递共享数据)：
		语法：--volumes-from，例如：docker run -it --name doc2 --volumes-from doc01 zzyy/centos
五、DockerFile解析
	定义：Dockerfile是用来构建Docker镜像的构建文件，是由一系列命令和参数构成的脚本。
	构建三步骤：编写Dockerfile文件、docker build、docker run
	关系：
		Dockerfile面向开发，Docker镜像成为交付标准，Docker容器则涉及部署与运维，三者缺一不可，合力充当Docker体系的基石
	保留字:
六、Docker发布
	aliyun镜像的使用：
	登录阿里云Docker Registry：$ sudo docker login --username=ali域逸诚 registry.cn-hangzhou.aliyuncs.com
	从Registry中拉取镜像：$ sudo docker pull registry.cn-hangzhou.aliyuncs.com/ali_yuyicheng/redis_test:[镜像版本号]				  
	将镜像推送到Registry：				  
					$ sudo docker login --username=ali域逸诚 registry.cn-hangzhou.aliyuncs.com
					$ sudo docker tag [ImageId] registry.cn-hangzhou.aliyuncs.com/ali_yuyicheng/redis_test:[镜像版本号]
					$ sudo docker push registry.cn-hangzhou.aliyuncs.com/ali_yuyicheng/redis_test:[镜像版本号]  
					
----------------------------------------------文档数据结构MongoDB的使用-------------------------------------------------------					  
一、npm（Node Package Manager 包管理器）工具的使用
	- 通过npm可以对node中的包进行上传、下载、搜索等操作
		- npm会在安装完node以后，自动安装
		- npm的常用指令
			npm -v 查看npm的版本
			npm version 查看所有模块的版本
			npm init 初始化项目-创建package.json
			npm i/install 包名 安装指定的包
			npm i/install 包名 --save 安装指定的包并添加依赖
			npm i/install 包名 -g 全局安装（一般都是一些工具）
			npm i/install 安装当前项目所依赖的包
			npm s/search 包名 搜索包	
			npm r/remove 包名 删除一个包
二、MongoDB	
	定义：为快速开发WEB应用而设计的数据库，面向文档，类似JSON数据(BSON),注意：MongoDB数据库使用的是JavaScript进行操作的，在MongoDB含有一个对ES标准实现的引擎，
		在MongoDB中所有ES中的语法中都可以使用
	启动：
		- 打开cmd命令行窗口
			- 输入 mongod 启动mongodb服务器
			- 32位注意：
				启动服务器时，需要输入如下内容
					mongod --storageEngine=mmapv1
					mongod --dbpath 数据库路径 --port 端口
			
		- 再打开一个cmd窗口
			- 输入 mongo 连接mongodb ，出现 >				  
					  
	- 基本概念
		数据库（database）- 类比SQL数据库、集合（collection）- 类比SQL表、文档（document）- 类比SQL表记录
		- 在MongoDB中，数据库和集合都不需要手动创建，当我们创建文档时，如果文档所在的集合或数据库不存在会自动创建数据库和集合		
		
	- 基本指令
		show dbs/databases 
			- 显示当前的所有数据库
		use 数据库名
			- 进入到指定的数据库中
		db
			- db表示的是当前所处的数据库
		show collections
			- 显示数据库中所有的集合
			
	- 数据库的CRUD（增删改查）的操作
		  
		- 向数据库中插入文档
		- db.collection.insert()
			- insert()可以向集合中插入一个或多个文档
		- db.collection.insertOne()
			- 向集合中插入一个文档
		- db.collection.insertMany()
			- 向集合中插入多个文档
		如：db.stus.insert([
				{name:"沙和尚",age:38,gender:"男"},
				{name:"白骨精",age:16,gender:"女"},
				{name:"蜘蛛精",age:14,gender:"女"}
			]);
			db.stus.find({}); //查询所有文档
				
		- 查询数据库中的文档
			- db.collection.find()
				- 可以根据指定条件从集合中查询所有符合条件的文档
				- 返回的是一个数组
			- db.collection.findOne()
				- 查询第一个符合条件的文档
				- 返回的是一个对象
			- db.collection.find().count()
				- 查询符合条件的文档的数量
			查询条件：
				-$gt $eq $lt $lte limit() $or
				如：db.emp.find({sal:{$lt:2000 , $gt:1000}}).limit(5);
					db.emp.find({$or:[{sal:{$lt:1000}} , {sal:{$gt:2500}}]});
			分页：
			skip()用于跳过指定数量的数据，MongoDB会自动调整skip和limit的位置
			如：db.numbers.find().skip(10).limit(10); -第11条到20条数据	
			如：db.stus.find({age:16 , name:"白骨精"});
				
		- 修改数据库中的文档
			- db.collection.update()
				- 可以修改、替换集合中的一个或多个文档（默认修改一个）
				注意：  - update()默认情况下会使用新对象来替换旧的对象
						- 如果需要修改指定的属性，而不是替换需要使用“修改操作符”来完成修改
							$set 可以用来修改文档中的指定属性
							$unset 可以用来删除文档的指定属性
							内嵌文档中：
							$push 用于向数组中添加一个新的元素
							$addToSet 向数组中添加一个新元素 ，如果数组中已经存在了该元素，则不会添加
							$inc 增加到	，如:db.emp.updateMany({sal:{$lte:1000}} , {$inc:{sal:400}});						
						- update()默认只会修改一个
			- db.collection.updateOne()
				- 修改集合中的一个文档
			- db.collection.updateMany()
				- 修改集合中的多个文档
			- db.collection.replaceOne()
				- 替换集合中的一个文档
			如：db.stus.update(
				{"_id" : ObjectId("59c219689410bc1dbecc0709")},
				{$set:{
					gender:"男",
					address:"流沙河"
				}}    
			)
			又如：db.stus.update(
					{"name" : "猪八戒"},
					
					{
						$set:{
						address:"呵呵呵"
						}
					}  ,
					{
						multi:true
					}    
				)
				
		- 删除集合中的文档
			- db.collection.remove()
				- 删除集合中的一个或多个文档（默认删除多个），可以第二个参数传递一个true，则只会删除一个
			- db.collection.deleteOne()
				- 删除集合中的一个文档
			- db.collection.deleteMany()
				- 删除集合中的多个文档
			- 清空一个集合
				db.collection.remove({})
			- 删除一个集合
				db.collection.drop()
			- 删除一个数据库
				db.dropDatabase()	
			注意：一般数据库数据中添加一个字段，来表示数据是否被删除
				如：db.stus.insert([
					{
						name:"zbj",
						isDel:0
						},
						{
						name:"shs",
						isDel:0
						},
					{
					name:"ts",
						isDel:0
					}

				]);
				db.stus.updateOne({name:"ts"},{$set:{isDel:1}});	
				db.stus.find({isDel:0});
	文档关系：一对一（one to one），内嵌文档的形式
			  如：db.wifeAndHusband.insert([
					{
						name:"黄蓉",
						husband:{
							name:"郭靖"
						}
					},{
						name:"潘金莲",
						husband:{
							name:"武大郎"
						}
					}

				]);
			  一对多（one to many）/多对一(many to one)，也可以用内嵌文档的形式
			  多对多(many to many) 用两个集合表示
	排序与投影：
			查询文档时，默认情况是按照_id的值进行排列（升序）
			sort()可以用来指定文档的排序的规则,sort()需要传递一个对象来指定排序规则 1表示升序 -1表示降序
			limit skip sort 可以以任意的顺序进行调用
			如：db.emp.find({}).sort({sal:1,empno:-1});
			在查询时，可以在第二个参数的位置来设置查询结果的投影，0不显示；1：显示
			如：db.emp.find({},{ename:1 , _id:0 , sal:1});
	分组查询：
		分组分片查询，aggregate的使用
		//源数据
		db.items.insert( [
		  {
		   "quantity" : 2,
		   "price" : 5.0,
		   "pnumber" : "p003",
		  }...,{
		   "quantity" : 5,
		   "price" : 10.0,
		   "pnumber" : "p002"
		  }
		])    
		//$group语法:{ $group: { _id: <expression>, <field1>: { <accumulator1> : <expression1> }, ... } }
		/*
		 *_id 分组的key,expression分组的字段，如果_id为null 相当于SQL:select count(*) from table
		 *field1 分组后展示的字段
		 *accumulator1 分组管道函数，如：$sum\$avg\$min\$max\$push\$addToSet\$first\$last
		 *expression1  分组显示数据相关
		 */	
		//查询总数,相当于SQL:select count(1) as count from items
		db.items.count();
		db.items.aggregate([{$group:{_id:null,count:{$sum:1}}}])
		//统计数量，相当于SQL:select sum(quantity) as total  from  items
		db.items.aggregate([{$group:{_id:null,total:{$sum:"$quantity"}}}]);
		//按产品类型来进行分组，然后在统计卖出的数量是多少，相当于SQL：select sum(quantity) as total from  items  group by pnumber
		db.items.aggregate([{$group:{_id:"$pnumber",total:{$sum:"$quantity"}}}])
		//通过相同的产品类型来进行分组，然后查询相同产品类型卖出最多的订单详情，相当于SQL:select max(quantity) as quantity from  items  group by pnumber
		db.items.aggregate([{$group:{_id:"$pnumber",max:{$max:"$quantity"}}}])
		db.items.aggregate([{$group:{_id:"$pnumber",min:{$min:"$quantity"}}}])
		//通过相同的产品类型来进行分组，统计各个产品数量，然后获取最大的数量，相当于SQL:select max(t.total) from (select sum(quantity) as total from  items  group by pnumber) t
		db.items.aggregate([{$group:{_id:"$pnumber",total:{$sum:"$quantity"}}}])
		db.items.aggregate([{$group:{_id:"$pnumber",total:{$sum:"$quantity"}}},{$group:{_id:null,max:{$max:"$total"}}}])
		//通过相同的产品类型来进行分组，然后查询每个订单详情相同产品类型卖出的平均价格，相当于SQL:select avg(price) as price from  items  group by pnumber
		db.items.aggregate([{$group:{_id:"$pnumber",price:{$avg:"$price"}}}])
		//通过相同的产品类型来进行分组，然后查询每个相同产品卖出的数量放在数组里面,，注意值数组中的值不要超过16M
		db.items.aggregate([{$group:{_id:"$pnumber",quantitys:{$push:"$quantity"}}}])
		db.items.aggregate([{$group:{_id:"$pnumber",quantitys:{$push:{quantity:"$quantity",price:"$price"}}}}])
		//表达式的值添加到一个数组中（无重复值），这个值不要超过16M
		db.items.aggregate([{$group:{_id:"$pnumber",quantitys:{$addToSet:"$quantity"}}}])
		//$first：返回每组第一个文档，如果有排序，按照排序，如果没有按照默认的存储的顺序的第一个文档。
		//$last：返回每组最后一个文档，如果有排序，按照排序，如果没有按照默认的存储的顺序的最后个文档。
		db.items.aggregate([{$group:{_id:"$pnumber",quantityFrist:{$first:"$quantity"}}}])
		//$project显示或不显示字段，相当于SQL:select
		db.items.aggregate([{$group:{_id:null,count:{$sum:1}}},{$project:{"_id":0,"count":1}}])
		//通过滤订单中，想知道卖出的数量大于8的产品有哪些产品，相当于SQL:select sum(quantity) as total from  items  group by pnumber having total>8   
		db.items.aggregate([{$group:{_id:"$pnumber",total:{$sum:"$quantity"}}},{$match:{total:{$gt:8}}}])
		//$match如果是放在$group之前就是当做where来使用，我们只统计pnumber =p001 产品卖出了多少个  select sum(quantity) as total from  items where pnumber='p001'
		db.items.aggregate([{$match:{"pnumber":"p001"}},{$group:{_id:null,total:{$sum:"$quantity"}}}])
		//$skip、$limit使用顺序不同，结果也不同，注意：$limit、$skip、$sort、$match可以使用在阶段管道，如果使用在$group之前可以过滤掉一些数据，提高性能
		db.items.aggregate([{ $skip: 2 },{ $limit: 4 },{ $sort: { quantity : -1 }}])
		db.items.aggregate([{ $limit: 4 },{ $skip: 2 }])
		//将文档中的某一个数组类型字段拆分成多条，每条包含数组中的一个值
		db.items.aggregate([{$group:{_id:"$pnumber",quantitys:{$push:"$quantity"}}}])
		db.items.aggregate([{$group:{_id:"$pnumber",quantitys:{$push:"$quantity"}}},{$unwind:"$quantitys"}])
		//$out必须为pipeline最后一个阶段管道，因为是将最后计算结果写入到指定的collection中
		db.items.aggregate([{$group:{_id:"$pnumber",quantitys:{$push:"$quantity"}}},{$unwind:"$quantitys"},{$project:{"_id":0,"quantitys":1}},{$out:"result"}])
		db.result.find()
	模糊查询：$options - 可选参数				  
		如：db.students.find({"user_name": {$regex: /尚/, $options:'i'}}); 
			db.students.find({"user_name": {$regex:/尚.*/i}}); 
			db.students.find({user_name:{$in:[/^孙尚香/i,/^胡歌/]}});
			db.students.find({user_name:{$regex:/^孙尚香/i,$nin:['孙尚香II']}});
			db.students.find({user_name:{$regex:/香/,$options:"si"}});	

----------------------------------------------缓存技术Redis的使用---------------------------------------------------------	
	
			
----------------------------------------------SpringCloud技术栈的使用---------------------------------------------------------						  
	基础概念：
	    微服务：强调的是服务的大小，它关注的是某一个点，是具体解决某一个问题/提供落地对应服务的一个服务应用
		-最早提出：马丁福勒
				微服务化的核心是将传统的一站式应用，根据业务拆分成一个一个的服务，彻底
		地去耦合,每一个微服务提供单个业务功能的服务，一个服务做一件事，
		从技术角度看就是一种小而独立的处理过程，类似进程概念，能够自行单独启动
		或销毁，拥有自己独立的数据库。
		微服务架构：架构模式，微服务之间互相协调、互相配合，每个服务运行在其独立的进程中，
			服务与服务间采用轻量级的通信机制互相协作（通常是基于HTTP协议的RESTful API），包括一些环境，有机构成的整体。
		优点缺点：
		-优点：内聚小，松耦合，拥有独立的进程，开发简单；
			   易于与第三方集成，如：与持续自动化构建部署（Jenkins, Hudson）
			   微服务只是业务逻辑的代码，不会和HTML,CSS 或其他界面组件混合（前后端分离思想）。
		-缺点：开发人员要处理分布式系统的复杂性
			   多服务运维难度，随着服务的增加，运维的压力也在增大
			   系统部署依赖
			   服务间通信成本、数据一致性、系统集成测试、性能监控……
		微服务技术栈：
			微服务条目			落地技术											备注			               
			
			服务开发			Springboot、Spring、SpringMVC
			服务配置与管理		Netflix公司的Archaius、阿里Diamond等
			服务注册与发现		Eureka、Consul、Zookeeper、AliBabaNacos等
			服务调用			Rest、RPC、gRPC
			服务熔断器			Hystrix、Envoy等
			负载均衡			Ribbon、Feign Nginx等
			服务接口调用(客户端调用服务的简化工具)
								Feign等
			消息队列			Kafka、RabbitMQ、ActiveMQ等
			服务配置中心管理  	SpringCloudConfig、Chef等
			服务路由（API网关） Zuul等
			服务监控			Zabbix、Nagios、Metrics、Spectator等
			全链路追踪			Zipkin，Brave、Dapper、Sleuth等
			服务部署			Docker、OpenStack、Kubernetes等
			数据流操作开发包	SpringCloud Stream（封装与Redis,Rabbit、Kafka等发送接收消息）
			事件消息总线    	Spring Cloud Bus
			......
    SpringCloud入门介绍：
		含义：SpringCloud=分布式微服务架构下的一站式解决方案，是各个微服务架构落地技术的集合体，俗称微服务全家桶
		与springboot之间关系：SpringBoot可以离开SpringCloud独立使用开发项目，
							  但是SpringCloud离不开SpringBoot，属于依赖的关系.
							  SpringBoot专注于快速、方便的开发单个微服务个体，SpringCloud关注全局的服务治理框架。
		与Dubbo的比较： 最大区别：SpringCloud抛弃了Dubbo的RPC通信，采用的是基于HTTP的REST方式。
						REST相比RPC更为灵活，服务提供方和调用方的依赖只依靠一纸契约，这在强调快速演化的微服务环境下，显得更加合适。
						品牌机与组装机的区别
						Spring Cloud的功能比DUBBO更加强大，涵盖面更广，而且作为Spring的拳头项目，它也能够与Spring Framework、Spring Boot、Spring Data、Spring Batch等其他Spring项目完美融合，这些对于微服务而言是至关重要的。
						使用Dubbo构建的微服务架构就像组装电脑，各环节我们的选择自由度很高；
						而Spring Cloud就像品牌机，在Spring Source的整合下，做了大量的兼容性测试，保证了机器拥有更高的稳定性。
						社区支持与更新力度
						最为重要的是，DUBBO停止了5年左右的更新，虽然2017.7重启了(刘军)。对于技术发展的新需求，需要由开发者自行拓展升级（比如当当网弄出了DubboX），这对于很多想要采用微服务架构的中小软件组织，显然是不太合适的，中小公司没有这么强大的技术能力去修改Dubbo源码+周边的一整套解决方案，并不是每一个公司都有阿里的大牛+真实的线上生产环境测试过。
	简单服务调用：
			-RestTemplate + API 使用方式： 
			 RestTemplate提供了多种便捷访问远程Http服务的方法，是一种简单便捷的访问restful服务模板类，是Spring提供的用于访问Rest服务的客户端模板工具集 
			使用步骤：
			1，注入Bean：
			如：@Configuration
				public class ConfigBean
				{
				 @Bean
				public RestTemplate getRestTemplate()
					{
				return new RestTemplate();
					}
				}
			2，声明使用：
			@Autowired
			private RestTemplate restTemplate;
			
			方法中：
			restTemplate.postForObject(REST_URL_PREFIX+"/dept/add", dept, Boolean.class); - 参数：REST请求地址、请求参数、HTTP响应转换被转换成的对象类型

	服务注册与发现：
			-Eureka(C/S)：
				简介：Netflix公司的子模块，是一个基于REST的服务，用于定位服务，以实现云端中间层服务发现和故障转移。Netflix在设计Eureka时遵守的就是AP原则
				CAP原则：CAP原则又称CAP定理，指的是在一个分布式系统中，Consistency（一致性）、 Availability（可用性）、Partition tolerance（分区容错性），三者不可兼得
				三大角色：1、Eureka Server 提供服务注册和发现；2、Service Provider服务提供方将自身服务注册到Eureka，从而使服务消费方能够找到；3、Service Consumer服务消费方从Eureka获取注册服务列表，从而能够消费服务
			使用注册：
				服务端：
				1,引用模块：POM.XML
					<dependency>
					<groupId>org.springframework.cloud<groupId>
					<artifactId>spring-cloud-starter-eureka-server<artifactId>
					</dependency>
				2,配置参数：application.properties或YML文件的配置
				格式：eureka.instance.hostname=localhost
					  #不要向注册中心注册自己
					  eureka.client.register-with-eureka=false
					  #禁止检索服务
					  eureka.client.fetch-registry=false
					  eureka.client.service-url.defaultZone=http://${eureka.instance.hostname}:${server.port}/eureka	
				3,申明使用：程序main入口，添加@EnableEurekaServer注解，来开启服务注册中心
				客户端：
				1,引用模块：POM.XML
					 <dependency>
						<groupId>org.springframework.cloud</groupId>
						<artifactId>spring-cloud-starter-eureka</artifactId>
					</dependency>
				2,配置参数：application.properties或YML文件的配置
				格式：
					#设置服务名
					spring:
					  application:
						name: 服务名
					eureka:
						  client: #客户端注册进eureka服务列表内
							service-url: 
							  defaultZone: http://localhost:7001/eureka
							  instance:
								instance-id: 服务实例名（设置后可以隐藏主机名）
							  prefer-ip-address: true #访问路径可以显示IP地址
							  #点击显示
							  info:
								  app.name: 服务程序名
								  company.name: 公司名
								  build.artifactId: $project.artifactId$
								  build.version: $project.version$
							  
				3,申明使用：主类上添加@EnableEurekaClient注解以实现Eureka中的DiscoveryClient实现，可以使用@EnableDiscoveryClient代替
			使用发现：
				申明使用，主启动类添加@EnableDiscoveryClient
			    使用时注入， @Autowired
							 private DiscoveryClient client;即可使用，注：DiscoveryClient是spring clould 对治理体系的一个抽象
			自我保护机制：某时刻某一个微服务不可用了，eureka不会立刻清理，依旧会对该微服务的信息进行保存
			集群处理：
				在Eureka服务器中添加配置：
				eureka: 
					instance:
						hostname: eureka1.com #eureka服务端的实例名称
					client: 
						register-with-eureka: false #false表示不向注册中心注册自己。
						fetch-registry: false #false表示自己端就是注册中心，我的职责就是维护服务实例，并不需要去检索服务
					service-url: 
					#单机 defaultZone: http://${eureka.instance.hostname}:${server.port}/eureka/       #设置与Eureka Server交互的地址查询服务和注册服务都需要依赖这个地址（单机）。
					defaultZone: http://eureka1.com:7002/eureka/,http://eureka3.com:7003/eureka/
			与Dubbo的Zookeeper的比较：
				著名的CAP理论指出，一个分布式系统不可能同时满足C(一致性)、A(可用性)和P(分区容错性)。由于分区容错性P在是分布式系统中必须要保证的，因此我们只能在A和C之间进行权衡。
				因此,Zookeeper保证的是CP,Eureka则是AP。因此，Eureka可以很好的应对因网络故障导致部分节点失去联系的情况，而不会像zookeeper那样使整个注册服务瘫痪。

			-Consul：
				简介：Spring Cloud Consul是分布式的、高可用、横向扩展(AP原则)，它包含多个组件，但是作为一个整体，在微服务架构中为我们的基础设施提供服务发现和服务配置的工具。它包含了下面几个特性：
					  服务发现（service discovery）
					  健康检查（health checking）
					  Key/Value存储（一个用来存储动态配置的系统）
					  多数据中心（multi-datacenter）
				使用-客户端：
				1,引用模块：POM.XML
					<dependency>
					  <groupId>org.springframework.cloud</groupId>
					  <artifactId>spring-cloud-starter-consul-discovery</artifactId>
					</dependency>
				2,配置参数：application.properties或YML文件的配置
				格式：
					  spring.cloud.consul.host=localhost #域名
					  spring.cloud.consul.port=8500 #端口
	
				3,申明使用：程序main入口，添加@EnableDiscoveryClient注解，开启服务治理
				注意：consul不需要创建类似eureka-server的服务端吗？由于Consul自身提供了服务端，所以我们不需要像之前实现Eureka的时候创建服务注册中心，直接通过下载consul的服务端程序就可以使用。
				启动consul服务：$consul agent -dev
				
			-Nocas：
				简介：Spring Cloud Alibaba 项目中开发分布式应用微服务的子组件，致力于服务发现、配置和管理微服务，基于 DNS 和基于 RPC 的服务发现。
				关键特性：
					1、服务发现和服务健康监测；2、动态配置服务；3、动态DNS服务与服务及其元数据管理
				使用-客户端：
				1,引用模块：POM.XML
					<!--Nacos的服务注册与发现模块-->
					<dependency>
						<groupId>org.springframework.cloud</groupId>
						<artifactId>spring-cloud-starter-alibaba-nacos-discovery</artifactId>
					</dependency>
					<!--统一管理-->
					<dependencyManagement>
						<dependencies>
							<dependency>
								<groupId>org.springframework.cloud</groupId>
								<artifactId>spring-cloud-dependencies</artifactId>
								<version>Greenwich.RELEASE</version>
								<type>pom</type>
								<scope>import</scope>
							</dependency>
							<dependency>
								<groupId>org.springframework.cloud</groupId>
								<artifactId>spring-cloud-alibaba-dependencies</artifactId>
								<version>0.2.2.RELEASE</version>
								<type>pom</type>
								<scope>import</scope>
							</dependency>
						</dependencies>
				</dependencyManagement>
				2,配置参数：application.properties或YML文件的配置
				格式：
					 spring:
						  application:
							name: 程序名
						  cloud:
							nacos:
							  discovery:
								server-addr: 192.168.43.142:8848 # 服务IP与端口
				3,申明使用：程序main入口，添加@EnableDiscoveryClient注解，开启服务治理
				
				详情参考：https://blog.csdn.net/qq_38765404/article/details/89521124

	负载均衡：
			-Ribbon（结合Eureka使用）：
			 简介：基于Netflix实现的一套客户端负载均衡的工具，主要功能是提供客户端的软件负载均衡算法。
			 负载均衡：将用户的请求基于某种规则平摊的分配到多个服务上，从而达到系统的HA，常见的负载均衡有软件Nginx，LVS，硬件F5等
				分类：集中式LB-即在服务的消费方和提供方之间使用独立的LB设施(可以是硬件，如F5, 也可以是软件，如nginx), 由该设施负责把访问请求通过某种策略转发至服务的提供方；
					  进程内LB-将LB逻辑集成到消费方，消费方从服务注册中心获知有哪些地址可用，然后自己再从这些地址中选择出一个合适的服务器。Ribbon就属于进程内LB。
			 使用：
				1,引用模块：POM.XML
					 <dependency>
						<groupId>org.springframework.cloud</groupId>
						<artifactId>spring-cloud-starter-ribbon</artifactId>
					</dependency>
					<dependency>
						<groupId>org.springframework.cloud</groupId>
						<artifactId>spring-cloud-starter-eureka</artifactId>
					</dependency>
				2,配置参数：application.properties或YML文件的配置
				格式：（eureka配置）
					server:
						port: 80
						eureka:
							client:
							register-with-eureka: false
							service-url: 
							defaultZone: http://eureka1.com:7001/eureka/,http://eureka2.com:7002/eureka/,http://eureka3.com:7003/eureka/
	
				3,申明使用：1、程序main入口，添加@EnableDiscoveryClient注解，开启服务治理；2、在配置文件ConfigBean 中添加@LoadBalanced注解
				  -》结论：Ribbon和Eureka整合后服务消费方可以直接调用服务而不用再关心地址和端口号
			    4,策略IRule：简单轮询负载均衡RoundRobinRule，区别于RetryRule，随机负载均衡，加权响应时间负载均衡 ，区域感知轮询负载均衡
			 自定义Ribbon：	
				主启动类添加@RibbonClient注解，格式：@RibbonClient(name="MICROSERVICECLOUD",configuration=MySelfRule.class)，注意：这个自定义配置类不能放在@ComponentScan所扫描的当前包下以及子包下，
					否则我们自定义的这个配置类就会被所有的Ribbon客户端所共享，也就是说我们达不到特殊化定制的目的了。
				在配置文件ConfigBean中添加@LoadBalanced注解
			
			-Feign（声明式服务调用，WebService客户端）：它的使用方法是定义一个接口，然后在上面添加注解，同时也支持JAX-RS（Java API for RESTful Web Services）标准的注解。
			 特性：
				可插拔式的注解支持，包括Feign注解和JAX-RS注解;
				支持可插拔的HTTP编码器和解码器;
				支持Hystrix和它的Fallback;
				支持Ribbon的负载均衡;
				支持HTTP请求和响应的压缩
			 使用：
				1,引用模块：POM.XML
					 <dependency>
						<groupId>org.springframework.cloud</groupId>
						<artifactId>spring-cloud-starter-feign</artifactId>
					</dependency>
					　<dependency>
						<groupId>org.springframework.cloud</groupId>
						<artifactId>spring-cloud-starter-eureka</artifactId>
						<version>1.3.5.RELEASE</version>
					</dependency>
				2,配置参数：application.properties或YML文件的配置
				格式：（整合eureka配置）
					server:
						port: 80
						eureka:
							client:
							register-with-eureka: false
							service-url: 
							defaultZone: http://eureka1.com:7001/eureka/,http://eureka2.com:7002/eureka/,http://eureka3.com:7003/eureka/
	
				3,申明使用：1、程序main入口，添加@EnableDiscoveryClient注解，开启服务治理；同时添加@EnableFeignClients 来开启feign
			                2, 定义接口：
							   格式：value=“服务名称”,configuration = xxx.class 这个类配置Hystrix的一些精确属性
			                   @FeignClient(value = "serviceName",fallback = FeignFallBack.class)
							    public interface FeignService {
									@RequestMapping(value = "/ml", method= RequestMethod.GET)
									String method1(@RequestParam("name") String name) ;
								}
								@Component
								public class FeignFallBack implements FeignService{
							　　//实现的方法是服务调用的降级方法
								@Override
								public String method1() {
									return "error";
								}
								
	服务熔断器（断路器）：		 
			-Hystrix：
			 概念来源：服务雪崩：
				服务扇出：多个微服务之间调用的时候，假设微服务A调用微服务B和微服务C，微服务B和微服务C又调用其它的微服务，这就是所谓的“扇出”效应。
				解决方案：熔断模式（容错处理机制）、隔离模式（容错处理机制）、限流模式（预防模式）
			 简介：Hystrix是一个用于处理分布式系统的延迟和容错的开源库，在分布式系统（SOA面向服务架构）里，许多依赖不可避免的会调用失败，比如超时、异常等，Hystrix能够保证在一个依赖出问题的情况下，不会导致整体服务失败，避免级联故障，以提高分布式系统的弹性。
				   “断路器”本身是一种开关装置，当某个服务单元发生故障之后，通过断路器的故障监控（类似熔断保险丝），
				   向调用方返回一个符合预期的、可处理的备选响应（FallBack），而不是长时间的等待或者抛出调用方无法处理的异常，这样就保证了服务调用方的线程不会被长时间、不必要地占用，从而避免了故障在分布式系统中的蔓延，乃至雪崩。
			 服务熔断
				使用：
					概念：当扇出链路的某个微服务不可用或者响应时间太长时，会进行服务的降级，进而熔断该节点微服务的调用，快速返回"错误"的响应信息。 
						  SpringCloud框架里熔断机制通过Hystrix实现。Hystrix会监控微服务间调用的状况，当失败的调用到一定阈值，缺省是5秒内20次调用失败就会启动熔断机制。熔断机制的注解是@HystrixCommand。
					1,引用模块：POM.XML
						 <dependency>
							<groupId>org.springframework.cloud</groupId>
							<artifactId>spring-cloud-starter-hystrix</artifactId>
						</dependency>
					2,配置参数：application.properties或YML文件的配置
					格式：（配合eureka配置）
						server:
							port: 80
							eureka:
								client:
								register-with-eureka: false
								service-url: 
								defaultZone: http://eureka1.com:7001/eureka/,http://eureka2.com:7002/eureka/,http://eureka3.com:7003/eureka/
		
					3,申明使用：1、程序main入口，添加@EnableCircuitBreaker注解，开启熔断支持；
								2、在控制层申明使用
									格式示例：fallbackMethod 快速应急的处理方法，进行服务降级处理
									@RequestMapping(value="/dept/get/{id}",method=RequestMethod.GET)
									@HystrixCommand(fallbackMethod = "processHystrix_Get")
									public Dept get(@PathVariable("id") Long id){
									    Dept dept =  this.service.get(id);
										if(null == dept){
										throw new RuntimeException("该ID："+id+"没有没有对应的信息");
									    }
										return dept;	
									}
									public Dept processHystrix_Get(@PathVariable("id") Long id){ 
										return new Dept().setDeptno(id)
											   .setDname("该ID："+id+"没有没有对应的信息,null--@HystrixCommand")
											   .setDb_source("no this database in MySQL");
									}
			 
			 服务降级Fallback
				使用： 
					概念：整体资源快不够了，忍痛将某些服务先关掉，待渡过难关，再开启回来。
						  服务降级处理是在客户端实现完成的，与服务端没有关系。
				    申明使用（与Feign结合使用）：	
						格式示例：
						@FeignClient(value = "MICROSERVICECLOUD",fallbackFactory=DeptClientServiceFallbackFactory.class)
						public interface DeptClientService{
							@RequestMapping(value = "/dept/get/{id}",method = RequestMethod.GET)
							public Dept get(@PathVariable("id") long id);
			            }
						
						@Component
						public class DeptClientServiceFallbackFactory implements FallbackFactory{
						
							@Override
							public Dept get(@PathVariable("id") long id){
								...
							}  
						}
						
						注意：在application.properties或YML文件的配置添加一行配置
						      feign: 
								hystrix: 
									enabled: true //开启   
			 
			 服务监控HystrixDashboard
			    使用：
				    概念：Hystrix还提供了准实时的监控（Hystrix Dashboard），Spring Cloud也提供了Hystrix Dashboard的整合，对监控内容转化成可视化界面。
					1,引用模块：POM.XML
						 <dependency>
							<groupId>org.springframework.cloud</groupId>
							<artifactId>spring-cloud-starter-hystrix</artifactId>
						</dependency>
						<dependency>
							<groupId>org.springframework.cloud</groupId>
							<artifactId>spring-boot-starter-actuator</artifactId>
						</dependency>
						
						在服务的监控一方添加如下配置
						<dependency>
							<groupId>org.springframework.cloud</groupId>
							<artifactId>spring-cloud-starter-hystrix-dashboard</artifactId>
						</dependency>
					2,配置参数：application.properties或YML文件的配置
					格式：
						server:
							port: 9901
		
					3,申明使用：1、程序main入口，添加@EnableHystrixDashboard注解，开启熔断监控的支持；
	
	路由网关：
			-Zuul：
			 概念：代理+路由+过滤三大功能，可以与Eureka整合并注册到注册中心里面
			 使用：
				1,引用模块：POM.XML
					<dependency>
						<groupId>org.springframework.cloud</groupId>
						<artifactId>spring-cloud-starter-eureka</artifactId>
					</dependency>
					<dependency>
						<groupId>org.springframework.cloud</groupId>
						<artifactId>spring-cloud-starter-zuul</artifactId>
					</dependency>
				2,配置参数：application.properties或YML文件的配置
				格式：
					zuul: 
					    prefix: /pre //前缀
						ignored-services: 服务名  //多个指定微服务以半角逗号分隔，所有可以用"*"通配符代替
						routes: 
							serverName.path: /serverName/**
							serverName.serviceId: 服务名 //给微服务起别名
							//或使用：serverName.url: http://${IP}:${PORT}/  //这种基于未使用服务注册中心的
						

				3,申明使用：1、程序main入口，添加@EnableZuulProxy注解，开启Zuul的支持；
				
	
	分布式配置中心：
				 -SpringCloud Config（与Git整合使用）
				 概念来源：分布式系统面临的---配置问题
				 概念：为微服务架构中的微服务提供集中化的外部配置支持，配置服务器为各个不同微服务应用的所有环境提供了一个中心化的外部配置
				    分类：服务端和客户端
						  服务端也称为分布式配置中心，它是一个独立的微服务应用，用来连接配置服务器并为客户端提供获取配置信息，加密/解密信息等访问接口
						  客户端则是通过指定的配置中心来管理应用资源，以及与业务相关的配置内容，并在启动的时候从配置中心获取和加载配置信息配置服务器默认采用git来存储配置信息，这样就有助于对环境配置进行版本管理，并且可以通过git客户端工具来方便的管理和访问配置内容。
					规则：1、不同环境不同配置，动态化的配置更新
						  2、运行期间动态调整配置，不再需要在每个服务部署的机器上编写配置文件，服务会向配置中心统一拉取配置自己的信息
						  3、当配置发生变动时，服务不需要重启即可感知到配置的变化并应用新的配置
						  4、将配置信息以REST接口的形式暴露
				 使用：
					 1、用自己的Github账户建一个统一配置中心仓库，并克隆到本地；
					 2、新建配置文件application.yml（保存格式必须为UTF-8）
					    格式参考示例：
						spring:
						  profiles:
							active:
							- dev
						---
						spring:
						  profiles: dev     #开发环境
						  application: 
							name: microservicecloud-config-dev
						---
						spring:
						  profiles: test   #测试环境
						  application: 
							name: microservicecloud-config-test
						#  请保存为UTF-8格式
					 3、push到git仓库
					 服务端配置使用：
						1,引用模块：POM.XML
							<dependency>
								<groupId>org.springframework.cloud</groupId>
								<artifactId>spring-cloud-config-server</artifactId>
							</dependency>
						2,配置参数：application.properties或YML文件的配置
									格式：	
									spring:
										application:
											name: microservicecloud-config
										cloud:
											config:
												server:
													git:
														uri: git@github.com***.git #GitHub上面的git仓库名字
						3,申明使用：1、程序main入口，添加@EnableConfigServer注解，开启Config的支持；		
						配置读取规则：
						  1、/{application}-{profile}.yml 如：http://config-3344.com:3344/application-dev.yml
						  2、/{application}/{profile}[/{label}] 如：http://config-3344.com:3344/application/dev/master
						  3、/{label}/{application}-{profile}.yml 如：http://config-3344.com:3344/master/application-dev.yml
					 客户端配置使用：
					      前提准备：
							本地仓库新建配置文件yml并提交到git仓库里，如：microservicecloud-config-client.yml
								参考示例：
									spring:
										profiles:
											active:
												- dev
									---
									server: 
										port: 8201 
									spring:
										profiles: dev
										application: 
											name: microservicecloud-config-client
									eureka: 
										client: 
											service-url: 
												defaultZone: http://eureka-dev.com:7001/eureka/   
									---
									server: 
										ort: 8202 
									spring:
										profiles: test
										application: 
											name: microservicecloud-config-client
									eureka: 
										client: 
											service-url: 
												defaultZone: http://eureka-test.com:7001/eureka/

						  1,引用模块：POM.XML
							<dependency>
								<groupId>org.springframework.cloud</groupId>
								<artifactId>spring-cloud-starter-config</artifactId>
							</dependency>
						  2,配置参数：bootstrap.yml配置文件的配置（系统级），而application.yml是用户级
									格式：	
									spring:
										cloud:
											config:
												name: microservicecloud-config-client #需要从github上读取的资源名称，注意没有yml后缀名
												profile: dev #本次访问的配置项
												label: master   
												uri: http://config-3344.com:3344  #本微服务启动后先去找3344号服务，通过SpringCloudConfig获取GitHub的服务地址
						  3,申明使用：1、程序main入口，添加@EnableConfigServer注解，开启Config的支持；	
						  
						  
						  
						  
						  
						  
						  
						  
						  
						  
						  
						  
----------------------------------------------Spring Cloud Alibaba 技术栈的使用---------------------------------------------------------						  
					  
					  
					  
					  
					  
					  
					  
					  
					  
					  
					  
		    
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	