                            Day20160711_MySQL.sql
-- 1、信息：现实世界中各种可以接触到的东西
-- 2、数据：信息在计算机世界中的反映（映射）

-- Java中可以把数据存储在各种容器中，但是电脑掉电后（或程序关闭后），存储在内存中的这些数据就被擦除掉了

-- 为了解决数据持久化的问题，人类提出了各种解决方案，比如：结绳记事、文字出现、计算机的使用（单个文件、文件系统、数据库）
-- 解决的核心问题：
-- 1、数据的持久化问题（比如：使用头脑记忆会忘记等等）
-- 2、大量数据的管理问题

-- 数据库（DataBase）是按照数据结构来进行组织、存储和管理数据的仓库

-- 数据库特点：
-- 1、实现数据共享
-- 2、减少数据的冗余
-- 3、保证数据的独立性
-- 4、实现数据的集中控制
-- 5、数据的完整性和一致性
-- 6、数据的故障修复

-- 数据库的分类（依据数据模型 和 发展历史）
-- 1、层次型数据模型	-->	层次型数据库
-- 2、网状型数据模型	-->	网状型数据库
-- 3、关系型数据模型	-->	关系型数据库（理论依据：关系代数）

-- 主流数据库：
-- 关系型数据库：			MySQL（甲骨文公司）、Oracle（甲骨文公司）、SQLServer（微软）、DB2（IBM）等等
-- 非关系型数据库（NoSQL）：	MongoDB、HBase、Cassandra等等

-- MySQL数据库：
-- 特点：体积小、功能比较强大、开源免费（企业特别看重）、应用广泛
-- 	国内互联网三巨头B（百度）A（阿里）T（腾讯）：都有自己针对MySQL的定制版本

-- MySQL数据库引擎：早期MySQL数据库默认引擎使用MyISAM引擎，最新版本默认引擎改为使用InnoDB引擎
-- 1、MyISAM引擎：查询和增删速度较快，但是不支持事务
-- 2、InnoDB引擎：支持事务，是作为关系型数据库MySQL的首选引擎

-- MySQL数据库环境的搭建
-- 1、安装
-- 2、设置
-- 3、查看MySQL服务是否开启，输入命令：services.msc
-- 4、在命令行窗口输入：mysql -uroot -p设置的密码

-- MySQL数据库语法
-- MySQL编码规范：
-- 1、在MySQL中编写的SQL语句均以英文分号;结尾
-- 2、强制要求SQL语句中的关键字使用大写，其他小写
-- 3、命名时，由多个单词组成的命名，多个单词之间使用下划线_连接

-- SQL语言：结构化查询语言（Structured Query Language）
-- 1、数据定义语言DDL：CREATE、DROP、ALTER、TRUNCATE
-- 2、数据操作语言DML：INSERT、UPDATE、DELETE
-- 3、数据查询语言DQL：SELECT
-- 4、数据控制语言DCL：COMMIT、ROLLBACK

-- SQL文件：保存为.sql后缀名的文件
-- SQL语句的注释：使用--两个中横线，接上需要注释的内容

-- 数据定义语言DDL
-- 对于数据库的库的理解：类比超市，超市中有多个区域，分别卖不同的商品：比如：生鲜、水果、肉类、鱼类等

-- MySQL数据库中的库的概念：database

-- 查看MySQL数据库中所有的库：（默认有四个库：information_schema、mysql、performace_schema、test）
-- 注意：这四个库，前三个都是和MySQL数据库系统有关的库，平时不操作，test这个库是创建给我们随意操作的
SHOW DATABASES;

-- 创建库
CREATE DATABSE 数据库名;

-- 删除库
DROP DATABASE 数据库名;

-- 查看MySQL数据库所支持的引擎类型（查看列的结果中SUPPORT列，标为YES或是DEFAULT（默认）都是支持的，标为NO的是不支持的引擎）
SHOW ENGINES \g;

-- 既然MySQL数据库中可以有多个database库，所以使用时，首先需要显式的说明要使用的是哪一个database库
USE 需要使用的数据库名;


-- 对于数据库的库中的表的理解：类比超市，超市中不同的区域里，含有若干个货架

-- MySQL数据库中的某个库中会有若干个表：table，回想关系型数据库，这些表其实就是关系的体现
-- 表的特征通过字段：field来进行体现

-- 查看使用的这个库中所有的表：
SHOW TABLES;

-- 创建表
CREATE TABLE 表名
(
	字段名1   数据类型,
	字段名2   数据类型,
	...
	字段名n   数据类型
);

-- 最常用的数据类型
-- INT：整型
-- VARCHAR(长度)：字符型

-- 查看表结构
-- 写法1
DESC 表名;
-- 写法2
DESCRIBE 表名;

-- 修改表名
ALTER TABLE 旧表名 RENAME 新表名;

-- 修改表的字段的数据类型
ALTER TABLE 表名 MODIFY 字段名 数据类型;

-- 修改表的字段名 和 数据类型
ALTER TABLE 表名 CHANGE 旧字段名 新字段名 新数据类型;

-- 添加字段（使用FIRST关键字把需要添加的字段添加在表结构的最前面，使用AFTER关键字把需要添加的字段添加在指定字段的后面）
ALTER TABLE 表名 ADD 新字段名 数据类型 FIRST;
ALTER TABLE 表名 ADD 新字段名 数据类型 AFTER 已存在的字段名;

-- 删除字段
ALTER TABLE 表名 DROP 字段名;

-- 删除表
DROP TABLE 表名;


                          Day20160712_MySQL.sql
-- ########## 01.MySQL的基本增删改查操作 ##########
-- 使用命令行编写SQL语句，效率低下，考虑使用图形化客户端工具：例如：MySQL Work Bench、Navicat等，经过反复比较，建议使用SQLyog

-- 重音符`：在MySQL的SQL语句中使用特殊字符时，一般会考虑使用重音符`，键盘位置一般在距离ESC键很近（一般在其下方），为了避免和特殊字符的冲突
-- 单引号'：一般和双引号在一个键上，用于描述字符类型的字段的内容

CREATE TABLE userinfo
(
	userid INT,
	username VARCHAR(10),
	`password` VARCHAR(10)
);

DESC userinfo;

-- 1、新增数据 INSERT
-- A：完整插入形式：INSERT INTO 表名(字段1, 字段2, ... 字段n) VALUES(值1, 值2, ... 值n);
INSERT INTO userinfo(userid, username, `password`) VALUES(1, '张三', '123');
-- B：简写插入形式：INSERT INTO 表名 VALUES(值1, 值2, ... 值n);
INSERT INTO userinfo VALUES(2, '李四', '456');
-- C：插入多行形式：
-- 早期版本：INSERT INTO 表名 VALUES(值1, 值2, ... 值n);INSERT INTO 表名 VALUES(值11, 值12, ... 值1n);
INSERT INTO userinfo VALUES(3, '王五', '789');
INSERT INTO userinfo VALUES(4, '赵六', '999');
-- 后续版本：INSERT INTO 表名 VALUES(值1, 值2, ... 值n), (值11, 值12, ... 值1n);
INSERT INTO userinfo VALUES(5, '小明', '888'), (6, '小红', '777');

-- 注意：空值 和 空串
-- 空串：''，一对单引号包含的内容
INSERT INTO userinfo VALUES(7, '小张', '');
-- 空值：NULL，特殊值
INSERT INTO userinfo VALUES(8, '小李', NULL);
-- 下句插入的是字符串NULL
INSERT INTO userinfo VALUES(9, '小王', 'NULL');

-- 2、修改数据 UPDATE
-- A：修改单个字段的值：UPDATE 表名 SET 字段名 = 新值 WHERE 条件子句;  （注意：通过WHERE条件限定范围）
UPDATE userinfo SET `password` = '666' WHERE username = '赵六';
UPDATE userinfo SET `password` = '999' WHERE userid = 4;
UPDATE userinfo SET `password` = '666' WHERE username = '赵六' AND userid = 4;
-- B：修改多个字段的值：UPDATE 表名 SET 字段名1 = 新值1, 字段名2 = 新值2, ... 字段名n = 新值n WHERE 条件子句; （注意：特别注意SET后多个字段赋值之间使用的是逗号）
UPDATE userinfo SET username = '赵云', `password` = '999' WHERE username = '赵六';
UPDATE userinfo SET username = '赵云', `password` = '666' WHERE userid = 4;
UPDATE userinfo SET username = '赵云', `password` = '999' WHERE userid = 4 AND username = '赵云';

-- 3、删除数据 DELETE  TRUNCATE
-- A：删除满足条件的数据：DELETE FROM 表名 WHERE 条件子句;  （注意：通过WHERE条件限定范围）
DELETE FROM userinfo WHERE `password` = '777';
-- B：删除全部数据：
-- 写法1：不使用WHERE子句的DELETE：DELETE FROM 表名;
DELETE FROM userinfo;
-- 写法2：使用TRUNCATE TABLE 表名;（注意：TRUNCATE常常翻译为截断和数据库的表的数据内容的联系）
TRUNCATE TABLE userinfo;

-- 最简单的查询
SELECT * FROM userinfo;

-- ########## 02.MySQL的一些基本概念 ##########
-- 学习数据库时，应该具备集合论的思想：把数据形成的结果作为一个集合（无序的）
-- 关注点在于作为集合的一系列的数据，而不是集合中的单个孤立的数据

-- 概念描述				物理描述
-- Entity实体		--->table表
-- Attribute属性	--->field字段

-- ########## 03.MySQL的约束 ##########
-- 约束：指的是针对字段进行的条件限制

-- 1、主键约束：描述表中的一个或多个字段为主键，不允许为空
-- A：字段后添加 PRIMARY KEY（适用于单一字段作为主键）
-- B：表中的字段定义均完成后，添加PRIMARY KEY(需要作为主键的字段1, 需要作为主键的字段2, ... 需要作为主键的字段n)（适用于多个字段作为主键）

-- 2、非空约束：描述某一个字段的内容不允许为空
-- 字段后添加 NOT NULL

-- 3、唯一性约束：描述某一个字段唯一，允许为空，但是只能出现一个空值
-- 字段后添加 UNIQUE

-- 4、默认约束：指定某个字段的默认值
-- 字段后添加 DEFAULT 默认值

-- 注意：和约束经常搭配使用的【属性值自增】（常常用于INT类型的主键字段上）
-- 字段后添加 AUTO_INCREMENT

-- 综合使用上述的约束及自增，制作一个学生信息表
CREATE TABLE student
(
	-- 考虑到通过【学生编号】对学生进行区分，所以设置【学生编号】作为表的主键
	-- 同时考虑到人脑记忆编号排到多少比较困难，所以考虑设置【学生编号】为自增
	studentid INT AUTO_INCREMENT PRIMARY KEY,
	-- 考虑【学生姓名】不会是空值，所以在【学生姓名】上使用非空约束
	studentname VARCHAR(20) NOT NULL,
	-- 考虑【学生性别】上使用默认约束
	gender VARCHAR(2) DEFAULT '女',
	-- 考虑【联系电话】上使用唯一约束
	phone VARCHAR(11) UNIQUE
);

DESC student;

-- 1、新增数据
INSERT INTO student VALUES(NULL, '刘备', '男', '110');
-- 测试一下【学生姓名】为null的情况
-- 错误代码： 1048 Column 'studentname' cannot be null
INSERT INTO student VALUES(NULL, NULL, '男', '120');
-- 选取表中的非自增字段赋值插入
INSERT INTO student(studentname, gender, phone) VALUES('关羽', '男', '120');  -- 编号为 2
-- 测试一下【联系电话】不唯一的情况
-- 错误代码： 1062 Duplicate entry '110' for key 'phone'
INSERT INTO student VALUES(NULL, '张飞', '男', '110');
-- 测试一下【学生性别】为默认的情况
INSERT INTO student VALUES(NULL, '黄月英', DEFAULT, '119');		-- 编号为 4

-- 2、修改数据
-- 错误代码： 1062 Duplicate entry '110' for key 'phone'
UPDATE student SET phone = '110' WHERE studentname = '黄月英';

-- 3、删除数据
-- 删除满足条件的数据
DELETE FROM student WHERE studentname = '关羽';

-- 删除全部数据（使用DELETE）
DELETE FROM student;

-- 再插入数据
INSERT INTO student VALUES(NULL, '孙权', '男', '110');		-- 编号为 5
INSERT INTO student VALUES(NULL, '鲁肃', '男', '120');		-- 编号为 6
INSERT INTO student VALUES(NULL, '大乔', DEFAULT, '114'), (NULL, '周瑜', '男', '119');		-- 编号为 7 和 编号为 8

DELETE FROM student;
INSERT INTO student VALUES(NULL, '小乔', DEFAULT, '123'), (NULL, '陆逊', '男', '125');		-- 编号为 9 和 编号为 10

-- 删除全部数据（使用TRUNCATE）
TRUNCATE TABLE student;

-- 再插入数据
INSERT INTO student VALUES(NULL, '曹操', '男', '110');		-- 编号为 1
INSERT INTO student VALUES(NULL, '曹丕', '男', '120');		-- 编号为 2

TRUNCATE TABLE student;
INSERT INTO student VALUES(NULL, '甄姬', DEFAULT, '123'), (NULL, '荀彧', '男', '125');

-- 注意：DELETE 和 TRUNCATE 删除全部数据后再插入数据的区别
-- 对于DELETE，删除数据后再插入数据，使用自增的字段会在删除前的数据基础上继续自增
-- 对于TRUNCATE，删除数据后再插入数据，从初始值重新开始

-- 最简单的查询
SELECT * FROM student;

-- ########## 04.MySQL常用数据类型 ##########
-- 数据类型：
-- 1、数值类型：（使用UNSIGNED关键字修饰无符号整数，即零 和 正整数）
-- 		A：整数类型：
--			tinyint：	1个字节（-128~127，如果使用UNSIGNED关键字范围变成0~255）
-- 			smallint：	2个字节
-- 			mediumint： 	3个字节
-- 			int：		4个字节
-- 			bigint：	8个字节
-- 		B：小数类型：
-- 			浮点数类型：（小数点后位数不确定）
-- 			float:
--			double:
-- 			精确小数类型：（小数点后位数确定，推荐使用）
-- 			decimal：decimal(最大位数, 小数点后数字的位数即精度)
-- 2、字符串类型：（字符串类型的括号中的数字，指的是字符的个数，不是字节的个数）
-- 			char：		定长字符串
-- 			varchar：	变长字符串
--			tinytext：
-- 			mediumtext：
--			text：		文本类型
-- 			longtext：
-- 3、日期类型：
-- 			date：		3个字节，格式：YYYY-MM-DD
-- 			time：		3个字节，格式：HH:ii:ss
--			year：		1个字节，格式：YYYY
--		    	datetime：	8个字节，格式：YYYY-MM-DD HH:ii:ss
-- 			timestamp：	8个字节，格式：YYYY-MM-DD HH:ii:ss
-- 4、复合类型：
-- 			enum类型：枚举类型，只允许从一个集合中取出某一个值，集合最多65535个元素
--			set类型：集合类型，允许从一个集合中取出多个值，集合最多64个元素
-- 5、二进制类型：（作为了解即可）
--	 		binary
--			varbinary
--			bit
--			tinyblob
--			mediumblob
--			blob
--			longblob

-- *******************************************************************************
-- 1、数值类型
CREATE TABLE test_int
(
	field1 TINYINT,
	field2 TINYINT UNSIGNED
);

-- 插入成功
INSERT INTO test_int VALUES(-3, 4);
-- 错误代码： 1264  Out of range value for column 'field2' at row 1
INSERT INTO test_int VALUES(-3, -4);
-- 插入成功
INSERT INTO test_int VALUES(-128, 255);
-- 错误代码： 1264   Out of range value for column 'field1' at row 1
INSERT INTO test_int VALUES(-129, 256);

SELECT * FROM test_int;

CREATE TABLE test_numeric
(
	field1 DECIMAL(10, 2),
	field2 FLOAT
);
DESC test_numeric;

INSERT INTO test_numeric VALUES(123.456, 987.654);		-- field1显示为123.46
INSERT INTO test_numeric VALUES(123.454, 987.654);		-- field1显示为123.45
INSERT INTO test_numeric VALUES(123.455, 987.654);		-- field1显示为123.46
-- 根据上面的测试，得知，对于decimal类型的数据，小数点位数超过设置位数，但总长度没有超出设置的总位数的，按四舍五入的规则

TRUNCATE TABLE test_numeric;
-- 修改test_numeric表的field1字段
ALTER TABLE test_numeric MODIFY field1 DECIMAL(4,2);
DESC test_numeric;

-- 根据上面的测试，得知，对于decimal类型的数据，小数点位数超过设置位数，但总长度超出设置的总位数的，无法插入成功
-- 错误代码： 1264   Out of range value for column 'field1' at row 1
INSERT INTO test_numeric VALUES(123.456, 987.654);

SELECT * FROM test_numeric;

-- *******************************************************************************
-- 2、字符串类型
-- CHAR：	定长字符，存储字符时，按照设定好的长度进行存储，存储不足长度的字符时，不足的部分会以空格补足
-- VARCHAR：定长字符，存储字符时，按照放入其中的字符内容的实际长度进行存储
-- 注意：MySQL处理时是按照上述的规则进行处理的，但是显示时，定长字符不足长度的部分的空格不会显示

CREATE TABLE test_character
(
	field1 VARCHAR(4),
	field2 CHAR(4)
);

INSERT INTO test_character VALUES(' sb ',' nb ');		-- 左右均有空格
INSERT INTO test_character VALUES('sb','nb');			-- 左右均无空格
INSERT INTO test_character VALUES(' sb',' nb');			-- 左侧有空格
INSERT INTO test_character VALUES('sb ','nb ');			-- 右侧有空格

-- 注意：
-- 以UTF-8字符集存储，一个汉字3个长度
-- 以GBK字符集存储，一个汉字2个长度

-- MySQL常用的函数：
-- LENGTH()：		长度函数，统计的是标准字符个数（按一个长度计算），非标准字符个数（按字符集的不同有所不同，以UTF-8字符集存储，一个汉字3个长度）
-- CHAR_LENGTH()：	字符长度函数，统计的是字段内容中字符的个数（一个按一个长度计算）

-- 从上面四条测试数据，得知，对于CHAR类型，右侧的空格不算为长度；对于VARCHAR类型，两侧空格都算为长度
SELECT LENGTH(field1), LENGTH(field2) FROM test_character;
SELECT CHAR_LENGTH(field1), CHAR_LENGTH(field2) FROM test_character;

TRUNCATE TABLE test_character;

-- 错误代码： 1064   You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near 'field2 CHAR(8)' at line 1
ALTER TABLE test_character MODIFY field1 VARCHAR(8), field2 CHAR(8);

ALTER TABLE test_character MODIFY field1 VARCHAR(8);
ALTER TABLE test_character MODIFY field2 CHAR(8);

DESC test_character;

INSERT INTO test_character VALUES('sb朝鲜','nb天朝');			-- 左右均无空格
INSERT INTO test_character VALUES(' sb朝鲜',' nb天朝');			-- 左侧有空格
INSERT INTO test_character VALUES('sb朝鲜 ','nb天朝 ');			-- 右侧有空格
INSERT INTO test_character VALUES(' sb朝鲜 ',' nb天朝 ');		-- 左右均有空格

SELECT * FROM test_character;

SELECT LENGTH(field1), LENGTH(field2) FROM test_character;
SELECT CHAR_LENGTH(field1), CHAR_LENGTH(field2) FROM test_character;

-- *******************************************************************************
-- 3、日期类型
CREATE TABLE test_date_time
(
	field1 DATE,
	field2 DATETIME
);

INSERT INTO test_date_time VALUES('2016-07-12', '2016-07-12 15:22:10');
INSERT INTO test_date_time VALUES('20160712', '20160712152350');

INSERT INTO test_date_time VALUES('18160712', '18160712152350');
-- 错误代码： 1292   Incorrect date value: '18161332' for column 'field1' at row 1
INSERT INTO test_date_time VALUES('18161332', '18161332256162');

-- MySQL常用的函数：
-- NOW()函数：获取当前的日期和时间
INSERT INTO test_date_time VALUES('2016-07-12', NOW());

SELECT * FROM test_date_time;

-- *******************************************************************************
-- 4、复合类型
CREATE TABLE test_enum_set
(
	field1 ENUM('男', '女'),
	field2 SET('听音乐','玩游戏','运动','购物')
);

DESC test_enum_set;

INSERT INTO test_enum_set VALUES('男', '听音乐,玩游戏');
-- 错误代码： 1265    Data truncated for column 'field1' at row 1
INSERT INTO test_enum_set VALUES('男,女', '听音乐,玩游戏');
-- 错误代码： 1265    Data truncated for column 'field1' at row 1
-- 注意：复合类型对于插入的数据内容进行了限制
INSERT INTO test_enum_set VALUES('男孩', '听音乐,玩游戏');

-- 插入SET类型的字段的值和设置的值的顺序不一致，也可以正常插入
-- 但是显示时，以设置的值的顺序为准，从中挑选选中的值显示
INSERT INTO test_enum_set VALUES('女', '购物,听音乐');

SELECT * FROM test_enum_set;


                                  Day20160713.sql
-- 数据库学习中的重点和难点：DQL 查询语句
*%*%
-- # 查询语句关键字执行顺序图
(8)SELECT (9)DISTINCT <select_list>
(1)FROM <left_table>
(3)<join_type> JOIN <right_table>
(2)ON <join_condition>
(4)WHERE <where_condition>
(5)GROUP BY <group_by_list>
(6)WITH {CUBE|ROLLUP}
(7)HAVING <having_condition>
(10)ORDER BY <order_by_list>
(11)LIMIT <limit_number>;

-- ########## 01.MySQL基本查询 ##########
-- 全能通配符：* 匹配所有的字段
SELECT * FROM student;

-- 注意：在实际工作中，不建议使用*星号通配符，因为效率较低
-- 推荐使用指定列的形式（即指明要查询的属性列）：SELECT columnlist FROM 表名;

-- 查询全部列
SELECT studentid, studentname, gender, phone FROM student;

-- 查询部分列
SELECT studentid, studentname, phone FROM student;

-- 注意：表的字段名一般不包含空格，如果字段名中有空格，那么在查询属性列时，需要使用重音符``包在字段名外
-- 		形如：`有空格的字段名`

-- ########## 02.MySQL直接量 ##########
-- 直接量：选择特定的值作为一列，该值和表中的数据没有直接的关系

SELECT 'China';
SELECT 123;
SELECT '中国安徽', studentname FROM student;

-- 注意：在执行表的查询时使用直接量，会在得到的结果行的每一行都重复出现直接量（根据查询的执行顺序）

-- 算术运算（+-*/%）
SELECT 1+2;
SELECT 6-4;
SELECT 3*5;
SELECT 7/3;		-- 2.3333
SELECT 7%3;		-- 1

-- MySQL的常用函数：
-- CONCAT：字符连接函数，用于连接字段，CONCAT(连接内容1, 连接内容2, ...)
SELECT CONCAT('中国', '安徽');
SELECT CONCAT(2, 1, 4);

-- ########## 03.AS起别名 ##########
SELECT * FROM student;

-- 1、使用AS：给字段起别名，格式：字段名 AS 别名
--	使用场景：字段名难以识别
SELECT studentname AS 学生姓名, phone AS 联系电话 FROM student;


-- 2、使用AS：给表起别名，格式：表名 AS 别名
-- 使用场景：表名很长或是需要更清晰的区分表名时或者如果查询的列存在重名时

-- 给表起了别名，但是对于字段不使用表的别名（在没有出现重复的字段列时）没有问题
SELECT studentname, phone FROM student AS t1;

-- 给表起了别名，并对字段使用表的别名，在出现重复的字段列时，可以清楚的区分是哪一个表的字段
SELECT t1.`studentname`, t1.`phone` FROM student AS t1;

-- 如下两种写法可以理解为：别名就是表自身
SELECT student.`studentname`, student.`phone` FROM student;
SELECT student.`studentname`, student.`phone` FROM student AS student;

-- 可以同时对字段和表使用别名
SELECT t1.`studentname` AS 学生姓名, t1.`phone` AS 联系电话 FROM student AS t1;

-- 对字段和表起别名时，也可以省略掉AS关键字，但是不能省略原名 和 别名之间的空格
SELECT t1.`studentname` 学生姓名, t1.`phone` 联系电话 FROM student t1;

-- 注意：经过对比，显然使用AS起别名的形式可读性更好，强制使用这种

-- ########## 04.常用函数 ##########
-- 1、字符函数：
-- LEFT()、RIGHT()、SUBSTRING()、SUBSTR()、LENGTH()、CHAR_LENGTH()、LTRIM()、RTRIM()、TRIM()、CONCAT()、UPPER()、LOWER()
SELECT LEFT('java', 3) AS 左截取;		-- jav
SELECT LEFT('不明觉厉', 3) AS 左截取;	-- 不明觉

SELECT RIGHT('java', 3) AS 右截取;		-- ava
SELECT RIGHT('不明觉厉', 3) AS 右截取;	-- 明觉厉

-- SUBSTRING()函数的第2个参数表示从哪一个位置开始，左侧的起始位置为1
SELECT SUBSTRING('temptation', 3) AS 子串;			-- mptation
SELECT SUBSTRING('temptation', 1) AS 子串;			-- temptation
SELECT SUBSTRING('temptation', 0) AS 子串;			-- 无内容

SELECT SUBSTRING('temptation', 3, 5) AS 子串;		-- mptat
SELECT SUBSTRING('temptation', 3, 0) AS 子串;		-- 无内容
SELECT SUBSTRING('temptation', 3, -1) AS 子串;		-- 无内容
SELECT SUBSTRING('temptation', 3, 10) AS 子串;		-- mptation

-- SUBSTR()函数，效果和SUBSTRING()函数一致
SELECT SUBSTR('temptation', 3) AS 子串;			-- mptation
SELECT SUBSTR('temptation', 1) AS 子串;			-- temptation
SELECT SUBSTR('temptation', 0) AS 子串;			-- 无内容

SELECT SUBSTR('temptation', 3, 5) AS 子串;		-- mptat
SELECT SUBSTR('temptation', 3, 0) AS 子串;		-- 无内容
SELECT SUBSTR('temptation', 3, -1) AS 子串;		-- 无内容
SELECT SUBSTR('temptation', 3, 10) AS 子串;		-- mptation

-- LENGTH()函数和CHAR_LENGTH()函数参见数据类型中的讲解

SELECT LENGTH(' temp tation ') AS 原始长度;		-- 13

-- LTRIM()函数：去除左侧空格
SELECT LTRIM(' temp tation ') AS 去除左侧空格;
SELECT LENGTH(LTRIM(' temp tation ')) AS 去除左侧空格后的长度;

-- RTRIM()函数：去除右侧空格
SELECT RTRIM(' temp tation ') AS 去除右侧空格;
SELECT LENGTH(RTRIM(' temp tation ')) AS 去除右侧空格后的长度;

-- 需求：去除两侧空格
-- 写法1、综合使用LTRIM()函数 和 RTRIM()函数
SELECT LTRIM(RTRIM(' temp tation ')) AS 去除两侧空格;
SELECT LENGTH(LTRIM(RTRIM(' temp tation '))) AS 去除两侧空格后的长度;

-- 写法2、使用TRIM()函数
SELECT TRIM(' temp tation ') AS 去除两侧空格;
SELECT LENGTH(TRIM(' temp tation ')) AS 去除两侧空格后的长度;

-- UPPER()函数：全部大写
SELECT UPPER('Temptation') AS 全部大写;

-- LOWER()函数：全部小写
SELECT LOWER('TempTation') AS 全部小写;

-- 2、日期/时间函数：
-- NOW()、DATE_FORMAT()、DATEDIFF()

-- NOW()函数获取当前的日期和时间
SELECT NOW() AS 当前的日期和时间;	-- 2016-07-13 10:30:10

-- DATE_FORMAT()对日期时间进行格式化
-- DATE_FORMAT()常用格式：
SELECT DATE_FORMAT(NOW(), '%y') AS 年份;	-- 16
SELECT DATE_FORMAT(NOW(), '%m') AS 月份;	-- 07
SELECT DATE_FORMAT(NOW(), '%d') AS 天;		-- 13
SELECT DATE_FORMAT(NOW(), '%Y') AS 完整年份;	-- 2016
SELECT DATE_FORMAT(NOW(), '%M') AS 英文月份;	-- July
SELECT DATE_FORMAT(NOW(), '%D') AS 天的序数词;	-- 13th

SELECT DATE_FORMAT(NOW(), '%h') AS 小时;	-- 10
SELECT DATE_FORMAT(NOW(), '%i') AS 分钟;	-- 2
SELECT DATE_FORMAT(NOW(), '%s') AS 秒;		-- 48
SELECT DATE_FORMAT(NOW(), '%H') AS 小时;	-- 10
SELECT DATE_FORMAT(NOW(), '%I') AS 分钟;	-- 没有这种形式
SELECT DATE_FORMAT(NOW(), '%S') AS 秒;		-- 36

-- DATEDIFF()函数计算间隔天数，结果 = 第1个参数 - 第2个参数
SELECT DATEDIFF(NOW(), '2016-07-17') AS 间隔天数;		-- -4
SELECT DATEDIFF(NOW(), '2016-07-10') AS 间隔天数;		-- 3
SELECT DATEDIFF(NOW(), '2016-07-14') AS 间隔天数;		-- -1
SELECT DATEDIFF(NOW(), '2016-07-12') AS 间隔天数;		-- -1
SELECT DATEDIFF(NOW(), '2016-07-13') AS 间隔天数;		-- 0

-- 3、数值函数：
-- ROUND()、RAND()、PI()
-- ROUND()函数：获取四舍五入的结果
-- A：只有一个参数，那么按照整数部分进行四舍五入
-- B：有两个参数，那么小数部分按照第2个参数的位数进行四舍五入，如果小数部分计算完毕就推到整数部分进行计算

SELECT ROUND(123);				-- 123
SELECT ROUND(125);				-- 125
SELECT ROUND(123.456);			-- 123
SELECT ROUND(123.567);			-- 124
SELECT ROUND(123.678);			-- 124

SELECT ROUND(123.456, 3);			-- 123.456
SELECT ROUND(123.456, 2);			-- 123.46
SELECT ROUND(123.455, 2);			-- 123.46
SELECT ROUND(123.454, 2);			-- 123.46
SELECT ROUND(123.456, 1);			-- 123.5
SELECT ROUND(123.456, 0);			-- 123
SELECT ROUND(123.456, -1);			-- 120

-- RAND()函数：每次随机出不同的值，范围在0~1之间
SELECT RAND();
-- RAND(参数)函数：范围在0~1之间，但是每次随机出的是相同的那个随机数
SELECT RAND(123);	-- 0.9277428611440052
SELECT RAND(120);	-- 0.17719353286288075

-- PI()函数：获取圆周率
SELECT PI();		-- 3.141593

-- 需求：如何获取圆周率的小数点后两位，形如：3.14？
SELECT ROUND(PI(), 2) AS 获取圆周率的小数点后两位;				-- 3.14
SELECT LEFT(PI(), 4) AS 获取圆周率的小数点后两位;				-- 3.14
SELECT SUBSTRING(PI(), 1, 4) AS 获取圆周率的小数点后两位;		-- 3.14

-- 4、转换函数：
-- CAST()、IFNULL()

-- CAST()函数：将某个表达式转换为某种类型，格式：CAST(Expression AS DataType)
SELECT '2016-04-08' AS 日期, CAST('2016-04-09' AS DATETIME) AS 日期和时间;		-- 2016-04-08		2016-04-09 00:00:00
SELECT CAST('2016ABCD' AS DATETIME) AS 日期和时间;				-- (NULL)

-- IFNULL() 函数：判断字段内容为NULL时做什么处理，格式：IFNULL(字段名, 替换值)
DESC student;
SELECT * FROM student;
-- 查看一下student表，电话可以为NULL
INSERT INTO student VALUES(NULL, '曹操', '男', NULL);

SELECT studentname AS 学生姓名, IFNULL(phone, '未知号码') AS 联系电话 FROM student;

-- ########## 05.查询的排序 ##########
-- 排序的两种思路：
-- A：对全部的数据先排序，再筛选
-- B：对全部的数据先筛选，再排序（显然这种形式效率比较高，语义上和实现上都符合要求，所以使用这种形式）

-- 次序：升序（顺序）ASC 和 降序（逆序）DESC
-- 特点：
-- A：没有指明使用哪个字段作为排序顺序时，默认的显示次序是按照表的主键的字段来进行排序（升序）的
-- B：升序时，NULL值的顺序排在非空值之前
-- C：不显式指明次序，默认的顺序为升序（顺序）ASC

DESC student;

SELECT * FROM student;

-- 1、单一字段的排序
SELECT * FROM student ORDER BY phone ASC;
SELECT * FROM student ORDER BY phone DESC;
SELECT * FROM student ORDER BY phone;

-- 2、多个字段的排序
INSERT INTO student VALUES(NULL, '郭嘉', '男', '666'), (NULL, '郭嘉', '男', '111');
-- 需求：按studentname升序，按phone降序
SELECT * FROM student ORDER BY studentname ASC, phone DESC;
INSERT INTO student VALUES(NULL, '郭嘉', '男', '222');

-- 注意：下句也涉及到多个字段的排序：先按studentname升序，再按主键studentid升序
-- 		即首先考虑ORDER BY子句中显式指明的排序次序，其次考虑隐式的主键升序
SELECT * FROM student ORDER BY studentname ASC;


                                  Day20160714.sql
-- ########## 01.基于列的逻辑 ##########

-- 商品表
CREATE TABLE product
(
	-- 商品编号
	productid INT AUTO_INCREMENT PRIMARY KEY,
	-- 商品名称
	productname VARCHAR(20),
	-- 分类编码
	categorycode ENUM('F', 'C')
);

INSERT INTO product VALUES(NULL, '苹果', 'F'), (NULL, '梨子', 'F'), (NULL, '香蕉', 'F'), (NULL, 'Nike', 'C'),(NULL, 'Kappa', 'C');

SELECT * FROM product;

-- 需求：分类编码categorycode显示的F、C不够清晰，在查询结果中希望能够看到清晰的含义
-- 关键字CASE、WHEN、THEN、ELSE、END的结合使用

-- CASE表达式的格式1：
-- select
-- case 字段或表达式
-- when 值1 then 结果1
-- WHEN 值2 THEN 结果2
-- ...
-- else 默认结果
-- end

SELECT
	productid AS 商品编号,
	productname AS 商品名称,
	categorycode AS 分类编码（不清晰）,
	CASE categorycode
	WHEN 'F' THEN '水果'
	WHEN 'C' THEN '衣服'
	ELSE '其他'
	END AS 分类编码（清晰）
FROM product;

-- CASE表达式的格式2：
-- select
-- case
-- when 条件1 then 结果1
-- WHEN 条件2 THEN 结果2
-- ...
-- else 默认结果
-- end

SELECT
	productid AS 商品编号,
	productname AS 商品名称,
	categorycode AS 分类编码（不清晰）,
	CASE
	WHEN categorycode = 'F' THEN '水果'
	WHEN categorycode = 'C' THEN '衣服'
	ELSE '其他'
	END AS 分类编码（清晰）
FROM product;

-- ########## 02.基于行的逻辑 ##########
SELECT * FROM student;

DESC student;

-- 1、使用WHERE子句，对集合进行条件筛选
SELECT * FROM student WHERE gender = '女';
SELECT * FROM student WHERE gender = '男';
-- 错误代码： 1064  You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near 'LIMIT 0, 1000' at line 1
SELECT * FROM student WHERE gender = DEFAULT;

-- 2、在WHERE子句中使用AND，表示逻辑与的关系（筛选出WHERE子句中所有条件均满足的结果）
SELECT * FROM student WHERE gender = '女' AND phone = '123';
SELECT * FROM student WHERE gender = '女' AND phone = '125';

-- 3、在WHERE子句中使用OR，表示逻辑或的关系（WHERE子句中的条件只要有满足的结果就取出来）
SELECT * FROM student WHERE gender = '女' OR phone = '123';
SELECT * FROM student WHERE gender = '女' OR phone = '125';

-- 4、在WHERE子句中使用!= 或者 <>，表示逻辑非（不等于）的关系
SELECT * FROM student WHERE gender != '女';
SELECT * FROM student WHERE gender <> '女';

-- 5、*通配符：星号通配符，用来代替所有的字段名称
SELECT * FROM student;

-- 6、_通配符：下划线通配符（占位通配符），结合LIKE关键字使用
INSERT INTO student VALUES(NULL, '曹丕', '男', '110'), (NULL, '曹植', '男', '120'), (NULL, '曹孟德', '男', '130');

-- 需求：查找以'曹'开头的，后面接一个任意字符的记录
SELECT * FROM student WHERE studentname LIKE '曹_';

-- 需求：查找以'曹'开头的，后面接两个任意字符的记录
SELECT * FROM student WHERE studentname LIKE '曹__';

-- 需求：查找以任意一个字符开头，中间有一个'孟'字，后面接一个任意字符的记录
SELECT * FROM student WHERE studentname LIKE '_孟_';

-- 需求：查找以任意一个字符开头，中间有一个'曹'字，后面接一个任意字符的记录
SELECT * FROM student WHERE studentname LIKE '_曹_';
-- 注意：体会占位的含义，下句插入空格+曹彰，会被查出
INSERT INTO student VALUES(NULL, ' 曹彰', '男', '140');
SELECT * FROM student WHERE studentname LIKE '_曹_';

-- 7、%通配符：任意匹配通配符，结合LIKE使用
INSERT INTO student VALUES(NULL, '曹', DEFAULT, '150');

-- 任意匹配的含义：不论匹配一个字符，还是匹配多个字符，甚至没有字符，均匹配
SELECT * FROM student WHERE studentname LIKE '曹%';

-- 下句中'曹'字符后有两个%百分号的效果和 '曹'字符后有一个%百分号的效果是一致的，都是在'曹'字符之后任意匹配
SELECT * FROM student WHERE studentname LIKE '曹%%';

-- 下句表示在'曹'字符前后任意匹配
SELECT * FROM student WHERE studentname LIKE '%曹%';

-- 匹配所有的记录（非空记录）
SELECT * FROM student WHERE studentname LIKE '%';

-- 匹配所有联系电话以1开头的记录
SELECT * FROM student WHERE phone LIKE '1%';

-- 匹配所有联系电话非空的记录（非空记录）
SELECT * FROM student WHERE phone LIKE '%';

-- 8、使用LIKE进行模糊查询时，取反操作NOT LIKE，不会对NULL值进行匹配的
SELECT * FROM student WHERE phone NOT LIKE '1%';

-- 9、在WHERE子句中使用IN关键字描述处于某一个小的范围的集合
-- IN对应的小范围集合的值在表中均有的情况：匹配值得记录被取出
SELECT * FROM student WHERE phone IN ('110', '120', '666');

-- IN对应的小范围集合的值在表中部分有的情况：匹配值得记录被取出
SELECT * FROM student WHERE phone IN ('110', '120', '777');

-- 注意：上述IN的使用可以理解为：
SELECT * FROM student WHERE phone = '110' OR phone = '120' OR phone = '777';

-- 10、在WHERE子句中使用NOT IN关键字描述不处于某一个小的范围的集合
SELECT * FROM student WHERE phone NOT IN ('110', '120', '666');

SELECT * FROM student WHERE phone NOT IN ('110', '120', '777');

-- 注意：IN某一个小的范围   +   NOT IN某一个小的范围   不等于   全部范围，因为忽略了NULL值

-- 11、使用IS NULL筛选字段的内容为NULL的记录
SELECT * FROM student WHERE phone IS NULL;

-- 12、使用IS NOT NULL筛选字段的内容不为NULL的记录
SELECT * FROM student WHERE phone IS NOT NULL;

-- 注意：IS NULL筛选出的记录   +   IS NOT NULL筛选出的记录   等于   所有记录

-- 13、使用大于、小于、大于等于、小于等于符号进行范围筛选（同样不包含NULL值对应的记录）
SELECT * FROM student WHERE phone > '150';		-- 2条记录
SELECT * FROM student WHERE phone < '150';		-- 7条记录
SELECT * FROM student WHERE phone >= '150';		-- 3条记录
SELECT * FROM student WHERE phone <= '150';		-- 8条记录

-- 14、使用BETWEEN...AND...做范围筛选（考虑边界值是否包含？  答：两个边界值均包含在内）
SELECT * FROM student WHERE studentid BETWEEN 3 AND 8;

-- 下句查询的结果：没有满足条件的记录
SELECT * FROM student WHERE studentid BETWEEN 8 AND 3;

-- 注意：BETWEEN 值1 AND 值2   相当于 大于等于 值1  且 小于等于 值2
SELECT * FROM student WHERE studentid >= 3 AND studentid <= 8;

-- ########## 03.汇总数据 ##########

-- 1、使用DISTINCT关键字去除重复的值
SELECT gender FROM student;
-- 上句从语法上看没有问题，但是从语义上，会取出很多重复的数据，这些重复的数据无意义

SELECT DISTINCT gender FROM student;

-- 聚合函数：SUM()、AVG()、MAX()、MIN()、COUNT()

SELECT * FROM student;

-- 2、单独使用聚合函数
SELECT COUNT(*) AS 记录条数 FROM student;

-- 对字段的内容中没有NULL值的字段进行COUNT()，结果和COUNT(*)的记录数一致
SELECT COUNT(studentid) AS 记录条数 FROM student;

-- 对字段的内容中有NULL值的字段进行COUNT()，结果和COUNT(*)的记录数相差了NULL值得个数
SELECT COUNT(phone) AS 非空记录条数 FROM student;

-- 注意：字段内容中的NULL值不会被COUNT()这个聚合函数统计在内

SELECT MAX(studentid) AS 最大学号 FROM student;
SELECT MIN(studentid) AS 最小学号 FROM student;

SELECT MAX(phone) AS 最大联系电话 FROM student;
SELECT MIN(phone) AS 最小联系电话 FROM student;

-- 注意：字段内容中的NULL值不会被MAX()、MIN()这两个聚合函数统计在内

ALTER TABLE student ADD score INT AFTER phone;

DESC student;
SELECT * FROM student;

-- 此时，新增了score成绩字段（可空），默认值均为NULL，对其进行SUM() 和 AVG()，均无结果
SELECT SUM(score) AS 总分 FROM student;
SELECT AVG(score) AS 平均分 FROM student;

-- 更新随机分数，测试一下
SELECT ROUND(RAND() * 100);
SELECT SUBSTRING(RAND() * 100, 1, 2);		-- 这种形式可能会出现个位数字加小数点点号的结果

-- 更新表中的数据
UPDATE student SET score = ROUND(RAND() * 100) WHERE studentid IN (1, 2, 8);

SELECT SUM(score) AS 总分 FROM student;
SELECT AVG(score) AS 平均分 FROM student;

-- 注意：字段内容中的NULL值不会被SUM()、AVG()这两个聚合函数统计在内

-- AVG(某个字段) = SUM(某个字段) / COUNT(某个字段)
SELECT SUM(score) / COUNT(score) AS 平均分 FROM student;

-- 聚合函数小结：聚合函数均无视NULL值

-- 3、结合GROUP BY子句（分组）使用聚合函数

-- 需求：统计班级中男生人数 和 女生人数
-- 分析：1）按照某些条件对数据进行分组操作
--		2）对于分组后的数据进行统计计算

-- 下句会显示按性别分出来的组中的各自第一条记录
-- 理解：类比把同学按性别分组排成两个纵队，不考虑身高体重，只能看到每组的第一个同学
SELECT * FROM student GROUP BY gender;

-- 按照性别进行分组，
SELECT gender FROM student GROUP BY gender;
-- 上句等价于使用DISTINCT去重复
SELECT DISTINCT gender FROM student;

-- 使用分组时需要具备的思想：
-- 既然使用了GROUP BY子句进行分组，需要操作的数据基于分组出来的组上的数据，即着眼点在组上
-- 而没有使用GROUP BY子句时，我们考虑的着眼点在行上或列上
SELECT gender, COUNT(*) AS 组的人数 FROM student GROUP BY gender;
SELECT gender, COUNT(studentid) AS 组的人数 FROM student GROUP BY gender;

-- 下句的phone字段会显示每组第一条记录的phone字段的值，这个意义对于组来说不大
-- 因为我们关注的是组数据的信息，而不是组中具体某一行数据的信息
SELECT phone, COUNT(*) AS 组的人数 FROM student GROUP BY gender;

-- 需求：统计班级中男生成绩的总分 和 女生成绩的总分
SELECT gender AS 性别,  SUM(score) AS 成绩总分 FROM student GROUP BY gender;

-- 需求：统计班级中男生成绩的平均分 和 女生成绩的平均分
SELECT gender AS 性别,  AVG(score) AS 成绩平均分 FROM student GROUP BY gender;

-- 下句其实就是计算每个学生自己的分数，因为这里的分组以主键来分的，即每一个学生就是一组
SELECT SUM(score) AS 总分 FROM student GROUP BY studentid;
SELECT studentid FROM student GROUP BY studentid;

-- ########## 04.ER关系 ##########

-- ER关系（逻辑描述）
-- A：E---Entity简写，实体，具有相同属性（特征）的对象归为同一实体
-- 		Attribute属性，描述实体具有的特征，一个实体可以有若干个属性来描述
-- B：R---RelationShip简写，关系/联系，数据对象彼此之间互相关联关系

-- ER关系常见的三种形式：
-- 1、一对一关系（1：1）：例如：夫妻关系、一个国家只有一个最高领导人...
-- 2、一对多关系（1：n）：例如：一把锁有多把钥匙、一个房子有多个门、一个皇帝有多个太监、一个部门有多个员工...
-- 3、多对多关系（m：n）：例如：参加招聘会的企业和同学、学生选课、饭桌上的菜和吃菜的人...

-- ########## 05.数据库设计 ##########
-- 设计的过程不是一步到位的，也不可能一步到位，都是一个反复迭代的过程

-- 需求：商场里会员顾客购买若干数量的商品
-- 提供的数据如下：
-- 顾客编号为1的顾客张三购买了3个商品编号为123的A商品
-- 顾客编号为2的顾客李四购买了4个商品编号为456的B商品
-- 顾客编号为1的顾客张三购买了3个商品编号为123的A商品（来自不同渠道）
-- 顾客编号为3的顾客王五购买了5个商品编号为123的A商品
-- 顾客编号为1的顾客张三购买了2个商品编号为456的B商品
-- ....

-- 分析：这可能就是业务提供方描述的一个场景，数据库设计时，会从中挖掘出很多信息
-- 数据整理：去除无效的数据，比如：除去重复的数据（可能来自不同的渠道，但其实描述的是相同的业务内容）

-- 对数据的整理，广大开发人员在长期的数据库设计过程中归纳整理了几个称为【范式】的东西
-- 【第1范式（1NF）】为了保证表中的行的数据是唯一的，属性是原子的。
-- 	也就是说，行的唯一性通过在表中定义一个唯一的主键来实现
-- 注意：这里说的唯一的主键，没有说主键只能建立在一个字段上

CREATE TABLE order_1nf
(
	orderid INT,
	productid INT,
	quantity INT,
	customerid INT,
	customername VARCHAR(10) NOT NULL,
	productname VARCHAR(20) NOT NULL,
	PRIMARY KEY(orderid, productid)
);

-- 【第2范式（2NF）】首先数据必须满足第1范式，其次要求非键属性（Nonkey Attribute）和候选键之间必须满足一定的条件。
-- 也就是说，一个非键属性不能只完全函数依赖于候选键的一部分。
-- 分析：order_1nf中，customerid只依赖于主键（候选键）(orderid, productid)的一部分orderid，所以，需要把order_1nf进行分解
CREATE TABLE order_2nf
(
	orderid INT,
	customerid INT,
	customername VARCHAR(10) NOT NULL,
	PRIMARY KEY(orderid)
);
CREATE TABLE orderdetail_2nf
(
	orderid INT,
	productid INT,
	quantity INT,
	PRIMARY KEY(orderid, productid)
);
CREATE TABLE product_2nf
(
	productid INT,
	productname VARCHAR(20) NOT NULL,
	PRIMARY KEY(productid)
);

-- 【第3范式（3NF）】首先数据必须满足第2范式，其次要求所有的非键属性必须非传递依赖于候选键。
-- 也就是说，一个非键属性不能依赖于其他的非键属性。
-- 分析：order_2nf中，customername依赖于customerid这个非键属性，所以，需要把order_2nf进行分解
CREATE TABLE order_3nf
(
	orderid INT,
	customerid INT,
	PRIMARY KEY(orderid)
);

CREATE TABLE cutomer_3nf
(
	customerid INT,
	customername VARCHAR(10) NOT NULL,
	PRIMARY KEY(customerid)
);

CREATE TABLE orderdetail_3nf
(
	orderid INT,
	productid INT,
	quantity INT,
	PRIMARY KEY(orderid, productid)
);

CREATE TABLE product_3nf
(
	productid INT,
	productname VARCHAR(20) NOT NULL,
	PRIMARY KEY(productid)
);

-- 需求：设计 学生选课的数据库设计
-- 		学生可以选择多门课程，一门课程可以有多个学生，一个老师可以带多门课程，一门课程只能由一个老师来带，每个学生选的课程有一个相应的课程成绩
-- 分析：
-- 实体有学生、课程、老师，
-- 实体间的关系：课程 和 老师 之间的关系是多对一的关系；学生 和 课程 之间的关系是多对多的关系

-- 首先设计较为独立的实体
-- 老师信息实体
CREATE TABLE teacherinfo
(
	-- 老师编号
	teacherid INT AUTO_INCREMENT PRIMARY KEY,
	-- 老师姓名
	teachername VARCHAR(10) NOT NULL,
	-- 老师性别
	teachergender ENUM('男', '女') NOT NULL,
	-- 老师年龄
	teacherage INT NOT NULL
);

-- 学生信息实体
CREATE TABLE studentinfo
(
	-- 学生编号
	studentid INT AUTO_INCREMENT PRIMARY KEY,
	-- 学生姓名
	studentname VARCHAR(10) NOT NULL,
	-- 学生性别
	studentgender ENUM('男', '女') NOT NULL,
	-- 学生年龄
	studentage INT NOT NULL
);

-- 接着设计一对多的关系，可以在作为多的实体中添加作为一的实体的主键作为非键属性；
-- 也可以在作为一的实体中添加作为多的实体的主键作为非键属性的值。显然，前者操作起来比较简单，也是一对多关系的经典设计方式。
-- 课程信息实体
CREATE TABLE courseinfo
(
	-- 课程编号
	courseid INT AUTO_INCREMENT PRIMARY KEY,
	-- 课程名称
	coursename VARCHAR(10) NOT NULL,
	-- 老师编号
	teacherid INT NOT NULL
);

-- 最后考虑设计多对多的关系，首先考虑在courseinfo中放入studentinfo的主键，在studentinfo中放入courseinfo的主键，这样可行
-- 但是既然两个表中都要放入相同的属性，并且考虑到学生选择的课程有相应的课程成绩，所以把相同的属性拿出来单独作为成绩信息实体
-- 成绩信息实体（学生 和 课程 多对多 关联关系表）
CREATE TABLE scoreinfo
(
	-- 成绩编号
	scoreid INT AUTO_INCREMENT PRIMARY KEY,
	-- 学生编号
	studentid INT NOT NULL,
	-- 课程编号
	courseid INT NOT NULL,
	-- 成绩分数
	score DECIMAL(4, 1)
);


                                  Day20160714.sql
-- ########## 01.汇总数据（进阶）##########

-- 模拟数据
INSERT INTO scoreinfo VALUES(NULL, 1, 1, 60), (NULL, 1, 2, 90),(NULL, 1, 3, 80),(NULL, 1, 4, 70),(NULL, 1, 5, 40),
(NULL, 2, 1, 70), (NULL, 2, 2, 50),(NULL, 2, 3, 70),(NULL, 2, 4, 30),(NULL, 2, 5, 90),
(NULL, 3, 1, 55), (NULL, 3, 2, 65),(NULL, 3, 3, 75),
(NULL, 4, 1, 87),(NULL, 4, 2, 63),(NULL, 4, 4, 28);

SELECT * FROM scoreinfo;

-- 需求：取得每个同学的成绩总分和成绩平均分
-- 思路：因为每个学生可能有多门课程的成绩，所以这里需要基于学生编号进行分组，并使用聚合函数
SELECT studentid AS 学生编号, SUM(score) AS 成绩总分, AVG(score) AS 成绩平均分 
FROM scoreinfo GROUP BY studentid;

-- 需求：列出每门功课的最高分、最低分，该门功课的总分、该门功课的平均分
-- 思路：因为每门功课可能对应多个学生的成绩，所以这里需要基于课程编号进行分组，并使用聚合函数
SELECT courseid AS 课程编号, MAX(score) AS 最高分, MIN(score) AS 最高分, SUM(score) AS 总分, AVG(score) AS 平均分
FROM scoreinfo GROUP BY courseid;

-- 需求：列出平均分高于65分的同学的学生编号及其平均分
-- 思路：首先想到的是使用分组子句（GROUP BY）和 筛选条件子句（WHERE）

-- 1、语义错误：先对scoreinfo这个集合进行条件筛选，把65分以上的成绩都留下来了，再按学生编号进行分组
SELECT studentid AS 学生编号, AVG(score) AS 平均分
FROM scoreinfo WHERE score > 65 GROUP BY studentid;

-- 2、语法错误：参照顺序图，因为WHERE子句在GROUP BY子句之前执行的，所以在WHERE子句中无法提前使用聚合函数
-- 错误代码： 1111   Invalid use of group function
SELECT studentid AS 学生编号, AVG(score) AS 平均分
FROM scoreinfo WHERE AVG(score) > 65 GROUP BY studentid;

-- 正确写法：引入 HAVING 子句，对于分组后的数据进行条件筛选
SELECT studentid AS 学生编号, AVG(score) AS 平均分
FROM scoreinfo 
GROUP BY studentid
HAVING AVG(score) > 65;

-- 注意：
-- 1、WHERE子句关注的是行的记录
-- 2、HAVING子句关注的是组的记录

SELECT * FROM scoreinfo HAVING score > 70;
-- 上句可以理解为：
SELECT * FROM scoreinfo GROUP BY scoreid HAVING score > 70;
-- 上句可以理解为：因为按照scoreid这个主键进行分组，每组就是一条记录，对这一条记录使用聚合函数还是它自身
SELECT * FROM scoreinfo GROUP BY scoreid HAVING AVG(score) > 70;
SELECT * FROM scoreinfo GROUP BY scoreid HAVING SUM(score) > 70;
-- 也就等价于
SELECT * FROM scoreinfo WHERE score > 70;

-- 需求：列出单科课程（课程编号）对应的所有同学（多行显示同学编号）
-- 如下写法不正确，因为这样分组后select获取的是每一组的第一条记录
-- 思考：为什么到处使用分组？
SELECT courseid AS 课程编号, studentid AS 学生编号
FROM scoreinfo
GROUP BY courseid;

-- 正确写法：
SELECT courseid AS 课程编号, studentid AS 学生编号
FROM scoreinfo
ORDER BY courseid;
-- 或者
SELECT courseid AS 课程编号, studentid AS 学生编号
FROM scoreinfo
ORDER BY courseid, studentid;

-- 需求：列出单科课程（课程编号）对应的所有同学（单行显示同学编号，多个编号之间以逗号连接）
-- 思路：首先考虑分组，分组后select时使用字符函数CONCAT，但是这样拼接的是每一组的第一条记录中的studentid
-- SELECT courseid AS 课程编号, CONCAT(studentid, ',') AS 学生编号
-- FROM scoreinfo
-- GROUP BY courseid;

-- 到MySQL手册中找灵感，查找了一下和GROUP BY子句相关的内容，看到有GROUP_CONCAT(expr) ：该函数返回带有来自一个组的连接的非NULL值的字符串结果。
SELECT courseid AS 课程编号,  GROUP_CONCAT(studentid) AS 选择该门课程的学生编号
FROM scoreinfo
GROUP BY courseid;

-- 需求：列出单科课程（课程编号）对应的学生人数
SELECT courseid AS 课程编号,  COUNT(studentid) AS 选择该门课程的学生人数
FROM scoreinfo
GROUP BY courseid;

-- 需求：列出单科课程（课程编号）对应的学生人数，并进行总计
-- 思路：总计操作使用 WITH ROLLUP 子句
SELECT courseid AS 课程编号,  COUNT(studentid) AS 选择该门课程的学生人数
FROM scoreinfo
GROUP BY courseid
WITH ROLLUP;

-- 需求：列出单科课程（课程编号）对应的所有学生（单行显示学生编号），并进行总人数的统计（单行显示学生编号）
SELECT courseid AS 课程编号,  GROUP_CONCAT(studentid) AS 选择该门课程的学生编号
FROM scoreinfo
GROUP BY courseid
WITH ROLLUP;


-- ########## 02.LIMIT的使用和分页 ##########
INSERT INTO studentinfo VALUES(NULL, '刘备', '男', 35),(NULL, '关羽', '男', 30),(NULL, '张飞', '男', 25),
(NULL, '貂蝉', '女', 15), (NULL, '吕布', '男', 33),(NULL, '甄姬', '女', 22), (NULL, '董卓', '男', 55);

SELECT * FROM studentinfo;

-- LIMIT的使用：
-- 用法1、LIMIT  起始位置,  记录条数
-- LIMIT的起始位置0表示第一条记录
SELECT * FROM studentinfo LIMIT 0, 3;
SELECT * FROM studentinfo LIMIT 1, 3;
-- 错误代码： 1064    You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near '-1, 3' at line 1
SELECT * FROM studentinfo LIMIT -1, 3;

-- 用法2、LIMIT  记录条数
-- 从第一条记录开始取若干条记录
SELECT * FROM studentinfo LIMIT 0;
SELECT * FROM studentinfo LIMIT 1;
SELECT * FROM studentinfo LIMIT 2;
SELECT * FROM studentinfo LIMIT 3;

-- LIMIT一般用于分页操作
-- 共有7条数据，设置每页3条记录，共分为3页
-- 列出每页的记录来归纳分页的方法：
SELECT COUNT(*) AS 总记录条数 FROM studentinfo;
-- 第1页：第1条、第2条、第3条
SELECT * FROM studentinfo LIMIT 0, 3;
-- 第2页：第4条、第5条、第6条
SELECT * FROM studentinfo LIMIT 3, 3;
-- 第3页：第7条
SELECT * FROM studentinfo LIMIT 6, 1;		-- 此语句执行OK，但是不利于规律的归纳
SELECT * FROM studentinfo LIMIT 6, 3;

-- 从上面的语句进行分析归纳，得出分页的通用方法
-- 考虑制作方法还是从方法的返回值类型 和 参数列表 入手
-- 1、返回值类型就是当前页的数据集合
-- 2、参数列表：对于LIMIT子句来说，就两个参数：初始位置  和   记录条数
-- 		A：记录条数：人为设定每一页的记录的条数
-- 		B：初始位置：变化的值，但是只要知道了当前是第几页，就可以推算出初始位置是多少
--				计算公式：（当前页 - 1）* 记录条数
-- 3、隐含了一个数据需要获取：总页数
-- 		A：总记录条数 % 单页记录条数 == 0 时，总页数 = (总记录条数 / 单页记录条数)
-- 		B：总记录条数 % 单页记录条数 != 0 时，总页数 = (总记录条数 / 单页记录条数) + 1
-- 4、总记录条数： SELECT COUNT(*) AS 总记录条数 FROM studentinfo;



-- ########## 03.插入数据和查询数据的结合操作 ##########
-- 创建学生临时信息表
CREATE TABLE studenttemp
(
	id INT AUTO_INCREMENT PRIMARY KEY,
	`name` VARCHAR(10) NOT NULL,
	gender ENUM('男', '女') NOT NULL
);

SELECT * FROM studenttemp;
SELECT * FROM studentinfo;

-- 需求：把学生信息表中的部分内容查询出来插入到学生临时信息表中
-- 思路：结合使用查询 和 插入
-- INSERT结合查询的写法：INSERT INTO 新表 查询其他表中的数据内容;
INSERT INTO studenttemp(`name`, gender)
SELECT studentname, studentgender FROM studentinfo;

SELECT * FROM studenttemp;

-- 注意：查询出来要插入的数据的数据类型必须和插入表中的字段的数据类型一致（名称可以不一致）


-- ########## 04.子查询 ##########
-- 子查询：在一个查询中包含了另一个查询语句

-- 1、【独立子查询】：先执行子查询，再执行外层查询
-- 使用之前创建的courseinfo表  和  teacherinfo表
INSERT INTO courseinfo VALUES(NULL, '语文', 1), (NULL, '数学', 2), (NULL, '英语', 1);
INSERT INTO teacherinfo VALUES(NULL, '张老师', '男', 60),(NULL, '王老师', '女', 30), (NULL, '李老师', '男', 40);

SELECT * FROM courseinfo;
SELECT * FROM teacherinfo;

-- 需求：列出代课的老师的信息
-- 错误代码： 1242  Subquery returns more than 1 row
-- 分析：下句不是子查询写的不正确，而是这里使用 等号=，到底是去等于子查询查询出来的集合中的哪一条记录呢？
SELECT * FROM teacherinfo 
WHERE teacherid = (SELECT teacherid FROM courseinfo);

-- 正确写法
SELECT * FROM teacherinfo
WHERE teacherid IN (SELECT teacherid FROM courseinfo);

-- 如下写法也正确，但是没有必要这样做，特别对于大量的数据，使用DISTINCT这个去重复的操作非常耗时，除非迫不得已，否则不使用去重复
SELECT * FROM teacherinfo
WHERE teacherid IN (SELECT DISTINCT teacherid FROM courseinfo);

-- 可以按照如下步骤来进行理解：
-- step1、得到集合数据（代课的老师编号）:{ 1, 2, 1 }
SELECT teacherid FROM courseinfo;
-- step2、代课老师的编号是上一步操作中得到的集合中的某一个数据，拿着这个数据到教师信息表中进行筛选
SELECT * FROM teacherinfo WHERE teacherid IN (1, 2, 1);

-- 需求：查找单个学生的所有课程成绩均及格的学生编号  和 学生姓名
-- 显然发生了语义错误：下面的子查询做的事情：
-- 只要这门课程的成绩大于60就筛选留下来了，没有去管这个学生其他课程成绩
SELECT studentid AS 学生编号, studentname AS 学生姓名
FROM studentinfo
WHERE studentid IN (
	SELECT studentid
	FROM scoreinfo
	WHERE score >= 60
);
SELECT * FROM scoreinfo;

-- 正确的写法：
-- 写法1、正向思路：考虑按照学生编号进行分组，取组的最小成绩大于等于60分的同学
SELECT studentid AS 学生编号, studentname AS 学生姓名
FROM studentinfo
WHERE studentid IN (
	SELECT studentid
	FROM scoreinfo
	GROUP BY studentid
	HAVING MIN(score) >= 60
);

-- 写法2、逆向思路：首先，如果考虑正向思考的难度较大，需要知道每个学生选了多少门课程，每门课程的成绩是多少
-- 可以逆向思考一下，所谓所有课程成绩均及格的同学
-- 也就是删除了那些只要有课程不及格就算不及格的同学后剩下的同学
-- 另外还必须是有成绩的同学才是我们要找的那部分同学
SELECT studentid AS 学生编号, studentname AS 学生姓名
FROM studentinfo
WHERE studentid NOT IN (
	-- 至少有一门功课不及格的同学编号
	SELECT studentid
	FROM scoreinfo
	WHERE score < 60
)
-- 有课程成绩的同学编号
AND studentid IN (
	SELECT studentid FROM scoreinfo
);

-- 使用比较运算符的子查询
-- 需求：列出不小于选修了课程编号2的学生学号的学生信息
-- 错误代码： 1242  Subquery returns more than 1 row
SELECT *
FROM studentinfo
WHERE studentid >= (
	SELECT studentid FROM scoreinfo WHERE courseid = 2
);

-- 正确写法：虽然没有大于等于某个范围的关键字或是符号，但是可以大于等于这个范围中最大的那个数据值
SELECT *
FROM studentinfo
WHERE studentid >= (
	SELECT MAX(studentid) FROM scoreinfo WHERE courseid = 2
);

-- 使用EXISTS关键字的子查询：如果子查询查询到了结果，外层的查询才执行；否则的话，外层的查询不执行

-- 需求：有课程成绩大于等于90分的同学就列出全部的学生信息
SELECT *
FROM studentinfo
WHERE EXISTS(SELECT * FROM scoreinfo WHERE score >= 90);

-- 需求：有课程成绩大于90分的同学就列出全部的学生信息
SELECT *
FROM studentinfo
WHERE EXISTS(SELECT * FROM scoreinfo WHERE score > 90);

-- 使用ANY 或 SOME 的子查询

-- 需求：列出学号大于选修了课程编号2的最小的学生学号的学生信息
SELECT *
FROM studentinfo
WHERE studentid >= ANY(
	SELECT studentid FROM scoreinfo WHERE courseid = 2
);
-- 上句等价于下句
SELECT *
FROM studentinfo
WHERE studentid >= (
	SELECT MIN(studentid) FROM scoreinfo WHERE courseid = 2
);
-- 关键字SOME 和 关键字ANY 是同义词
SELECT *
FROM studentinfo
WHERE studentid >= SOME(
	SELECT studentid FROM scoreinfo WHERE courseid = 2
);

-- 使用ALL 的子查询
-- 需求：列出学号不小于所有选修了课程编号2的学生学号的学生信息
SELECT *
FROM studentinfo
WHERE studentid >= ALL(
	SELECT studentid FROM scoreinfo WHERE courseid = 2
);
-- 上句可以理解为：大于等于查询出课程编号2的学生学号这个范围中最大的那个数据值
SELECT *
FROM studentinfo
WHERE studentid >= (
	SELECT MAX(studentid) FROM scoreinfo WHERE courseid = 2
);

-- 结合常见的场景：客户信息 和 订单信息来看看子查询的使用
-- 客户信息表
CREATE TABLE customers
(
	customerid INT AUTO_INCREMENT PRIMARY KEY,
	customername VARCHAR(10) NOT NULL
);

-- 订单信息表
CREATE TABLE orders
(
	orderid INT AUTO_INCREMENT PRIMARY KEY,
	customerid INT NOT NULL,
	-- 金额
	amount DECIMAL(10, 2) NOT NULL,
	-- 订单类型：现金，信用卡
	ordertype VARCHAR(10) NOT NULL
);

INSERT INTO customers VALUES(NULL, '张三'), (NULL, '李四'), (NULL, '王五'), (NULL, '赵六');
INSERT INTO orders VALUES(NULL, 1, 22.25, '现金'), (NULL, 2, 11.75, '信用卡'),(NULL, 2, 5.00, '信用卡'),(NULL, 2, 8.00, '现金'), 
(NULL, 3, 9.33, '信用卡'),(NULL, 3, 10.11, '信用卡');

SELECT * FROM customers;
SELECT * FROM orders;

-- 1、独立子查询作为数据源（包含数据的集合）的使用
-- 需求：以客户为单位，统计每个客户的现金消费总数
-- 1）筛选在分组后做
-- 错误代码： 1054   Unknown column 'ordertype' in 'having clause'
-- 分析：因为按照customerid进行分组形成的每个组中会有不同的ordertype
SELECT customerid AS 客户编号, SUM(amount) AS 现金消费总数
FROM orders
GROUP BY customerid
HAVING ordertype = '现金';
-- 2）筛选在分组前做，考虑使用子查询
-- 错误代码： 1248  Every derived table must have its own alias
SELECT *
FROM (
	SELECT customerid AS 客户编号, SUM(amount) AS 现金消费总数
	FROM orders
	WHERE ordertype = '现金'
	GROUP BY customerid
);
-- 正确写法：
SELECT *
FROM (
	SELECT customerid AS 客户编号, SUM(amount) AS 现金消费总数
	FROM orders
	WHERE ordertype = '现金'
	GROUP BY customerid
) AS temp;

-- 不使用星号通配符，使用具体的字段
-- 错误代码： 1054  Unknown column 'customerid' in 'field list'
SELECT customerid AS 客户编号, SUM(amount) AS 现金消费总数
FROM (
	SELECT customerid AS 客户编号, SUM(amount) AS 现金消费总数
	FROM orders
	WHERE ordertype = '现金'
	GROUP BY customerid
) AS temp;
-- 正确写法：
-- 写法1
SELECT 客户编号, 现金消费总数
FROM (
	SELECT customerid AS 客户编号, SUM(amount) AS 现金消费总数
	FROM orders
	WHERE ordertype = '现金'
	GROUP BY customerid
) AS temp;
-- 写法2
SELECT temp.客户编号, temp.现金消费总数
FROM (
	SELECT customerid AS 客户编号, SUM(amount) AS 现金消费总数
	FROM orders
	WHERE ordertype = '现金'
	GROUP BY customerid
) AS temp;

-- 2、关联子查询
-- 1）在查询条件中使用关联子查询

-- 需求：查询出消费总计小于20元的客户信息
SELECT * FROM orders;
-- 写法1、使用独立子查询
-- 分析后考虑筛选在分组后操作，着眼于以客户编号分出的组的数据上
SELECT *
FROM customers
WHERE customerid IN (
	SELECT customerid
	FROM orders
	GROUP BY customerid
	HAVING SUM(amount) < 20
);
-- 写法2、使用关联子查询
-- 【使用关联子查询时，子查询不再像独立子查询那样可以独立执行，也不再像独立子查询那样先执行】
SELECT *
FROM customers AS c
WHERE (
	SELECT customerid
	FROM orders AS o
	WHERE o.customerid = c.customerid
	GROUP BY o.customerid
	HAVING SUM(o.amount) < 20
);
-- 可以理解为：分步操作，在查询条件中的关联子查询相当于遍历customers表中的每一行记录
-- 第1行记录
SELECT customerid
FROM orders AS o
WHERE o.customerid = 1
GROUP BY o.customerid
HAVING SUM(o.amount) < 20
-- 第2行记录
SELECT customerid
FROM orders AS o
WHERE o.customerid = 2
GROUP BY o.customerid
HAVING SUM(o.amount) < 20
-- 第3行记录（查询到了满足条件的记录，所以留下来）
SELECT customerid
FROM orders AS o
WHERE o.customerid = 3
GROUP BY o.customerid
HAVING SUM(o.amount) < 20
-- 第4行记录
SELECT customerid
FROM orders AS o
WHERE o.customerid = 4
GROUP BY o.customerid
HAVING SUM(o.amount) < 20

-- 2）关联子查询作为一个计算的列

-- 需求：列出客户姓名以及客户的个人消费数量
-- 思路：使用关联子查询from customers这个集合，select一行一行的记录展示出来
-- 		那么，在展示这一行一行记录的时候，对于行中的客户编号，如果能拿着去orders表中做个分组，count一下消费数量就好了
SELECT * FROM orders;

SELECT 
	customername AS 客户姓名,
	(
		SELECT COUNT(o.orderid) AS 消费数量
		FROM orders AS o
		WHERE o.customerid = c.customerid
	) AS 个人消费数量
FROM customers AS c;
-- 可以理解为：分步操作，在列种的关联子查询相当于遍历customers表中的每一行记录
-- 第1行记录
SELECT COUNT(o.orderid) AS 消费数量
FROM orders AS o
WHERE o.customerid = 1
-- 第2行记录
SELECT COUNT(o.orderid) AS 消费数量
FROM orders AS o
WHERE o.customerid = 2
-- 第3行记录
SELECT COUNT(o.orderid) AS 消费数量
FROM orders AS o
WHERE o.customerid = 3
-- 第4行记录
SELECT COUNT(o.orderid) AS 消费数量
FROM orders AS o
WHERE o.customerid = 4

-- 子查询的总结：

-- 1、独立子查询：可以独立执行，且先执行
-- 2、关联子查询：不可以独立执行，且伴随着外层查询的操作，每一次都被调用



					Day20160715_MySQL
-- ########## 01.汇总数据（进阶）##########

-- 模拟数据
INSERT INTO scoreinfo VALUES(NULL, 1, 1, 60), (NULL, 1, 2, 90),(NULL, 1, 3, 80),(NULL, 1, 4, 70),(NULL, 1, 5, 40),
(NULL, 2, 1, 70), (NULL, 2, 2, 50),(NULL, 2, 3, 70),(NULL, 2, 4, 30),(NULL, 2, 5, 90),
(NULL, 3, 1, 55), (NULL, 3, 2, 65),(NULL, 3, 3, 75),
(NULL, 4, 1, 87),(NULL, 4, 2, 63),(NULL, 4, 4, 28);

SELECT * FROM scoreinfo;

-- 需求：取得每个同学的成绩总分和成绩平均分
-- 思路：因为每个学生可能有多门课程的成绩，所以这里需要基于学生编号进行分组，并使用聚合函数
SELECT studentid AS 学生编号, SUM(score) AS 成绩总分, AVG(score) AS 成绩平均分 
FROM scoreinfo GROUP BY studentid;

-- 需求：列出每门功课的最高分、最低分，该门功课的总分、该门功课的平均分
-- 思路：因为每门功课可能对应多个学生的成绩，所以这里需要基于课程编号进行分组，并使用聚合函数
SELECT courseid AS 课程编号, MAX(score) AS 最高分, MIN(score) AS 最高分, SUM(score) AS 总分, AVG(score) AS 平均分
FROM scoreinfo GROUP BY courseid;

-- 需求：列出平均分高于65分的同学的学生编号及其平均分
-- 思路：首先想到的是使用分组子句（GROUP BY）和 筛选条件子句（WHERE）

-- 1、语义错误：先对scoreinfo这个集合进行条件筛选，把65分以上的成绩都留下来了，再按学生编号进行分组
SELECT studentid AS 学生编号, AVG(score) AS 平均分
FROM scoreinfo WHERE score > 65 GROUP BY studentid;

-- 2、语法错误：参照顺序图，因为WHERE子句在GROUP BY子句之前执行的，所以在WHERE子句中无法提前使用聚合函数
-- 错误代码： 1111   Invalid use of group function
SELECT studentid AS 学生编号, AVG(score) AS 平均分
FROM scoreinfo WHERE AVG(score) > 65 GROUP BY studentid;

-- 正确写法：引入 HAVING 子句，对于分组后的数据进行条件筛选
SELECT studentid AS 学生编号, AVG(score) AS 平均分
FROM scoreinfo 
GROUP BY studentid
HAVING AVG(score) > 65;

-- 注意：
-- 1、WHERE子句关注的是行的记录
-- 2、HAVING子句关注的是组的记录

SELECT * FROM scoreinfo HAVING score > 70;
-- 上句可以理解为：
SELECT * FROM scoreinfo GROUP BY scoreid HAVING score > 70;
-- 上句可以理解为：因为按照scoreid这个主键进行分组，每组就是一条记录，对这一条记录使用聚合函数还是它自身
SELECT * FROM scoreinfo GROUP BY scoreid HAVING AVG(score) > 70;
SELECT * FROM scoreinfo GROUP BY scoreid HAVING SUM(score) > 70;
-- 也就等价于
SELECT * FROM scoreinfo WHERE score > 70;

-- 需求：列出单科课程（课程编号）对应的所有同学（多行显示同学编号）
-- 如下写法不正确，因为这样分组后select获取的是每一组的第一条记录
-- 思考：为什么到处使用分组？
SELECT courseid AS 课程编号, studentid AS 学生编号
FROM scoreinfo
GROUP BY courseid;

-- 正确写法：
SELECT courseid AS 课程编号, studentid AS 学生编号
FROM scoreinfo
ORDER BY courseid;
-- 或者
SELECT courseid AS 课程编号, studentid AS 学生编号
FROM scoreinfo
ORDER BY courseid, studentid;

-- 需求：列出单科课程（课程编号）对应的所有同学（单行显示同学编号，多个编号之间以逗号连接）
-- 思路：首先考虑分组，分组后select时使用字符函数CONCAT，但是这样拼接的是每一组的第一条记录中的studentid
-- SELECT courseid AS 课程编号, CONCAT(studentid, ',') AS 学生编号
-- FROM scoreinfo
-- GROUP BY courseid;

-- 到MySQL手册中找灵感，查找了一下和GROUP BY子句相关的内容，看到有GROUP_CONCAT(expr) ：该函数返回带有来自一个组的连接的非NULL值的字符串结果。
SELECT courseid AS 课程编号,  GROUP_CONCAT(studentid) AS 选择该门课程的学生编号
FROM scoreinfo
GROUP BY courseid;

-- 需求：列出单科课程（课程编号）对应的学生人数
SELECT courseid AS 课程编号,  COUNT(studentid) AS 选择该门课程的学生人数
FROM scoreinfo
GROUP BY courseid;

-- 需求：列出单科课程（课程编号）对应的学生人数，并进行总计
-- 思路：总计操作使用 WITH ROLLUP 子句
SELECT courseid AS 课程编号,  COUNT(studentid) AS 选择该门课程的学生人数
FROM scoreinfo
GROUP BY courseid
WITH ROLLUP;

-- 需求：列出单科课程（课程编号）对应的所有学生（单行显示学生编号），并进行总人数的统计（单行显示学生编号）
SELECT courseid AS 课程编号,  GROUP_CONCAT(studentid) AS 选择该门课程的学生编号
FROM scoreinfo
GROUP BY courseid
WITH ROLLUP;


-- ########## 02.LIMIT的使用和分页 ##########
INSERT INTO studentinfo VALUES(NULL, '刘备', '男', 35),(NULL, '关羽', '男', 30),(NULL, '张飞', '男', 25),
(NULL, '貂蝉', '女', 15), (NULL, '吕布', '男', 33),(NULL, '甄姬', '女', 22), (NULL, '董卓', '男', 55);

SELECT * FROM studentinfo;

-- LIMIT的使用：
-- 用法1、LIMIT  起始位置,  记录条数
-- LIMIT的起始位置0表示第一条记录
SELECT * FROM studentinfo LIMIT 0, 3;
SELECT * FROM studentinfo LIMIT 1, 3;
-- 错误代码： 1064    You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near '-1, 3' at line 1
SELECT * FROM studentinfo LIMIT -1, 3;

-- 用法2、LIMIT  记录条数
-- 从第一条记录开始取若干条记录
SELECT * FROM studentinfo LIMIT 0;
SELECT * FROM studentinfo LIMIT 1;
SELECT * FROM studentinfo LIMIT 2;
SELECT * FROM studentinfo LIMIT 3;

-- LIMIT一般用于分页操作
-- 共有7条数据，设置每页3条记录，共分为3页
-- 列出每页的记录来归纳分页的方法：
SELECT COUNT(*) AS 总记录条数 FROM studentinfo;
-- 第1页：第1条、第2条、第3条
SELECT * FROM studentinfo LIMIT 0, 3;
-- 第2页：第4条、第5条、第6条
SELECT * FROM studentinfo LIMIT 3, 3;
-- 第3页：第7条
SELECT * FROM studentinfo LIMIT 6, 1;		-- 此语句执行OK，但是不利于规律的归纳
SELECT * FROM studentinfo LIMIT 6, 3;

-- 从上面的语句进行分析归纳，得出分页的通用方法
-- 考虑制作方法还是从方法的返回值类型 和 参数列表 入手
-- 1、返回值类型就是当前页的数据集合
-- 2、参数列表：对于LIMIT子句来说，就两个参数：初始位置  和   记录条数
-- 		A：记录条数：人为设定每一页的记录的条数
-- 		B：初始位置：变化的值，但是只要知道了当前是第几页，就可以推算出初始位置是多少
--				计算公式：（当前页 - 1）* 记录条数
-- 3、隐含了一个数据需要获取：总页数
-- 		A：总记录条数 % 单页记录条数 == 0 时，总页数 = (总记录条数 / 单页记录条数)
-- 		B：总记录条数 % 单页记录条数 != 0 时，总页数 = (总记录条数 / 单页记录条数) + 1
-- 4、总记录条数： SELECT COUNT(*) AS 总记录条数 FROM studentinfo;



-- ########## 03.插入数据和查询数据的结合操作 ##########
-- 创建学生临时信息表
CREATE TABLE studenttemp
(
	id INT AUTO_INCREMENT PRIMARY KEY,
	`name` VARCHAR(10) NOT NULL,
	gender ENUM('男', '女') NOT NULL
);

SELECT * FROM studenttemp;
SELECT * FROM studentinfo;

-- 需求：把学生信息表中的部分内容查询出来插入到学生临时信息表中
-- 思路：结合使用查询 和 插入
-- INSERT结合查询的写法：INSERT INTO 新表 查询其他表中的数据内容;
INSERT INTO studenttemp(`name`, gender)
SELECT studentname, studentgender FROM studentinfo;

SELECT * FROM studenttemp;

-- 注意：查询出来要插入的数据的数据类型必须和插入表中的字段的数据类型一致（名称可以不一致）


-- ########## 04.子查询 ##########
-- 子查询：在一个查询中包含了另一个查询语句

-- 1、【独立子查询】：先执行子查询，再执行外层查询
-- 使用之前创建的courseinfo表  和  teacherinfo表
INSERT INTO courseinfo VALUES(NULL, '语文', 1), (NULL, '数学', 2), (NULL, '英语', 1);
INSERT INTO teacherinfo VALUES(NULL, '张老师', '男', 60),(NULL, '王老师', '女', 30), (NULL, '李老师', '男', 40);

SELECT * FROM courseinfo;
SELECT * FROM teacherinfo;

-- 需求：列出代课的老师的信息
-- 错误代码： 1242  Subquery returns more than 1 row
-- 分析：下句不是子查询写的不正确，而是这里使用 等号=，到底是去等于子查询查询出来的集合中的哪一条记录呢？
SELECT * FROM teacherinfo 
WHERE teacherid = (SELECT teacherid FROM courseinfo);

-- 正确写法
SELECT * FROM teacherinfo
WHERE teacherid IN (SELECT teacherid FROM courseinfo);

-- 如下写法也正确，但是没有必要这样做，特别对于大量的数据，使用DISTINCT这个去重复的操作非常耗时，除非迫不得已，否则不使用去重复
SELECT * FROM teacherinfo
WHERE teacherid IN (SELECT DISTINCT teacherid FROM courseinfo);

-- 可以按照如下步骤来进行理解：
-- step1、得到集合数据（代课的老师编号）:{ 1, 2, 1 }
SELECT teacherid FROM courseinfo;
-- step2、代课老师的编号是上一步操作中得到的集合中的某一个数据，拿着这个数据到教师信息表中进行筛选
SELECT * FROM teacherinfo WHERE teacherid IN (1, 2, 1);

-- 需求：查找单个学生的所有课程成绩均及格的学生编号  和 学生姓名
-- 显然发生了语义错误：下面的子查询做的事情：
-- 只要这门课程的成绩大于60就筛选留下来了，没有去管这个学生其他课程成绩
SELECT studentid AS 学生编号, studentname AS 学生姓名
FROM studentinfo
WHERE studentid IN (
	SELECT studentid
	FROM scoreinfo
	WHERE score >= 60
);
SELECT * FROM scoreinfo;

-- 正确的写法：
-- 写法1、正向思路：考虑按照学生编号进行分组，取组的最小成绩大于等于60分的同学
SELECT studentid AS 学生编号, studentname AS 学生姓名
FROM studentinfo
WHERE studentid IN (
	SELECT studentid
	FROM scoreinfo
	GROUP BY studentid
	HAVING MIN(score) >= 60
);

-- 写法2、逆向思路：首先，如果考虑正向思考的难度较大，需要知道每个学生选了多少门课程，每门课程的成绩是多少
-- 可以逆向思考一下，所谓所有课程成绩均及格的同学
-- 也就是删除了那些只要有课程不及格就算不及格的同学后剩下的同学
-- 另外还必须是有成绩的同学才是我们要找的那部分同学
SELECT studentid AS 学生编号, studentname AS 学生姓名
FROM studentinfo
WHERE studentid NOT IN (
	-- 至少有一门功课不及格的同学编号
	SELECT studentid
	FROM scoreinfo
	WHERE score < 60
)
-- 有课程成绩的同学编号
AND studentid IN (
	SELECT studentid FROM scoreinfo
);

-- 使用比较运算符的子查询
-- 需求：列出不小于选修了课程编号2的学生学号的学生信息
-- 错误代码： 1242  Subquery returns more than 1 row
SELECT *
FROM studentinfo
WHERE studentid >= (
	SELECT studentid FROM scoreinfo WHERE courseid = 2
);

-- 正确写法：虽然没有大于等于某个范围的关键字或是符号，但是可以大于等于这个范围中最大的那个数据值
SELECT *
FROM studentinfo
WHERE studentid >= (
	SELECT MAX(studentid) FROM scoreinfo WHERE courseid = 2
);

-- 使用EXISTS关键字的子查询：如果子查询查询到了结果，外层的查询才执行；否则的话，外层的查询不执行

-- 需求：有课程成绩大于等于90分的同学就列出全部的学生信息
SELECT *
FROM studentinfo
WHERE EXISTS(SELECT * FROM scoreinfo WHERE score >= 90);

-- 需求：有课程成绩大于90分的同学就列出全部的学生信息
SELECT *
FROM studentinfo
WHERE EXISTS(SELECT * FROM scoreinfo WHERE score > 90);

-- 使用ANY 或 SOME 的子查询

-- 需求：列出学号大于选修了课程编号2的最小的学生学号的学生信息
SELECT *
FROM studentinfo
WHERE studentid >= ANY(
	SELECT studentid FROM scoreinfo WHERE courseid = 2
);
-- 上句等价于下句
SELECT *
FROM studentinfo
WHERE studentid >= (
	SELECT MIN(studentid) FROM scoreinfo WHERE courseid = 2
);
-- 关键字SOME 和 关键字ANY 是同义词
SELECT *
FROM studentinfo
WHERE studentid >= SOME(
	SELECT studentid FROM scoreinfo WHERE courseid = 2
);

-- 使用ALL 的子查询
-- 需求：列出学号不小于所有选修了课程编号2的学生学号的学生信息
SELECT *
FROM studentinfo
WHERE studentid >= ALL(
	SELECT studentid FROM scoreinfo WHERE courseid = 2
);
-- 上句可以理解为：大于等于查询出课程编号2的学生学号这个范围中最大的那个数据值
SELECT *
FROM studentinfo
WHERE studentid >= (
	SELECT MAX(studentid) FROM scoreinfo WHERE courseid = 2
);

-- 结合常见的场景：客户信息 和 订单信息来看看子查询的使用
-- 客户信息表
CREATE TABLE customers
(
	customerid INT AUTO_INCREMENT PRIMARY KEY,
	customername VARCHAR(10) NOT NULL
);

-- 订单信息表
CREATE TABLE orders
(
	orderid INT AUTO_INCREMENT PRIMARY KEY,
	customerid INT NOT NULL,
	-- 金额
	amount DECIMAL(10, 2) NOT NULL,
	-- 订单类型：现金，信用卡
	ordertype VARCHAR(10) NOT NULL
);

INSERT INTO customers VALUES(NULL, '张三'), (NULL, '李四'), (NULL, '王五'), (NULL, '赵六');
INSERT INTO orders VALUES(NULL, 1, 22.25, '现金'), (NULL, 2, 11.75, '信用卡'),(NULL, 2, 5.00, '信用卡'),(NULL, 2, 8.00, '现金'), 
(NULL, 3, 9.33, '信用卡'),(NULL, 3, 10.11, '信用卡');

SELECT * FROM customers;
SELECT * FROM orders;

-- 1、独立子查询作为数据源（包含数据的集合）的使用
-- 需求：以客户为单位，统计每个客户的现金消费总数
-- 1）筛选在分组后做
-- 错误代码： 1054   Unknown column 'ordertype' in 'having clause'
-- 分析：因为按照customerid进行分组形成的每个组中会有不同的ordertype
SELECT customerid AS 客户编号, SUM(amount) AS 现金消费总数
FROM orders
GROUP BY customerid
HAVING ordertype = '现金';
-- 2）筛选在分组前做，考虑使用子查询
-- 错误代码： 1248  Every derived table must have its own alias
SELECT *
FROM (
	SELECT customerid AS 客户编号, SUM(amount) AS 现金消费总数
	FROM orders
	WHERE ordertype = '现金'
	GROUP BY customerid
);
-- 正确写法：
SELECT *
FROM (
	SELECT customerid AS 客户编号, SUM(amount) AS 现金消费总数
	FROM orders
	WHERE ordertype = '现金'
	GROUP BY customerid
) AS temp;

-- 不使用星号通配符，使用具体的字段
-- 错误代码： 1054  Unknown column 'customerid' in 'field list'
SELECT customerid AS 客户编号, SUM(amount) AS 现金消费总数
FROM (
	SELECT customerid AS 客户编号, SUM(amount) AS 现金消费总数
	FROM orders
	WHERE ordertype = '现金'
	GROUP BY customerid
) AS temp;
-- 正确写法：
-- 写法1
SELECT 客户编号, 现金消费总数
FROM (
	SELECT customerid AS 客户编号, SUM(amount) AS 现金消费总数
	FROM orders
	WHERE ordertype = '现金'
	GROUP BY customerid
) AS temp;
-- 写法2
SELECT temp.客户编号, temp.现金消费总数
FROM (
	SELECT customerid AS 客户编号, SUM(amount) AS 现金消费总数
	FROM orders
	WHERE ordertype = '现金'
	GROUP BY customerid
) AS temp;

-- 2、关联子查询
-- 1）在查询条件中使用关联子查询

-- 需求：查询出消费总计小于20元的客户信息
SELECT * FROM orders;
-- 写法1、使用独立子查询
-- 分析后考虑筛选在分组后操作，着眼于以客户编号分出的组的数据上
SELECT *
FROM customers
WHERE customerid IN (
	SELECT customerid
	FROM orders
	GROUP BY customerid
	HAVING SUM(amount) < 20
);
-- 写法2、使用关联子查询
-- 【使用关联子查询时，子查询不再像独立子查询那样可以独立执行，也不再像独立子查询那样先执行】
SELECT *
FROM customers AS c
WHERE (
	SELECT customerid
	FROM orders AS o
	WHERE o.customerid = c.customerid
	GROUP BY o.customerid
	HAVING SUM(o.amount) < 20
);
-- 可以理解为：分步操作，在查询条件中的关联子查询相当于遍历customers表中的每一行记录
-- 第1行记录
SELECT customerid
FROM orders AS o
WHERE o.customerid = 1
GROUP BY o.customerid
HAVING SUM(o.amount) < 20
-- 第2行记录
SELECT customerid
FROM orders AS o
WHERE o.customerid = 2
GROUP BY o.customerid
HAVING SUM(o.amount) < 20
-- 第3行记录（查询到了满足条件的记录，所以留下来）
SELECT customerid
FROM orders AS o
WHERE o.customerid = 3
GROUP BY o.customerid
HAVING SUM(o.amount) < 20
-- 第4行记录
SELECT customerid
FROM orders AS o
WHERE o.customerid = 4
GROUP BY o.customerid
HAVING SUM(o.amount) < 20

-- 2）关联子查询作为一个计算的列

-- 需求：列出客户姓名以及客户的个人消费数量
-- 思路：使用关联子查询from customers这个集合，select一行一行的记录展示出来
-- 		那么，在展示这一行一行记录的时候，对于行中的客户编号，如果能拿着去orders表中做个分组，count一下消费数量就好了
SELECT * FROM orders;

SELECT 
	customername AS 客户姓名,
	(
		SELECT COUNT(o.orderid) AS 消费数量
		FROM orders AS o
		WHERE o.customerid = c.customerid
	) AS 个人消费数量
FROM customers AS c;
-- 可以理解为：分步操作，在列种的关联子查询相当于遍历customers表中的每一行记录
-- 第1行记录
SELECT COUNT(o.orderid) AS 消费数量
FROM orders AS o
WHERE o.customerid = 1
-- 第2行记录
SELECT COUNT(o.orderid) AS 消费数量
FROM orders AS o
WHERE o.customerid = 2
-- 第3行记录
SELECT COUNT(o.orderid) AS 消费数量
FROM orders AS o
WHERE o.customerid = 3
-- 第4行记录
SELECT COUNT(o.orderid) AS 消费数量
FROM orders AS o
WHERE o.customerid = 4

-- 子查询的总结：
-- 1、独立子查询：可以独立执行，且先执行
-- 2、关联子查询：不可以独立执行，且伴随着外层查询的操作，每一次都被调用


                            Day20160718_MySQL.sql
-- ########## 01、表的连接 ##########

-- 常用的场景：部门 和  员工 是一对多的关系，部门是一，员工是多
-- 为了体现这种一对多的关系，在员工信息表中放置部门编号这个字段

-- 部门表
CREATE TABLE dept
(
	id INT AUTO_INCREMENT PRIMARY KEY,
	`name` VARCHAR(20) UNIQUE NOT NULL
);

-- 员工表
CREATE TABLE employee
(
	id INT AUTO_INCREMENT PRIMARY KEY,
	`name` VARCHAR(10) NOT NULL,
	deptid INT NULL
);

-- 模拟数据
INSERT INTO dept VALUES(NULL, '开发部'), (NULL, '销售部'), (NULL, '总经办'), (NULL, '人事部');
INSERT INTO employee VALUES(NULL, '刘备', 1), (NULL, '关羽', 1), (NULL, '张飞', 1),
(NULL, '曹操', 2), (NULL, '郭嘉', 2), (NULL, '荀彧', 2),
(NULL, '孙权', 3), (NULL, '周瑜', 3), (NULL, '陆逊', 3),
(NULL, '孟获', NULL), (NULL, '于吉', 5);

-- 1、交叉连接（CROSS JOIN）：获取笛卡儿积
SELECT * FROM dept;
SELECT * FROM employee;
-- 交叉连接：不加任何限制条件，把两个实体（分别有m条记录和n条记录）进行连接，形成m*n条记录的新的集合
-- 写法1
SELECT * FROM dept, employee;
-- 写法2、显式使用CROSS JOIN关键字（推荐写法）
SELECT * FROM dept CROSS JOIN employee;

-- 2、内连接（INNER JOIN）：在交叉连接上进行条件限制（筛选）

-- 需求：查询出员工信息及其对应的所属部门的名称
-- 分析：上述取得的笛卡儿积没有任何条件的限制，很多数据是没有意义的
-- 		 我们需要根据员工信息表中的部门唯一标识---部门编号，到部门信息表中获取部门的相应信息出来
--		 也就是员工信息表中的部门编号应该和部门信息表中的部门编号对应起来

-- 考虑使用INNER JOIN关键字 和 WHERE子句
SELECT *
FROM dept
INNER JOIN employee
WHERE dept.id = employee.deptid;
-- 改进
SELECT employee.id AS 员工编号, employee.name AS 员工姓名, dept.name AS 部门名称
FROM dept
INNER JOIN employee
WHERE dept.id = employee.deptid;
-- 可以理解为：首先取得交叉连接的笛卡尔积，再针对笛卡儿积使用条件限制，就得到了内连接的结果
SELECT employee.id AS 员工编号, employee.name AS 员工姓名, dept.name AS 部门名称
FROM dept
CROSS JOIN employee
WHERE dept.id = employee.deptid;
-- 上述写法等价于
SELECT employee.id AS 员工编号, employee.name AS 员工姓名, dept.name AS 部门名称
FROM dept, employee
WHERE dept.id = employee.deptid;
-- 对于连接的对应关系的描述，SQL中提供了ON关键字
SELECT employee.id AS 员工编号, employee.name AS 员工姓名, dept.name AS 部门名称
FROM dept
INNER JOIN employee
ON dept.id = employee.deptid;

-- 3、外连接（OUTER JOIN）
-- 理解：这里的外，是针对作为重点的那个集合而言的

-- 1）左外连接/左连接（LEFT OUTER JOIN/LEFT JOIN）：
-- 以左边的表为主，右边的表中能匹配的上的数据列出来，匹配不上的显示为NULL值
-- 2）右外连接/右连接（RIGHT OUTER JOIN/RIGHT JOIN）：
-- 以右边的表为主，左边的表中能匹配的上的数据列出来，匹配不上的显示为NULL值

-- 需求：列出公司全部的部门以及部门的员工信息（多行显示）
-- 分析：重点在全部的部门，另外要列出的是全部部门中每个部门对应的员工的信息
-- 		 隐含的意思，哪怕这个部门没有员工，也要列出这个部门来，没有员工时，员工信息就显示为NULL值
-- 		 但是员工没有部门的，不考虑
SELECT *
FROM dept 
LEFT OUTER JOIN employee
ON dept.id = employee.deptid;
-- 写法1、使用LEFT OUTER JOIN
SELECT dept.name AS 部门名称, employee.id AS 员工编号, employee.name AS 员工姓名
FROM dept 
LEFT OUTER JOIN employee
ON dept.id = employee.deptid;
-- 写法2、使用LEFT JOIN
SELECT dept.name AS 部门名称, employee.id AS 员工编号, employee.name AS 员工姓名
FROM dept 
LEFT JOIN employee
ON dept.id = employee.deptid;

-- 需求：列出公司全部的员工以及员工的部门信息
-- 分析：重点在全部的员工上，另外要列出的是全部员工中每个员工对应的部门的信息
-- 隐含的意思，哪怕这个员工没有部门，也要列出这个员工来，没有部门时，部门信息就显示为NULL值
-- 写法1、使用左连接写法
SELECT employee.id AS 员工编号, employee.name AS 员工姓名, dept.name AS 部门名称
FROM employee 
LEFT JOIN dept
ON dept.id = employee.deptid;
-- 写法2、使用右连接写法
SELECT employee.id AS 员工编号, employee.name AS 员工姓名, dept.name AS 部门名称
FROM dept 
RIGHT OUTER JOIN employee
ON dept.id = employee.deptid;
-- 简化
SELECT employee.id AS 员工编号, employee.name AS 员工姓名, dept.name AS 部门名称
FROM dept 
RIGHT JOIN employee
ON dept.id = employee.deptid;

-- 4、自连接（内连接的变体）

-- 需求：设计公司的组织架构信息表（这种设计很重要：必须掌握）
-- 陈氏国际
-- 		陈氏中国
-- 			陈氏安徽
-- 			陈氏北京
-- 			陈氏上海
-- 		陈氏美国
-- 			陈氏纽约
-- 			陈氏德州
-- 		陈氏日本
-- 			陈氏关东
-- 			陈氏关西

-- 考虑树形结构来进行描述，描述树结构上的节点的位置，需要描述其当前的节点和它的父节点，这样才能确定它的位置

-- 公司组织结构信息表
CREATE TABLE companyinfo
(
	-- 组织编号
	id INT AUTO_INCREMENT PRIMARY KEY,
	-- 组织名称
	`name` VARCHAR(10) NOT NULL,
	-- 组织父编号
	pid INT NOT NULL
);
-- 模拟数据
INSERT INTO companyinfo VALUES(NULL, '陈氏国际', 0),
(NULL, '陈氏中国', 1), (NULL, '陈氏美国', 1), (NULL, '陈氏日本', 1),
(NULL, '陈氏安徽', 2), (NULL, '陈氏北京', 2), (NULL, '陈氏上海', 2),
(NULL, '陈氏纽约', 3), (NULL, '陈氏德州', 3), 
(NULL, '陈氏关东', 4), (NULL, '陈氏关西', 4);

SELECT * FROM companyinfo;

-- 需求：根据给定的组织名称查看其组织编号及其下一级
-- 思路：首先按给定的组织名称获取其组织编号，再拿着这个组织编号作为pid父编号在表中查询，得到其下一级

-- 分步操作如下：
-- Step1、首先按给定的组织名称获取其组织编号
SELECT id AS 组织编号, `name` AS 组织名称
FROM companyinfo
WHERE `name` = '陈氏中国';
-- Step2、拿着这个组织编号作为pid父编号在表中查询，得到其下一级
SELECT id AS 下一级组织编号, `name` AS 下一级组织名称
FROM companyinfo
WHERE pid = 2;

-- 不使用分步操作，使用自连接，将组织信息表集合1的编号 和 组织信息表集合2的父编号进行匹配
-- 也就是把左表的编号作为右表的父编号进行匹配
SELECT *
FROM companyinfo AS c1
INNER JOIN companyinfo AS c2
ON c1.id = c2.pid;

-- 考虑到需求要根据给定的组织名称查看其组织编号及其下一级
-- 错误代码： 1052    Column 'name' in where clause is ambiguous  name列在where子句中有歧义（因为有多个name字段）
SELECT *
FROM companyinfo AS c1
INNER JOIN companyinfo AS c2
ON c1.id = c2.pid
WHERE `name` = '陈氏中国';

-- 正确写法1、筛选条件中使用ON 和 WHERE
SELECT c1.id AS 组织编号, c1.`name` AS 组织名称, c2.`name` AS 下一级组织名称
FROM companyinfo AS c1
INNER JOIN companyinfo AS c2
ON c1.id = c2.pid
WHERE c1.`name` = '陈氏中国';

-- 正确写法2、筛选条件中只使用ON
SELECT c1.id AS 组织编号, c1.`name` AS 组织名称, c2.`name` AS 下一级组织名称
FROM companyinfo AS c1
INNER JOIN companyinfo AS c2
ON c1.id = c2.pid AND c1.`name` = '陈氏中国';

-- 正确写法3、筛选条件中只使用WHERE
SELECT c1.id AS 组织编号, c1.`name` AS 组织名称, c2.`name` AS 下一级组织名称
FROM companyinfo AS c1
INNER JOIN companyinfo AS c2
WHERE c1.id = c2.pid AND c1.`name` = '陈氏中国';

-- 需求：查看一级组织（一级子公司）及其下一级组织（多行显示）
SELECT c1.id AS 组织编号, c1.`name` AS 一级组织名称, c2.`name` AS 下一级组织名称
FROM companyinfo AS c1
INNER JOIN companyinfo AS c2
WHERE c1.id = c2.pid AND c1.pid = 1;

-- 需求：查看一级组织（一级子公司）及其下一级组织（单行显示）
SELECT temp.一级组织名称 AS 一级组织名称, GROUP_CONCAT(temp.下一级组织名称) AS 下一级组织名称
FROM
(
	SELECT c1.`name` AS 一级组织名称, c2.`name` AS 下一级组织名称
	FROM companyinfo AS c1
	INNER JOIN companyinfo AS c2
	WHERE c1.id = c2.pid AND c1.pid = 1
) AS temp
GROUP BY temp.一级组织名称;


-- ########## 02、集合逻辑 ##########

-- MySQL中，只实现了一种集合逻辑：逻辑与，有两种用法：UNION 和 UNION ALL

-- 临时表1
CREATE TABLE temp1
(
	id INT NOT NULL
);

-- 临时表2
CREATE TABLE temp2
(
	id INT NOT NULL
);

-- 模拟数据
INSERT INTO temp1 VALUES(1),(2);
INSERT INTO temp2 VALUES(2),(3);

SELECT * FROM temp1;
SELECT * FROM temp2;

-- UNION：进行逻辑与的集合中相同的元素在结果中出现一次
(
	SELECT * FROM temp1
)
UNION
(
	SELECT * FROM temp2
);

-- UNION ALL：进行逻辑与的集合中相同的元素在结果中都出现
(
	SELECT * FROM temp1
)
UNION ALL
(
	SELECT * FROM temp2
);

-- 对使用UNION 或 UNION ALL的结果这个集合进行查询操作
SELECT *
FROM
(
	(
		SELECT * FROM temp1
	)
	UNION
	(
		SELECT * FROM temp2
	)
) AS temp;

SELECT *
FROM
(
	(
		SELECT * FROM temp1
	)
	UNION ALL
	(
		SELECT * FROM temp2
	)
) AS temp;


-- ########## 03、视图（View） ##########

-- 视图：View，从其他表中抽取部分 或 全部字段形成的一种映射，在某种程度上可以理解为临时表
-- 使用场景：一般用于方便查询

-- 创建视图的格式：
-- create view 视图名称
-- AS
-- ...

-- 需求：查询学生信息（涉及学生姓名 和 学生性别），只给使用者查看两列字段的内容
-- 创建视图
CREATE VIEW vw_studentinfo
AS
SELECT studentname AS 学生姓名, studentgender AS 学生性别 
FROM studentinfo;

-- 使用视图进行查询
SELECT * FROM vw_studentinfo;

-- 使用视图进行新增
-- 错误代码： 1423   Field of view 'test.vw_studentinfo' underlying table doesn't have a default value
INSERT INTO vw_studentinfo VALUES('孙权', '男');
SELECT * FROM studentinfo;

-- 使用视图进行修改
UPDATE vw_studentinfo SET 学生性别 = '女' WHERE 学生姓名 = '关羽';
-- 修改的操作可以执行成功，注意：对视图中数据的修改最终反映在视图基于的原表的数据中
SELECT * FROM vw_studentinfo;
SELECT * FROM studentinfo;

-- 使用视图进行删除
DELETE FROM vw_studentinfo WHERE 学生姓名 = '关羽';
-- 删除的操作可以执行成功，注意：对视图中数据的删除最终反映在视图基于的原表的数据中
SELECT * FROM vw_studentinfo;
SELECT * FROM studentinfo;

-- 需求：查询部门信息及部门对应的员工信息
CREATE VIEW vw_dept_employee
AS
SELECT d.id AS 部门编号, d.`name` AS 部门名称, e.`name` AS 员工姓名
FROM dept AS d
LEFT JOIN employee AS e
ON d.id = e.deptid;

-- 使用视图进行查询
SELECT * FROM vw_dept_employee;

-- 使用视图进行新增
-- 错误代码： 1394   Can not insert into join view 'test.vw_dept_employee' without fields list
INSERT INTO vw_dept_employee VALUES(NULL, '后勤部', '祝融');

-- 使用视图进行修改
UPDATE vw_dept_employee SET 部门名称 = '人力资源部' WHERE 部门编号 = 4;
SELECT * FROM vw_dept_employee;
SELECT * FROM dept;

-- 错误代码： 1393  Can not modify more than one base table through a join view 'test.vw_dept_employee'   使用连接视图不能修改超过一个基础表中的数据
UPDATE vw_dept_employee SET 部门名称 = '通宵部', 员工姓名='张宇' WHERE 员工姓名='张飞';
-- 下句修改一个基础表的数据内容，可以执行成功
UPDATE vw_dept_employee SET 员工姓名='张宇' WHERE 员工姓名='张飞';
SELECT * FROM vw_dept_employee;
SELECT * FROM employee;

-- 错误代码： 1395  Can not delete from join view 'test.vw_dept_employee'   连接视图不给删除数据
DELETE FROM vw_dept_employee WHERE 员工姓名='张宇';

-- 视图的意义：封装性的体现
-- 使用者不需要知道数据的内在逻辑，也不需要会高深的SQL语法，只要拿着视图就可以使用，方便使用，降低了开发难度，也保证了数据安全性


-- ########## 04、事务（Transaction） ##########
-- 事务的理解：一件事情的处理需要多个步骤，当多个步骤中的某一个步骤发生异常时，考虑接着如果处理这件事情是恢复到最初始的状态
-- 			   还是恢复到之前的某一个状态，或者继续做下去的机制
-- 			   从操作的简洁性上考虑，将这件事情恢复到最初始的状态，再重新执行，是最简单的处理方式

-- 术语：在事情的处理过程中，从某一个后续的状态恢复至之前的某一个状态的动作，称为事务的回滚（rollback）
-- 类比：小学体育课上的翻垫子

-- MySQL是支持事务的关系型数据库（安装时选择支持事务的数据库引擎InnoDB）
-- 事务常常用在增加、修改、删除（DML）操作中

CREATE TABLE test
(
	id INT
);

-- MySQL中的事务处理有两种方式：
-- 方式1、使用BEGIN、ROLLBACK、COMMIT关键字来实现
-- BEGIN：开始事务
-- ROLLBACK：事务回滚
-- COMMIT：事务确认

BEGIN;
INSERT INTO test VALUES(1);
INSERT INTO test VALUES(2);

-- 先执行BEGIN及后面2条插入语句，再执行下句，可以查询出2条记录
SELECT * FROM test;

BEGIN;
INSERT INTO test VALUES(3);
INSERT INTO test VALUES(4);
COMMIT;

-- 先执行BEGIN及后面2条插入语句以及COMMIT，再执行下句，可以查询出4条记录（前2条记录是上一步操作插入的）
SELECT * FROM test;

-- 发现插入后，写COMMIT语句和不写COMMIT语句效果一致

BEGIN;
INSERT INTO test VALUES(5);
ROLLBACK;

-- 先执行BEGIN及后面1条插入语句以及ROLLBACK，再执行下句，可以查询出4条记录（前2条记录是上一步操作插入的）
-- 394行的插入是无效的，被395行回滚了
SELECT * FROM test;


-- 方式2、首先设置MySQL的自动提交参数为否
-- 设置MySQL的自动提交参数为否，也就是说需要手动提交
SET AUTOCOMMIT = 0;

INSERT INTO test VALUES(6);

-- 在当前的SQLyog客户端中查询test表，显示数值6已经插入进去了，但是这是假象
-- 在命令行窗口中查询test表，数值6不存在
-- select * from test;

-- 既然设置了AUTOCOMMIT为0，禁止自动提交，那么久需要显式的手动提交
COMMIT;

-- 手动提交后，不论在当前的SQLyog客户端中查看test表，还是在命令行窗口中查看test表，数值6真的插入进去了
SELECT * FROM test;

-- 操作后恢复默认设置
SET AUTOCOMMIT = 1;


-- ########## 05、存储过程（Stored Procedure） ##########
-- 存储过程：Stored Procedure
-- 数据库中的SQL语句在执行时都是需要先编译再执行的，存储过程就是这样一组为了完成特定功能的SQL语句
-- 存储过程经过编译存储在数据库中，使用者通过制定存储过程的名称并给定参数来进行调用执行

-- 格式：
-- create procedure 存储过程名([参数1, 参数2, ...])
-- [特性]
-- 过程体

-- 存储过程的创建和使用：
-- 1、首先需要使用DELIMITER关键字声明分隔符，因为MySQL中默认以;作为分隔符
-- 	  所以如果没有再声明一个分隔符，编译器就会把存储过程当作MySQL的SQL语句来进行处理
-- 	  那样存储过程的编译过程就会出错
--	  注意：使用完成后需要把分隔符再还原回去
-- 2、存储过程根据参数的有无分为  无参、有参输入、有参输出  三种

SELECT * FROM userinfo;
TRUNCATE TABLE userinfo;
INSERT INTO userinfo VALUES(1, '诸葛亮', '888'), (2, '司马懿', '666');

-- 1、无参的存储过程
-- 声明分隔符为$$
DELIMITER $$
CREATE PROCEDURE proc_select_userinfo()
-- 使用BEGIN...END语句块
BEGIN
	SELECT * FROM userinfo;
END
-- 下句使用声明的分隔符，表明到这里都是需要编译的存储过程的内容，不需要执行
$$
-- 使用完毕后，再把分隔符还原为;
DELIMITER ;

-- 调用存储过程：CALL 存储过程名
CALL proc_select_userinfo();

-- 2、输入参数的存储过程
-- 声明分隔符为$$
DELIMITER $$
CREATE PROCEDURE proc_select_userinfo_by_id(IN _id INT)
-- 使用BEGIN...END语句块
BEGIN
	SELECT *
	FROM userinfo
	WHERE userid = _id;
END
-- 下句使用声明的分隔符，表明到这里都是需要编译的存储过程的内容，不需要执行
$$
-- 使用完毕后，再把分隔符还原为;
DELIMITER ;

-- 调用存储过程：CALL 存储过程名(输入参数值)
CALL proc_select_userinfo_by_id(1);
-- 下句可以在其他窗口（比如：命令行窗口）中执行
CALL proc_select_userinfo_by_id(2);


-- 3、输出参数的存储过程
-- 声明分隔符为$$
DELIMITER $$
CREATE PROCEDURE proc_select_count_userinfo(OUT _number INT)
-- 使用BEGIN...END语句块
BEGIN
	SELECT COUNT(*) INTO _number
	FROM userinfo;
END
-- 下句使用声明的分隔符，表明到这里都是需要编译的存储过程的内容，不需要执行
$$
-- 使用完毕后，再把分隔符还原为;
DELIMITER ;

-- 调用存储过程：需要定义一个变量用于接收输出参数结果
-- MySQL中定义变量格式：SET @变量名  
SET @outparam = 1;
CALL proc_select_count_userinfo(@outparam);
-- 把操作后的变量当作直接量使用
SELECT @outparam AS 记录条数;


				Day20160719_MySQL.sql
-- ########## 综合练习 ##########

-- 使用的表结构来自前面创建的"教师授课、学生选课并有课程成绩"这个数据库设计
-- studentinfo、courseinfo、teacherinfo、scoreinfo
-- 老师信息实体
CREATE TABLE teacherinfo
(
	-- 老师编号
	teacherid INT AUTO_INCREMENT PRIMARY KEY,
	-- 老师姓名
	teachername VARCHAR(10) NOT NULL,
	-- 老师性别
	teachergender ENUM('男', '女') NOT NULL,
	-- 老师年龄
	teacherage INT NOT NULL
);
-- 学生信息实体
CREATE TABLE studentinfo
(
	-- 学生编号
	studentid INT AUTO_INCREMENT PRIMARY KEY,
	-- 学生姓名
	studentname VARCHAR(10) NOT NULL,
	-- 学生性别
	studentgender ENUM('男', '女') NOT NULL,
	-- 学生年龄
	studentage INT NOT NULL
);
CREATE TABLE courseinfo
(
	-- 课程编号
	courseid INT AUTO_INCREMENT PRIMARY KEY,
	-- 课程名称
	coursename VARCHAR(10) NOT NULL,
	-- 老师编号
	teacherid INT NOT NULL
);
CREATE TABLE scoreinfo
(
	-- 成绩编号
	scoreid INT AUTO_INCREMENT PRIMARY KEY,
	-- 学生编号
	studentid INT NOT NULL,
	-- 课程编号
	courseid INT NOT NULL,
	-- 成绩分数
	score DECIMAL(4, 1)
);


INSERT INTO courseinfo VALUES(NULL, '语文', 1), (NULL, '数学', 2), (NULL, '英语', 1);
INSERT INTO teacherinfo VALUES(NULL, '张老师', '男', 60),(NULL, '王老师', '女', 30), (NULL, '李老师', '男', 40);
INSERT INTO studentinfo VALUES(NULL, '刘备', '男', 35),(NULL, '关羽', '男', 30),(NULL, '张飞', '男', 25),
(NULL, '貂蝉', '女', 15), (NULL, '吕布', '男', 33),(NULL, '甄姬', '女', 22);
-- 模拟数据
INSERT INTO scoreinfo VALUES(NULL, 1, 1, 60), (NULL, 1, 2, 90),(NULL, 1, 3, 80),(NULL, 1, 4, 70),(NULL, 1, 5, 40),
(NULL, 2, 1, 70), (NULL, 2, 2, 50),(NULL, 2, 3, 70),(NULL, 2, 4, 30),(NULL, 2, 5, 90),
(NULL, 3, 1, 55), (NULL, 3, 2, 65),(NULL, 3, 3, 75),
(NULL, 4, 1, 87),(NULL, 4, 2, 63),(NULL, 4, 4, 28);

SELECT * FROM studentinfo;
SELECT * FROM courseinfo;
SELECT * FROM teacherinfo;
SELECT * FROM scoreinfo;

-- 1、查询姓张的老师的数量
SELECT COUNT(teacherid) AS 姓张的老师的数量
FROM teacherinfo
WHERE teachername LIKE '张%';

-- 2、查询每门功课选修的学生数量
-- 写法1、使用左连接
SELECT c.`coursename` AS 课程名称, temp.选修的学生数量
FROM courseinfo AS c
LEFT JOIN 
(
	SELECT courseid, COUNT(studentid) AS 选修的学生数量
	FROM scoreinfo
	GROUP BY courseid
) AS temp
ON c.`courseid` = temp.courseid;
-- 写法2、使用子查询
SELECT
	c.`coursename` AS 课程名称, 
	(
		SELECT COUNT(studentid)
		FROM scoreinfo AS sc
		WHERE sc.courseid = c.`courseid`
	) AS 选修的学生数量
FROM courseinfo AS c;

-- 3、查询个人平均成绩高于60分的学生编号、学生姓名 和 个人平均成绩（如果得到的人数超过2人，显示第二条记录和第三条记录）
SELECT temp.studentid AS 学生编号, s.`studentname` AS 学生姓名, temp.个人平均成绩
FROM 
(
	SELECT studentid, AVG(score) AS 个人平均成绩
	FROM scoreinfo
	GROUP BY studentid
	HAVING AVG(score) > 60
) AS temp
LEFT JOIN studentinfo AS s
ON temp.studentid = s.`studentid`
LIMIT 1, 2;

-- 4、查询男生的人数 和 女生的人数
SELECT studentgender AS 性别, COUNT(studentid) AS 人数
FROM studentinfo
GROUP BY studentgender;

-- 5、查询同名同姓的学生人数
SELECT * FROM studentinfo;
INSERT INTO studentinfo VALUES(NULL, '甄姬', '女', 38);

SELECT studentname AS 学生姓名, COUNT(studentid) AS 学生人数
FROM studentinfo
GROUP BY studentname
HAVING COUNT(studentid) > 1;

-- 6、查询每门功课的平均成绩，结果按每门功课平均成绩升序排列，成绩相同时，按课程编号倒序排列
SELECT c.`coursename` AS 课程名称, temp.平均成绩
FROM courseinfo AS c
LEFT JOIN
(
	SELECT courseid, AVG(score) AS 平均成绩
	FROM scoreinfo
	GROUP BY courseid
) AS temp
ON c.`courseid` = temp.courseid
ORDER BY temp.平均成绩 ASC, c.`courseid` DESC;

-- 7、查询课程名称为数学，且数学成绩低于60分的学生姓名和分数
SELECT c.`coursename` AS 课程名称, s.`studentname` AS 学生姓名, sc.`score` AS 成绩分数
FROM scoreinfo AS sc
INNER JOIN courseinfo AS c ON sc.`courseid` = c.`courseid` AND c.`coursename` = '数学' AND sc.`score` < 60
INNER JOIN studentinfo AS s ON sc.`studentid` = s.`studentid`;

-- 8、查询所有学生的选课信息（显示为：学生编号、学生姓名、课程名称）
SELECT s.`studentid` AS 学生编号, s.`studentname` AS 学生姓名, c.`coursename` AS 课程名称
FROM studentinfo AS s
LEFT JOIN scoreinfo AS sc ON s.`studentid` = sc.`studentid`
LEFT JOIN courseinfo AS c ON c.`courseid` = sc.`courseid`;

-- 9、查询任何一门课程成绩在60分以上的学生姓名、课程名称及成绩
SELECT s.`studentname` AS 学生姓名, c.`coursename` AS 课程名称, sc.`score` AS 成绩分数
FROM scoreinfo AS sc
INNER JOIN courseinfo AS c ON sc.`courseid` = c.`courseid`
INNER JOIN studentinfo AS s ON sc.`studentid` = s.`studentid`
WHERE sc.`score` > 60;

-- 10、查询至少选修了两门课程的学生信息
-- 写法1、使用独立子查询
SELECT s.`studentid` AS 学生编号, s.`studentname` AS 学生姓名, s.`studentgender` AS 学生性别, s.`studentage` AS 学生年龄
FROM studentinfo AS s
WHERE s.`studentid` IN
(
	SELECT studentid
	FROM scoreinfo
	GROUP BY studentid
	HAVING COUNT(courseid) >= 2
);
-- 写法2、使用内连接
SELECT s.`studentid` AS 学生编号, s.`studentname` AS 学生姓名, s.`studentgender` AS 学生性别, s.`studentage` AS 学生年龄
FROM studentinfo AS s
INNER JOIN 
(
	SELECT studentid
	FROM scoreinfo
	GROUP BY studentid
	HAVING COUNT(courseid) >= 2
) AS temp
ON s.`studentid` = temp.studentid;

-- 11、查询全部学生都选修了的课程编号以及课程名称（基于无脏数据）
SELECT courseid AS 课程编号, coursename AS 课程名称
FROM courseinfo
WHERE courseid IN
(
	-- 在成绩信息表中，按课程编号分组，统计每组的学生编号数量，看看哪组的数量和学生信息表中学生数量一致
	SELECT courseid
	FROM scoreinfo
	GROUP BY courseid
	HAVING	COUNT(studentid) = (SELECT COUNT(studentid) FROM studentinfo)
);

-- 12、查询个人的英语成绩比数学成绩高的学生信息
-- 思路：在成绩信息表中对行数据进行获取比较，操作起来比较麻烦
-- 		考虑进行【行转列】的操作，这样就可以在一行中对不同的列的内容进行比较
-- 		【行转列】技巧的理解：分别从成绩信息表中通过课程名称对应的课程编号获得两个独立的集合
-- 		再把这两个集合根据学生编号进行内连接，就得到了同一行中有不同课程成绩的新集合
-- 【行转列】的技巧必须掌握
SELECT s.`studentid` AS 学生编号, s.`studentname` AS 学生姓名, s.`studentgender` AS 学生性别, s.`studentage` AS 学生年龄
FROM studentinfo AS s
WHERE s.`studentid` IN
(
	SELECT temp1.studentid
	FROM 
	(
		SELECT studentid, score
		FROM scoreinfo
		WHERE courseid = (SELECT courseid FROM courseinfo WHERE coursename = '英语')
	) AS temp1
	INNER JOIN 
	(
		SELECT studentid, score
		FROM scoreinfo
		WHERE courseid = (SELECT courseid FROM courseinfo WHERE coursename = '数学')
	) AS temp2
	ON temp1.studentid = temp2.studentid AND temp1.score > temp2.score
);

-- 13、查询所有学生的编号、姓名、选课数量、总成绩
SELECT
	s.`studentid` AS 学生编号,
	s.`studentname` AS 学生姓名,
	COUNT(sc.courseid) AS 选课数量,
	SUM(sc.score) AS 总成绩
FROM studentinfo AS s
LEFT JOIN scoreinfo AS sc ON s.`studentid` = sc.`studentid`
-- 按照学生编号进行分组，语法OK
GROUP BY s.`studentid`;
-- 按照学生编号和学生姓名进行分组，语法也是OK，因为studentid是主键，就可以唯一标识记录了，加上studentname属于锦上添花
-- group by s.`studentid`, s.`studentname`;
-- 按照学生姓名进行分组，语法不是OK，因为学生姓名有重名时，就会分到一组中了
-- group by s.`studentname`;

-- 14、查询没有选修过张老师课程的学生信息
-- 思路：没有选修张老师课程的学生有两种：选修了课程但是选的不是张老师课程的学生  和  没有选修课程的学生
-- 		这里正向思考比较麻烦，所以考虑逆向思考
-- 		从学生集合中剔除那些选了张老师课程的学生，剩下的就是没有选修张老师课程的学生
SELECT s.`studentid` AS 学生编号, s.`studentname` AS 学生姓名, s.`studentgender` AS 学生性别, s.`studentage` AS 学生年龄
FROM studentinfo AS s
WHERE s.`studentid` NOT IN
(
	-- 选修了课程但是选的是张老师课程的学生
	SELECT sc.`studentid`
	FROM scoreinfo AS sc
	INNER JOIN courseinfo AS c ON sc.`courseid` = c.`courseid`
	INNER JOIN teacherinfo AS t ON c.`teacherid` = t.`teacherid` AND t.`teachername` = '张老师'
);

-- 15、查询学过语文也学过数学的学生信息
SELECT s.`studentid` AS 学生编号, s.`studentname` AS 学生姓名, s.`studentgender` AS 学生性别, s.`studentage` AS 学生年龄
FROM studentinfo AS s
INNER JOIN scoreinfo AS sc1 
ON s.`studentid` = sc1.`studentid` AND sc1.`courseid` = (SELECT courseid FROM courseinfo WHERE coursename = '语文')
INNER JOIN scoreinfo AS sc2
ON s.`studentid` = sc2.`studentid` AND sc2.`courseid` = (SELECT courseid FROM courseinfo WHERE coursename = '数学');

-- 16、查询个人成绩中每门功课都不及格的学生信息
-- 可能性1、无成绩的也算满足条件
SELECT s.`studentid` AS 学生编号, s.`studentname` AS 学生姓名, s.`studentgender` AS 学生性别, s.`studentage` AS 学生年龄
FROM studentinfo AS s
WHERE s.`studentid` NOT IN
(
	SELECT studentid
	FROM scoreinfo
	WHERE score >= 60
);
-- 可能性2、无成绩的不算满足条件
SELECT s.`studentid` AS 学生编号, s.`studentname` AS 学生姓名, s.`studentgender` AS 学生性别, s.`studentage` AS 学生年龄
FROM studentinfo AS s
WHERE s.`studentid` IN
(
	-- 如下写法不正确：因为这样会把部分课程不及格部分课程及格的同学也筛选出来
	-- select studentid
	-- 	from scoreinfo
	-- 	where score < 60

	-- 正确写法：按照学生编号分组，分组后组里最高的课程分数还小于60分，意味着所有课程都不及格
	SELECT studentid
	FROM scoreinfo
	GROUP BY studentid
	HAVING MAX(score) < 60
);

-- 17、查询每门功课的分数段人数，显示为：课程编号、课程名称、选课人数、[优秀90~100]、[良好80~90]、[一般70~80]、[及格60~70]、[不及格0~60]
SELECT 
	sc.`courseid` AS 课程编号,
	c.`coursename` AS 课程名称,
	COUNT(sc.`studentid`) AS 选课人数,
	SUM(CASE WHEN sc.score >= 90 AND sc.score <= 100 THEN 1 ELSE 0 END) AS `[优秀90~100]`,
	SUM(CASE WHEN sc.score >= 80 AND sc.score < 90 THEN 1 ELSE 0 END) AS `[良好80~90]`,
	SUM(CASE WHEN sc.score >= 70 AND sc.score < 80 THEN 1 ELSE 0 END) AS `[一般70~80]`,
	SUM(CASE WHEN sc.score >= 60 AND sc.score < 70 THEN 1 ELSE 0 END) AS `[及格60~70]`,
	SUM(CASE WHEN sc.score >= 0 AND sc.score < 60 THEN 1 ELSE 0 END) AS `[不及格0~60]`
FROM scoreinfo AS sc
INNER JOIN courseinfo AS c ON c.`courseid` = sc.`courseid`
GROUP BY sc.`courseid`;

-- 18、查询没有选修全部课程的学生信息
SELECT s.`studentid` AS 学生编号, s.`studentname` AS 学生姓名, s.`studentgender` AS 学生性别, s.`studentage` AS 学生年龄
FROM studentinfo AS s
WHERE s.`studentid` IN
(
	-- 按学生编号分组，每组中的课程统计数量小于课程信息表中课程数量的就是没有选修全部课程的学生
	SELECT studentid
	FROM scoreinfo
	GROUP BY studentid
	HAVING COUNT(courseid) < (SELECT COUNT(courseid) FROM courseinfo)
);

-- 19、查询和刘备（学生编号1）至少一起选修了一门课程的学生编号和学生姓名
SELECT s.`studentid` AS 学生编号, s.`studentname` AS 学生姓名, s.`studentgender` AS 学生性别, s.`studentage` AS 学生年龄
FROM studentinfo s
WHERE studentid IN
(
	-- 至少和刘备一起选修了一门课程
	SELECT studentid
	FROM scoreinfo
	WHERE courseid IN
	(
		-- 查询出刘备选的课程
		SELECT courseid
		FROM scoreinfo AS sc
		INNER JOIN studentinfo AS s
		ON s.`studentid` = sc.`studentid` AND s.`studentid` = 1 AND s.`studentname` = '刘备'
	)
);

-- 20、查询和张飞（学生编号3）选修的课程完全相同的学生编号和学生姓名
-- 思路：
-- 1）首先制作两个成绩信息表的连接，右表为张飞（学生编号3）的课程及成绩
-- 此时会得到完全和张飞课程相同的学生 和 部分和张飞课程相同的学生
SELECT sc1.*, sc2.*
FROM scoreinfo AS sc1
INNER JOIN scoreinfo AS sc2 ON sc1.`courseid` = sc2.`courseid` AND sc2.studentid = 3 AND sc1.`studentid` <> sc2.`studentid`;
-- 2）在此基础上，在新生成的集合中按照学生编号进行分组，如果有学生的课程数量和张飞的课程数量一致的，那就是和张飞（学生编号3）选修的课程完全相同的学生
SELECT s.`studentid` AS 学生编号, s.`studentname` AS 学生姓名, s.`studentgender` AS 学生性别, s.`studentage` AS 学生年龄
FROM studentinfo AS s
WHERE s.`studentid` IN
(
	SELECT sc1.`studentid`
	FROM scoreinfo AS sc1
	INNER JOIN scoreinfo AS sc2 ON sc1.`courseid` = sc2.`courseid` AND sc2.studentid = 3 AND sc1.`studentid` <> sc2.`studentid`
	GROUP BY sc1.`studentid`, sc2.`studentid`
	HAVING COUNT(sc1.`courseid`) = (SELECT COUNT(courseid) FROM scoreinfo WHERE studentid = 3)
);

-- 21、按个人平均成绩降序排列显示学生的语文、数学、英语三门功课的成绩（选修了几门计算几门的平均分，未选修的课程显示未选）
--     显示为：学生编号、学生姓名、平均成绩、语文成绩、数学成绩、英语成绩
SELECT
	sc.`studentid` AS 学生编号,
	s.`studentname` AS 学生姓名,
	AVG(sc.`score`) AS 平均成绩,
	IFNULL((
		SELECT sc1.score
		FROM scoreinfo AS sc1
		WHERE sc1.studentid = sc.`studentid`
		AND sc1.courseid = (SELECT courseid FROM courseinfo WHERE coursename = '语文')
	), '未选') AS 语文成绩,
	IFNULL((
		SELECT sc2.score
		FROM scoreinfo AS sc2
		WHERE sc2.studentid = sc.`studentid`
		AND sc2.courseid = (SELECT courseid FROM courseinfo WHERE coursename = '数学')
	), '未选') AS 数学成绩,
	IFNULL((
		SELECT sc3.score
		FROM scoreinfo AS sc3
		WHERE sc3.studentid = sc.`studentid`
		AND sc3.courseid = (SELECT courseid FROM courseinfo WHERE coursename = '英语')
	), '未选') AS 英语成绩
FROM scoreinfo AS sc
INNER JOIN studentinfo AS s ON sc.`studentid` = s.`studentid`
GROUP BY sc.`studentid`
-- order by AVG(sc.`score`) desc;
-- 上面写法和下面写法均可以，因为ORDER BY子句在SELECT子句之后执行
ORDER BY 平均成绩 DESC;

-- 22、查询每门功课的最高分和最低分，显示为：课程编号、课程名称、最高分、最低分
SELECT
	sc.`courseid` AS 课程编号,
	c.`coursename` AS 课程名称,
	MAX(sc.`score`) AS 最高分,
	MIN(sc.`score`) AS 最低分
FROM scoreinfo AS sc
INNER JOIN courseinfo AS c ON sc.`courseid` = c.`courseid`
GROUP BY sc.`courseid`;

-- 23、查询只选修了一门功课的学生的学号和姓名
SELECT 
	sc.`studentid` AS 学生编号,
	s.`studentname` AS 学生姓名
FROM scoreinfo AS sc
INNER JOIN studentinfo AS s
ON sc.`studentid` = s.`studentid`
GROUP BY sc.`studentid`
HAVING COUNT(sc.`courseid`) = 1;

-- 24、查询学过张老师教的全部课程的学生的学号和姓名
SELECT
	sc.`studentid` AS 学生编号,
	s.`studentname` AS 学生姓名
FROM scoreinfo AS sc
INNER JOIN courseinfo AS c ON sc.`courseid` = c.`courseid`
INNER JOIN teacherinfo AS t ON c.`teacherid` = t.`teacherid` AND t.`teachername` = '张老师'
INNER JOIN studentinfo AS s ON sc.`studentid` = s.`studentid`
GROUP BY sc.`studentid`
HAVING COUNT(sc.`courseid`) = (
-- 张老师教的课程数量
SELECT COUNT(courseinfo.`courseid`)
FROM courseinfo
INNER JOIN teacherinfo
ON courseinfo.`teacherid` = teacherinfo.`teacherid` AND teacherinfo.`teachername` = '张老师');

-- 25、学生信息表中被人删除了若干条记录，现在需要查询出第4行至第6行的记录来使用（考虑多种实现）
-- 写法1：直接使用MySQL的LIMIT关键字就可以实现
SELECT * FROM studentinfo LIMIT 3,3;

-- 写法2：
-- 如果数据没有被删除过，那么设置了studentid自增且为主键
-- 第4行的studentid就是4，第6行的studentid就是6
SELECT * FROM studentinfo WHERE studentid >= 4 AND studentid <= 6;
SELECT * FROM studentinfo WHERE studentid BETWEEN 4 AND 6;
-- 数据被删除后，也不知道删除的是哪些行
-- 所以考虑取出前6行，进行倒序排列，再取出前3行，再倒序
SELECT *
FROM 
(
	SELECT *
	FROM
	(
		SELECT * 
		FROM (SELECT * FROM studentinfo LIMIT 0, 6) AS temp1 
		ORDER BY temp1.studentid DESC
	) AS temp2 LIMIT 0, 3
) AS temp3
ORDER BY temp3.studentid ASC;